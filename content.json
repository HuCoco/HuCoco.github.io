{"meta":{"title":"HuCoco","subtitle":null,"description":null,"author":"Hu Ke","url":"http://HuCoco.com"},"pages":[{"title":"about","date":"2018-03-01T15:06:49.000Z","updated":"2018-03-01T15:06:49.223Z","comments":true,"path":"about/index.html","permalink":"http://HuCoco.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Do Ray Tracing","slug":"Do-Ray-Tracing","date":"2018-07-10T05:54:10.000Z","updated":"2018-07-10T06:50:01.867Z","comments":true,"path":"2018/07/10/Do-Ray-Tracing/","link":"","permalink":"http://HuCoco.com/2018/07/10/Do-Ray-Tracing/","excerpt":"Generate RayGenerate a ray that goes from the camera’s origin through the pixel location (pixelPosX, pixelPosY) of the camera. Note that pixelPosX and pixelPosY can be non-integer. The image origin is at the bottom-leftmost corner, that means: The bottom-leftmost corner of the image is (0, 0). The top-rightmost corner of the image is (imageWidth, imageHeight). The center of the bottom-leftmost pixel is (0.5, 0.5). The center of the top-rightmost pixel is (imageWidth-0.5, imageHeight-0.5). 12345Ray getRay( double pixelPosX, double pixelPosY ) const&#123; Vector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV; return Ray( mCOP, imgPos - mCOP );&#125;","text":"Generate RayGenerate a ray that goes from the camera’s origin through the pixel location (pixelPosX, pixelPosY) of the camera. Note that pixelPosX and pixelPosY can be non-integer. The image origin is at the bottom-leftmost corner, that means: The bottom-leftmost corner of the image is (0, 0). The top-rightmost corner of the image is (imageWidth, imageHeight). The center of the bottom-leftmost pixel is (0.5, 0.5). The center of the top-rightmost pixel is (imageWidth-0.5, imageHeight-0.5). 12345Ray getRay( double pixelPosX, double pixelPosY ) const&#123; Vector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV; return Ray( mCOP, imgPos - mCOP );&#125; Nearest SurfaceFind whether and where the ray hits some surface. Take the nearest hit point. 12345678910111213141516bool hasHitSomething = false;double nearest_t = DEFAULT_TMAX;SurfaceHitRecord nearestHitRec;for ( int i = 0; i &lt; scene.numSurfaces; i++ )&#123; SurfaceHitRecord tempHitRec; bool hasHit = scene.surfacep[i]-&gt;hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec ); if ( hasHit &amp;&amp; tempHitRec.t &lt; nearest_t ) &#123; hasHitSomething = true; nearest_t = tempHitRec.t; nearestHitRec = tempHitRec; &#125;&#125; ShadowAdd to result the phong lightin contributed by each point light source. Compute shadow if hasShadow is true. 123456789101112131415161718192021222324252627bool shadow = true;for(int i = 0 ; i &lt; scene.numPtLights ; i++)&#123; Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p; double MaxLength = (Lin).length(); double invLen = 1 / MaxLength; Vector3d L = (Lin)*invLen; if(hasShadow) &#123; Ray newRay(nearestHitRec.p,L); for(int j = 0 ; j &lt; scene.numSurfaces ; j++) &#123; if(scene.surfacep[j]-&gt;shadowHit(newRay, DEFAULT_TMIN, MaxLength)) &#123; shadow = false; break; &#125; &#125; if(shadow == false) &#123; continue; &#125; &#125; result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);&#125; ReflectionAdd to result the reflection of the scene. 123456if(reflectLevels &gt; 0)&#123; Vector3d dir = mirrorReflect(V, N); Ray rRay(nearestHitRec.p,dir); result += nearestHitRec.mat_ptr-&gt;k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);&#125; Hammersley SamplingWe know that binary numbers are used to represent data in the computer. The corresponding relations between decimal and binary systems are shown in the following table. Decimal Binary 1 1 2 10 3 11 4 100 And Hammersley Sampling is to generate uniformly distributed 2D random sampliong points by using this characteristics. It constructs a value by implementing a Radical Inverse method for a binary number. Its process is as follows Decimal Binary Radical Inverse Value 1 1 .1 = 1 * 1/2 0.5 2 10 .01 = 0 1/2 + 1 1/4 0.25 3 11 .11 = 1 1/2 + 1 1/4 0.75 4 100 .001 = 0 1/2 + 0 1/4 + 1 * 1/8 0.125 Constructing a set of 2D random sampling points for Hammersley Sampling \\phi(i) = RadicalInverse(i)P_i = (x_i,y_i) = (i/N,\\phi(i))Anti-AliasingIn ray tracing world, Anti-Aliasing method is simply, it only just increase the amount of sampling. Anti-Aliasing in GLSL123456for(uint i = 0 ; i &lt; NumSample; i++)&#123; vec2 offset = Hammersley(i, NumSample); Ray ray = getRay(float(pos.x) + offset.x, float(pos.y) + offset.y); // create ray from camera color += RayTrace(ray,ReflectLevels,HasShadow);&#125; Code12345678910111213141516171819202122for (uint32_t y = task-&gt;beginHeight; y &lt; task-&gt;endHeight; y++)&#123; for (uint32_t x = 0; x &lt; task-&gt;width; x++) &#123; Color pixelColor = Color(0, 0, 0); for (uint32_t i = 0; i &lt; task-&gt;numSample; i++) &#123; float xx; float yy; Math::Hammersley(i, task-&gt;numSample, &amp;xx, &amp;yy); double pixelPosX = x + xx; double pixelPosY = y + yy; Ray ray = task-&gt;scene-&gt;camera.getRay(pixelPosX, pixelPosY); pixelColor += Raytrace::TraceRay(ray, *task-&gt;scene, task-&gt;reflectLevels, task-&gt;hasShadow); &#125; pixelColor /= (float)task-&gt;numSample; pixelColor.clamp(); task-&gt;output-&gt;setPixel(x, y, pixelColor); &#125; // printf( \"%d \", y );&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Color Raytrace::TraceRay( const Ray &amp;ray, const Scene &amp;scene, int reflectLevels, bool hasShadow )&#123; Ray uRay( ray ); uRay.makeUnitDirection(); // Normalize ray direction. bool hasHitSomething = false; double nearest_t = DEFAULT_TMAX; SurfaceHitRecord nearestHitRec; for ( int i = 0; i &lt; scene.numSurfaces; i++ ) &#123; SurfaceHitRecord tempHitRec; bool hasHit = scene.surfacep[i]-&gt;hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec ); if ( hasHit &amp;&amp; tempHitRec.t &lt; nearest_t ) &#123; hasHitSomething = true; nearest_t = tempHitRec.t; nearestHitRec = tempHitRec; &#125; &#125; if ( !hasHitSomething ) return scene.backgroundColor; nearestHitRec.normal.makeUnitVector(); Vector3d N = nearestHitRec.normal; // Unit vector. Vector3d V = -uRay.direction(); // Unit vector. Color result( 0.0f, 0.0f, 0.0f ); // The result will be accumulated here. bool shadow = 1.0f; for(int i = 0 ; i &lt; scene.numPtLights ; i++) &#123; Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p; double MaxLength = (Lin).length(); double invLen = 1 / MaxLength; Vector3d L = (Lin)*invLen; if(hasShadow) &#123; Ray newRay(nearestHitRec.p,L); for(int j = 0 ; j &lt; scene.numSurfaces ; j++) &#123; if(scene.surfacep[j]-&gt;shadowHit(newRay, DEFAULT_TMIN, MaxLength)) &#123; shadow = true; break; &#125; &#125; if(shadow == false) &#123; continue; &#125; &#125; result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]); &#125; result += scene.amLight.I_a * nearestHitRec.mat_ptr-&gt;k_a; if(reflectLevels &gt; 0) &#123; Vector3d dir = mirrorReflect(V, N); Ray rRay(nearestHitRec.p,dir); result += nearestHitRec.mat_ptr-&gt;k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow); &#125; return result;&#125;","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Lighting and Materials","slug":"Lighting_and_Materials","date":"2018-07-09T12:59:05.000Z","updated":"2018-07-10T06:46:18.372Z","comments":true,"path":"2018/07/09/Lighting_and_Materials/","link":"","permalink":"http://HuCoco.com/2018/07/09/Lighting_and_Materials/","excerpt":"LightingCaculate lighting effect is extremely complicated and it depends on way too many factors in real world, therefore we use a method based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the Phong lighting model. Phong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area.","text":"LightingCaculate lighting effect is extremely complicated and it depends on way too many factors in real world, therefore we use a method based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the Phong lighting model. Phong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area. In 1977 the Blinn-Phong lighting model was introduced by James F. Blinn as an extension to the Phong shading we’ve used so far. The Blinn-Phong model is largely similar, but approaches the specular model slightly different which as a result overcomes our problem. Instead of relying on a reflection vector we’re using a so called halfway vector that is a unit vector exactly halfway between the view direction and the light direction. The closer this halfway vector aligns with the surface’s normal vector, the higher the specular contribution. Getting the halfway vector is easy, we add the light’s direction vector and view vector together and normalize the result: \\overline{H} = \\frac{\\overline{V} + \\overline{H}} {\\begin{Vmatrix} \\overline{V} + \\overline{H} \\end{Vmatrix}}MatrialsThe major building blocks of the Phong model consist of 3 components: ambient, diffuse and specular lighting. Below you can see what these lighting components actually look like: Ambient lighting: even when it is dark there is usually still some light somewhere in the world (the moon, a distant light) so objects are almost never completely dark. To simulate this we use an ambient lighting constant that always gives the object some color. Diffuse lighting: simulates the directional impact a light object has on an object. This is the most visually significant component of the lighting model. The more a part of an object faces the light source, the brighter it becomes. 1ptLight.I_source * mat-&gt;k_d * NL Specular lighting: simulates the bright spot of a light that appears on shiny objects. Specular highlights are often more inclined to the color of the light than the color of the object. 123float RVn = pow( (float) dot( V, R ), (float) mat-&gt;n); \\\\Phong lighting modelfloat RVn = pow( (float) dot( N, H ), (float) mat-&gt;n); \\\\Blinn-Phong lighting modelptLight.I_source * mat-&gt;k_r * RVn); Phong lighting model1234567891011static Color computePhongLighting( const Vector3d &amp;L, const Vector3d &amp;N, const Vector3d &amp;V, const EMPMaterial* mat, const PointLightSource &amp;ptLight )&#123; Vector3d NN = ( dot( L, N ) &gt;= 0.0 )? N : -N; Vector3d R = mirrorReflect( L, NN ); float NL = (float) dot( NN, L ); float RVn = pow( (float) dot( V, R ), (float) mat-&gt;n ); return ptLight.I_source * ( mat-&gt;k_d * NL + mat-&gt;k_r * RVn );&#125; Blinn-Phong lighting model12345678910111213static Color computeBlinnPhongLighting(const Vector3d &amp;L, const Vector3d &amp;N, const Vector3d &amp;V, const EMPMaterial* mat, const PointLightSource &amp;ptLight)&#123; Vector3d NN = (dot(L, N) &gt;= 0.0) ? N : -N; Vector3d R = mirrorReflect(L, NN); Vector3d H = L + V; H = H.makeUnitVector(); float NL = (float)dot(NN, L); float RVn = pow((float)dot(N, H), (float)mat-&gt;n); return ptLight.I_source * (mat-&gt;k_d * NL + mat-&gt;k_r * RVn);&#125; those lighting models are experience model, it is not base on physically visual effect. physically based rendering is a collection of render techniques, these techniques will be introduced in other series of articles. Physically Based Rendering Series Catalogue, and the series is in progress.","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Ray and Camera","slug":"Ray-and-Camera","date":"2018-07-07T08:08:16.000Z","updated":"2018-07-07T16:23:13.252Z","comments":true,"path":"2018/07/07/Ray-and-Camera/","link":"","permalink":"http://HuCoco.com/2018/07/07/Ray-and-Camera/","excerpt":"RayFinding ray-object intersection and computing surface normal is central to ray tracing. Ray representations: Two 3D vectors Ray origin position Ray direction vector Parametric form $P(t) = origin + t \\times direction$","text":"RayFinding ray-object intersection and computing surface normal is central to ray tracing. Ray representations: Two 3D vectors Ray origin position Ray direction vector Parametric form $P(t) = origin + t \\times direction$ Computing Reflection / Refraction Rays Snell’s law\\mu_1sin\\theta = \\mu_2sin\\phiReflectionR = 2 (N \\cdot L) N - LRefraction\\mu = \\frac{\\mu_1}{\\mu_2}T = -\\mu L + (\\mu (N \\cdot L) - \\sqrt{1 - \\mu^2 (1 - (N \\cdot L)^2)})NRecursive Ray TracingFor each reflection/refraction ray spawned, we can trace it just like tracing the original ray. When to stop recursion? When the surface is totally diffuse (and opaque) When reflected/refracted ray hits nothing When maximum recursion depth is reached When the contribution of the reflected/refracted ray to thecolor at the top level is too small $(K_{rg1} | K_{tg1}) \\times \\cdots \\times (k_{rg(n-1)}|k_{tg(n-1)}) &lt; threshold $ CameraCamera view &amp; image resolution Camera position and orientation in world coordinate frame Similar to gluLookAt() Field of view Similar to gluPerspective(), but no need near &amp; far plane Image resolution Number of pixels in each dimension 1234567891011121314151617181920212223242526Camera &amp;Camera::setCamera( const Vector3d &amp;eye, const Vector3d &amp;lookAt, const Vector3d &amp;upVector, double left, double right, double bottom, double top, double near, int image_width, int image_height )&#123; assert( image_width &gt; 0 &amp;&amp; image_height &gt; 0 ); mImageWidth = image_width; mImageHeight = image_height; mCOP = eye; Vector3d cop_n = (eye - lookAt).unitVector(); Vector3d cop_u = cross( upVector.unitVector(), cop_n ); Vector3d cop_v = cross( cop_n, cop_u ); mImageOrigin = mCOP + ( left * cop_u ) + ( bottom * cop_v ) + ( -near * cop_n ); mImageU = (right - left) * cop_u; mImageV = (top - bottom) * cop_v; return (*this);&#125;Ray getRay( double pixelPosX, double pixelPosY ) const&#123; Vector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV; return Ray( mCOP, imgPos - mCOP );&#125;","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Various surfaces","slug":"Various-surfaces","date":"2018-07-06T15:28:40.000Z","updated":"2018-07-07T08:33:09.676Z","comments":true,"path":"2018/07/06/Various-surfaces/","link":"","permalink":"http://HuCoco.com/2018/07/06/Various-surfaces/","excerpt":"Ray-Plane IntersectionPlane is often represented in implicit form : Ax + By + Cz + D = 0Equivalent: N \\cdot P + D = 0where $N = [A B C]^T$ and $P = [x y z]^T$ To find ray-plane intersection, substitute ray equation $P(t)$ into plane equation: We get $N \\cdot P + D = 0$. Sovle for $t$ to get $t_0$. if $t_0$ is infinity, no intersection (ray is parallel to plane). Intersection point is $P(t_0)$. Verify that intersection is not behind ray origin. The normal at the intersection is $N$ (or $-N$)","text":"Ray-Plane IntersectionPlane is often represented in implicit form : Ax + By + Cz + D = 0Equivalent: N \\cdot P + D = 0where $N = [A B C]^T$ and $P = [x y z]^T$ To find ray-plane intersection, substitute ray equation $P(t)$ into plane equation: We get $N \\cdot P + D = 0$. Sovle for $t$ to get $t_0$. if $t_0$ is infinity, no intersection (ray is parallel to plane). Intersection point is $P(t_0)$. Verify that intersection is not behind ray origin. The normal at the intersection is $N$ (or $-N$) 12345678910111213141516bool Plane::hit( const Ray &amp;r, double tmin, double tmax, SurfaceHitRecord &amp;rec ) const &#123; Vector3d N( A, B, C ); double NRd = dot( N, r.direction() ); double NRo = dot( N, r.origin() ); double t = (-D - NRo) / NRd; if ( t &lt; tmin || t &gt; tmax ) &#123; return false; &#125; rec.t = t; rec.p = r.pointAtParam(t); rec.normal = N; rec.mat_ptr = matp; return true;&#125; Ray-Sphere IntersectionSphere (centered at origin) is often represented in implicit form: x^2 + y^2 + z^2 - r^2 = 0Equivalent: P \\cdot P - r^2 = 0To find ray-plane intersection, substitute ray equation P(t) into plane equation: We get $P \\cdot P - r^2 = 0$: P(t) \\cdot P(t) - r^2 = 0(R_o + tR_d) \\cdot (R_o + tR_d) - r^2 = 0R_d \\cdot R_dt^2 + 2R_d \\cdot R_o + R_o \\cdot R_o - r^2 = 0$R_o$ is ray origin, $R_d$ is ray direction. It is a quadratic equation in the form $at^2 + bt + c = 0$ $a = R_o \\cdot R_o = 1$ (Since $|R_d| = 1$) $b = 2R_d \\cdot R_o$ $c = R_o \\cdot R_o - r^2$ Discriminant: $d = b^2 + 4ac$ Solution: $t_\\pm = \\frac{-b\\pm\\sqrt{b^2 + 4ac}}{2a}$ Choose $t_0$ as the closest positive $t$ value ($t_+$ + or $t_-$) The normal at the intersection point is $P(t_0)/|P(t_0)|$ Very easy to compute, that is why most ray tracing images have spheres. 1234567891011121314151617181920212223bool Sphere::hit( const Ray &amp;r, double tmin, double tmax, SurfaceHitRecord &amp;rec ) const &#123; Vector3d Rd = r.direction(); Vector3d Ro = r.origin() - center; double a = dot(Rd,Rd); double b = 2.0 * dot(Rd, Ro); double c = dot(Ro,Ro) - pow(radius, 2); double d = pow(b, 2) - 4.0 * a * c; if(d &lt; 0) &#123; return false; &#125; double t = (-b - sqrt(d)) / (2.0f * a); if ( t &gt;= tmin &amp;&amp; t &lt;= tmax ) &#123; rec.t = t ; rec.p = r.pointAtParam(t); rec.normal = (Ro + t * Rd) / radius; rec.mat_ptr = matp; return true; &#125; return false;&#125; Ray-Box IntersectionTo find ray-box intersection: For each pair of parallel plane, find the distance to the first plane ($t_{near}$) and to the second plane ($t_{far}$). Keep the largest $t_{near}$ so far, and smallest $t_{far}$ so far. If largest $t_{near}$ &gt; smallest $t_{far}$ , no intersection. Otherwise, the intersection is at P(largest $t_{near}$ ) Ray-Triangle IntersectionFinding intersection between a ray and a general polygon is difficult. Compute ray-plane intersection Determine whether intersection is within polygon Tedious for non-convex polygon Interpolation of attributes at the vertices are not well-defined Much easier to find ray-triangle intersection Can use the barycentric coordinates method. Interpolation of attributes at the vertices are well-defined using the barycentric coordinates. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bool Triangle::hit( const Ray &amp;r, double tmin, double tmax, SurfaceHitRecord &amp;rec ) const &#123; double A = v0.x() - v1.x(); double B = v0.y() - v1.y(); double C = v0.z() - v1.z(); double D = v0.x() - v2.x(); double E = v0.y() - v2.y(); double F = v0.z() - v2.z(); double G = r.direction().x(); double H = r.direction().y(); double I = r.direction().z(); double J = v0.x() - r.origin().x(); double K = v0.y() - r.origin().y(); double L = v0.z() - r.origin().z(); double EIHF = E*I - H*F; double GFDI = G*F - D*I; double DHEG = D*H - E*G; double denom = (A*EIHF + B*GFDI + C*DHEG); double beta = (J*EIHF + K*GFDI + L*DHEG) / denom; if ( beta &lt; 0.0 || beta &gt; 1.0 ) return false; double AKJB = A*K - J*B; double JCAL = J*C - A*L; double BLKC = B*L - K*C; double gamma = (I*AKJB + H*JCAL + G*BLKC) / denom; if ( gamma &lt; 0.0 || beta + gamma &gt; 1.0 ) return false; double t = -(F*AKJB + E*JCAL + D*BLKC) / denom; if ( t &gt;= tmin &amp;&amp; t &lt;= tmax ) &#123; // We have a hit -- populat hit record. rec.t = t; rec.p = r.pointAtParam(t); double alpha = 1.0 - beta - gamma; rec.normal = alpha * n0 + beta * n1 + gamma * n2; rec.mat_ptr = matp; return true; &#125; return false;&#125; Barycentric CoordinatesThe barycentric coordinates of a point P on a triangle $ABC$ is ($ \\alpha $, $ \\beta $, $ \\gamma $) such that: P = \\alpha A + \\beta B + \\gamma Cwhere \\alpha + \\beta + \\gamma = 1and 0 \\leq \\alpha,\\beta,\\gamma \\leq 1We can rewrite it as: P = (1 - \\beta - \\gamma)A + \\beta B + \\gamma CP = A + \\beta(B-A) + \\gamma(C-A) To find ray-triangle intersection, we let: P(t) = A + \\beta(B-A) + \\gamma(C-A)R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)Solve for $t$, $\\beta$ and $\\gamma$ Intersection if $\\beta + \\gamma &lt; 1$ and $\\beta,\\gamma &gt; 0$ and $t &gt; 0$ Expand &amp;R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)&amp; \\begin{cases} R_{ox} + tR_{dx} = A_x + \\beta(B_x-A_x) + \\gamma(C_x + A_x) \\\\ R_{oy} + tR_{dy} = A_y + \\beta(B_y-A_y) + \\gamma(C_y + A_y) \\\\ R_{oz} + tR_{dz} = A_z + \\beta(B_z-A_z) + \\gamma(C_z + A_z) \\\\ \\end{cases}we have 3 equations and 3 unknowns here. Regroup and write in matrix form \\begin{bmatrix} A_x - B_x &A_x - C_x &R_{dx}\\\\ A_y - B_y &A_y - C_y &R_{dy}\\\\ A_z - B_z &A_z - C_z &R_{dz} \\end{bmatrix} \\begin{bmatrix} \\beta \\\\ \\gamma \\\\ t \\end{bmatrix} = \\begin{bmatrix} A_x - R_{ox} \\\\ A_y - R_{oy} \\\\ A_z - R_{oz} \\end{bmatrix}Use Cramer’s Rule to solve for $t$, $\\beta$ and $\\gamma$ \\beta = \\frac { \\begin{vmatrix} A_x - R_{ox} &A_x-C_x &R_{dx} \\\\ A_y - R_{oy} &A_y-C_y &R_{dy} \\\\ A_z - R_{oz} &A_z-C_z &R_{dz} \\end{vmatrix} } { |A| } \\gamma = \\frac { \\begin{vmatrix} A_x - B_{x} &A_x-R_{ox} &R_{dx} \\\\ A_y - B_{y} &A_y-R_{oy} &R_{dy} \\\\ A_z - B_{z} &A_z-R_{oz} &R_{dz} \\end{vmatrix} } { |A| } t= \\frac { \\begin{vmatrix} A_x - B_{x} &A_x - C_{x} &A_x-R_{ox} \\\\ A_y - B_{y} &A_x - C_{x} &A_y-R_{oy} \\\\ A_z - B_{z} &A_x - C_{x} &A_z-R_{oz} \\end{vmatrix} } { |A| }12345678910111213141516171819202122232425262728293031323334bool Triangle::hit( const Ray &amp;r, double tmin, double tmax, SurfaceHitRecord &amp;rec ) const &#123; Vector3d e1 = v1 - v0; Vector3d e2 = v2 - v0; Vector3d p = cross( r.direction(), e2 ); double a = dot( e1, p ); double f = 1.0 / a; Vector3d s = r.origin() - v0; double beta = f * dot( s, p ); if ( beta &lt; 0.0 || beta &gt; 1.0 ) &#123; return false; &#125; Vector3d q = cross( s, e1 ); double gamma = f * dot( r.direction(), q ); if ( gamma &lt; 0.0 || beta + gamma &gt; 1.0 ) &#123; return false; &#125; double t = f * dot( e2, q ); if ( t &gt;= tmin &amp;&amp; t &lt;= tmax ) &#123; rec.t = t; rec.p = r.pointAtParam(t); double alpha = 1.0 - beta - gamma; rec.normal = alpha * n0 + beta * n1 + gamma * n2; rec.mat_ptr = matp; return true; &#125; return false;&#125; Advantages of Barycentric Intersection Efficient No need to store plane equation Barycentric coordinates are useful for linear interpolation of normal vectors, texture coordinates, and other attributes at the vertices For example, the interpolated normal at $P$ is: N_p = (1 - \\beta - \\gamma)N_A + \\beta N_B + \\gamma N_Cand all vector should do a normalization. The “Epsilon” ProblemShould not accept intersection for very small positive $t$ May falsely intersect the surface at the ray origin Method 1: Use an epsilon value $\\varepsilon$ &gt; 0, and accept an intersection only if its $t &gt; \\varepsilon$. Method 2: When a new ray is spawned, advanced the ray origin by an epsilon distance $\\varepsilon$ in the ray direction","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Ray Tracing Overview","slug":"Theory-of-Ray-Tracing","date":"2018-07-05T12:09:50.000Z","updated":"2018-07-06T15:27:07.119Z","comments":true,"path":"2018/07/05/Theory-of-Ray-Tracing/","link":"","permalink":"http://HuCoco.com/2018/07/05/Theory-of-Ray-Tracing/","excerpt":"Overview In 3D compute graphics, ray tracing is rendering technique for generating an visual image by tracing the path of light. it has better effect than either ray casting and scan-line rendering techniques. Typically, there are two question need be deal: What object has been seen? What color of the object is under the influence of light and environment? In nature, a ray will travel to a surface that stop ray traveling, or until out of energy eventually disappears.there are four things might happen with light ray: absorption, reflection, refraction, fluorescence,","text":"Overview In 3D compute graphics, ray tracing is rendering technique for generating an visual image by tracing the path of light. it has better effect than either ray casting and scan-line rendering techniques. Typically, there are two question need be deal: What object has been seen? What color of the object is under the influence of light and environment? In nature, a ray will travel to a surface that stop ray traveling, or until out of energy eventually disappears.there are four things might happen with light ray: absorption, reflection, refraction, fluorescence, Ray CastingIn ancient time, it was used for the study of perspective. The first ray tracing algorithm used for rendering was presented by Arthur Appel in 1968.[1] This algorithm has since been termed “ray casting”. The idea behind ray casting is to shoot rays from the eye, one per pixel, and find the closest object blocking the path of that ray. Think of an image as a screen-door, with each square in the screen being a pixel. This is then the object the eye sees through that pixel. Using the material properties and the effect of the lights in the scene, this algorithm can determine the shading of this object. The simplifying assumption is made that if a surface faces a light, the light will reach that surface and not be blocked or in shadow. The shading of the surface is computed using traditional 3D computer graphics shading models. One important advantage ray casting offered over older scanline algorithms was its ability to easily deal with non-planar surfaces and solids, such as cones and spheres. If a mathematical surface can be intersected by a ray, it can be rendered using ray casting. Elaborate objects can be created by using solid modeling techniques and easily rendered. Ray Tracingit almost like ray casting, but in ray tracing, it will generate some new ray from the closet intersection point. Reflection ray Refraction ray Shadow rays and this technique also called Recursive Ray Tracing. AdvantagesRay tracing’s popularity stems from its basis in a realistic simulation of lighting over other rendering methods (such as scanline rendering or ray casting). Effects such as reflections and shadows, which are difficult to simulate using other algorithms, are a natural result of the ray tracing algorithm. The computational independence of each ray makes ray tracing amenable to parallelization. DisadvantagesA serious disadvantage of ray tracing is performance (though it can in theory be faster than traditional scanline rendering depending on scene complexity vs. number of pixels on-screen). Scanline algorithms and other algorithms use data coherence to share computations between pixels, while ray tracing normally starts the process anew, treating each eye ray separately. However, this separation offers other advantages, such as the ability to shoot more rays as needed to perform spatial anti-aliasing and improve image quality where needed. Although it does handle interreflection and optical effects such as refraction accurately, traditional ray tracing is also not necessarily photorealistic. True photorealism occurs when the rendering equation is closely approximated or fully implemented. Implementing the rendering equation gives true photorealism, as the equation describes every physical effect of light flow. However, this is usually infeasible given the computing resources required. The realism of all rendering methods can be evaluated as an approximation to the equation. Ray tracing, if it is limited to Whitted’s algorithm, is not necessarily the most realistic. Methods that trace rays, but include additional techniques (photon mapping, path tracing), give far more accurate simulation of real-world lighting. Ray Tracing Detail ShadowAt each surface intersection point,a shadow ray is shot towards eachlight source to determine any occlusion between light source and surface point. ReferenceRay Tracing Wiki NUSRI Summer Programme 2016, 3D Graphics Rendering, Lecture 9 Ray Tracing, School of Computing National University of Singapore","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Physically Based Rendering Catalogue","slug":"Physically-Based-Rendering-Catalogue","date":"2018-07-04T13:57:47.000Z","updated":"2018-07-04T14:21:45.571Z","comments":true,"path":"2018/07/04/Physically-Based-Rendering-Catalogue/","link":"","permalink":"http://HuCoco.com/2018/07/04/Physically-Based-Rendering-Catalogue/","excerpt":"","text":"This is catalogue of Physically Based Rendering, I will update it if I have free time.(It’s means I don’t know what time I will finish one of them.) Theory of Physically Based Rendering The microfacet model BRDF Lighting IBL","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"PBR","slug":"Graphics/PBR","permalink":"http://HuCoco.com/categories/Graphics/PBR/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"PBR","slug":"PBR","permalink":"http://HuCoco.com/tags/PBR/"}]},{"title":"Ray Tracing Catalogue","slug":"Ray-Tracing-Catalogue","date":"2018-07-04T13:26:13.000Z","updated":"2018-07-09T12:58:21.415Z","comments":true,"path":"2018/07/04/Ray-Tracing-Catalogue/","link":"","permalink":"http://HuCoco.com/2018/07/04/Ray-Tracing-Catalogue/","excerpt":"","text":"This is catalogue of Ray Tracing, I will update it if I have free time.(It’s means I don’t know what time I will finish one of them.) Theory of ray tracing Ray, Scene and Camera Various surfaces Materials Do ray tracing Shadow Reflection Ambient Occlusion Blur","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"SSE Instruction List","slug":"SSE-Instruction-List","date":"2018-03-26T14:22:53.000Z","updated":"2018-03-26T14:50:20.776Z","comments":true,"path":"2018/03/26/SSE-Instruction-List/","link":"","permalink":"http://HuCoco.com/2018/03/26/SSE-Instruction-List/","excerpt":"","text":"move instruction Instruction Description movaps move 4 alignment single precision value to xmm register movups move 4 non-alignment single precision value to xmm register movss move 1 alignment single precision value to low 4 bytes of register movlps move 2 alignment single precision value to low 8 bytes of register movhps move 2 alignment single precision value to high 8 bytes of register movlhps move 2 alignment single precision value to high 8 bytes of register from low 8 bytes movhlps move 2 alignment single precision value to low 8 bytes of register from high 8 bytes basic operation instruction Instruction Description addps add operation subps sub operation mulps mul operation divps div operation rcpps rcp opeartion sqrtps sqrt operation rsqrtps rcp sqrt operation maxps get max operation minps get min operation andps and operation andnps negation operation orps or operation xorps xor operation compared instruction Instruction Description cmpps compared operation cmpss compared operation comiss compared and set eflags register ucomiss compared and set eflags register those instruction will return a value: Return Value Description 0 Equal to 1 Less-than 2 Less than or equal to 3 Disorder 4 Not equal to 5 Greater than 6 Greater than or equal to 7 Order","categories":[{"name":"SIMD","slug":"SIMD","permalink":"http://HuCoco.com/categories/SIMD/"},{"name":"SSE","slug":"SIMD/SSE","permalink":"http://HuCoco.com/categories/SIMD/SSE/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"SIMD","slug":"SIMD","permalink":"http://HuCoco.com/tags/SIMD/"},{"name":"SSE","slug":"SSE","permalink":"http://HuCoco.com/tags/SSE/"}]},{"title":"Sorting Algorithm","slug":"Sorting-Algorithm","date":"2018-03-10T05:07:14.000Z","updated":"2018-03-10T05:34:49.563Z","comments":true,"path":"2018/03/10/Sorting-Algorithm/","link":"","permalink":"http://HuCoco.com/2018/03/10/Sorting-Algorithm/","excerpt":"8 Kind of Sorting AlgorithmBubble sort1234567def bubble_sort(lists): count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists","text":"8 Kind of Sorting AlgorithmBubble sort1234567def bubble_sort(lists): count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists Insertion sort1234567891011def insert_sort(lists): count = len(lists) for i in range(1, count): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j + 1] = lists[j] lists[j] = key j -= 1 return lists Shell Sort123456789101112131415161718def shell_sort(lists): count = len(lists) step = 2 group = count // step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lists[j] while k &gt;= 0: if lists[k] &gt; key: lists[k + group] = lists[k] lists[k] = key k -= group j += group group //= step return lists Selection Sort123456789def select_sort(lists): count = len(lists) for i in range(0, count): min = i for j in range(i + 1, count): if lists[min] &gt; lists[j]: min = j lists[min], lists[i] = lists[i], lists[min] return lists heap sort1234567891011121314151617181920212223def adjust_heap(lists, i, size): lchild = 2 * i + 1 rchild = 2 * i + 2 max = i if i &lt; size // 2: if lchild &lt; size and lists[lchild] &gt; lists[max]: max = lchild if rchild &lt; size and lists[rchild] &gt; lists[max]: max = rchild if max != i: lists[max], lists[i] = lists[i], lists[max] adjust_heap(lists, max, size) def build_heap(lists, size): for i in range(0, (size//2))[::-1]: adjust_heap(lists, i, size) def heap_sort(lists): size = len(lists) build_heap(lists, size) for i in range(0, size)[::-1]: lists[0], lists[i] = lists[i], lists[0] adjust_heap(lists, 0, i) Fast sorting1234567891011121314151617def quick_sort(lists, left, right): if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return lists Merging sorting123456789101112131415161718192021def merge(left, right): i, j = 0, 0 result = [] while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return result def merge_sort(lists): if len(lists) &lt;= 1: return lists num = len(lists) // 2 left = merge_sort(lists[:num]) right = merge_sort(lists[num:]) return merge(left, right)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://HuCoco.com/categories/Algorithm/Sort/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://HuCoco.com/tags/Python/"},{"name":"Sort","slug":"Sort","permalink":"http://HuCoco.com/tags/Sort/"}]},{"title":"N-Queens Problem","slug":"N-Queens-Problem","date":"2018-03-09T13:51:43.000Z","updated":"2018-03-09T14:43:00.190Z","comments":true,"path":"2018/03/09/N-Queens-Problem/","link":"","permalink":"http://HuCoco.com/2018/03/09/N-Queens-Problem/","excerpt":"N-Queens ProblemOverviewThe eight queens problem is a question with chess as the background: how to place eight queens on an 8×8 chess board so that no queen can directly eat other queens? In order to achieve this purpose, any two queens are not in the same horizontal, vertical or diagonal. The eight queen problem can be extended to the more general N-Queens Problem. more information about n-queens problem please google it. C++ Code123456789101112int NQueens(int n) &#123; int upperlim = (1 &lt;&lt; n) - 1, sum = 0; std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123; if(row == upperlim) &#123;++sum;return;&#125; for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123; pos = cur &amp; (-cur); cur -= pos; &#125; &#125;; dfs(0,0,0); return sum;&#125;","text":"N-Queens ProblemOverviewThe eight queens problem is a question with chess as the background: how to place eight queens on an 8×8 chess board so that no queen can directly eat other queens? In order to achieve this purpose, any two queens are not in the same horizontal, vertical or diagonal. The eight queen problem can be extended to the more general N-Queens Problem. more information about n-queens problem please google it. C++ Code123456789101112int NQueens(int n) &#123; int upperlim = (1 &lt;&lt; n) - 1, sum = 0; std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123; if(row == upperlim) &#123;++sum;return;&#125; for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123; pos = cur &amp; (-cur); cur -= pos; &#125; &#125;; dfs(0,0,0); return sum;&#125; Introductioninitialization1upperlim = (1 &lt;&lt; n) - 1, sum = 0; Upperlim value is n-bit binary 1. Recursive Function1234567std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123; if(row == upperlim) &#123;++sum;return;&#125; for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123; pos = cur &amp; (-cur); cur -= pos; &#125;&#125;; The function has three parameters: row : row ld : Left diagonal rd : Right diagonal Use these three parameters to determine whether a queen can be placed in a certain position. DiagramHere is a step-by-step illustration of the Six Queens question. 12345row = 000001ld = 000010rd = 000000cur = 111100pos = 000100 12345row = 000101ld = 001100rd = 000010 cur = 110000pos = 010000 12345row = 010101ld = 111000rd = 001001 cur = 000010pos = 000010 12345row = 010111ld = 110100rd = 000101 cur = 001000pos = 001000 12345row = 011111ld = 111000rd = 000110cur = 000000pos = 000000 The first round of search is completed, there is a kind of thought is the depth first search, is to find a solution and then press forward to the enemy’s capital to find second solution, because the eight queens problem belongs to the scope of the graph, so the idea of graph theory can be found in this problem.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Problems","slug":"Algorithm/Problems","permalink":"http://HuCoco.com/categories/Algorithm/Problems/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"},{"name":"Backtracking","slug":"Backtracking","permalink":"http://HuCoco.com/tags/Backtracking/"}]},{"title":"Topological Sort","slug":"Topological-Sort","date":"2018-03-08T12:14:15.000Z","updated":"2018-03-08T12:43:16.271Z","comments":true,"path":"2018/03/08/Topological-Sort/","link":"","permalink":"http://HuCoco.com/2018/03/08/Topological-Sort/","excerpt":"Topological Sort Chinese version address Topological SortOverviewTopological sorting means ordering a Directed Acyclic Graph(DAG) to get an ordered linear sequence. In this way, it may be understood more abstractly. For example, a project consists of four subsections A, B, C, and D, and A depends on B and D. C depends on D. Now to develop a plan to write A, B, C, D the order of execution. At this point, you can use topological sorting, which is used to determine the order in which things happen. In topological sorting, if there is a path from the vertex A to the vertex B, B appears behind the A in the ranking result. Algorithm Introduction Create a queue Q and a topological ordered result queue T. Put all the nodes that do not depend on the vertex in the Q. When Q has vertices, perform the following steps. Take a vertex n from Q (delete n from Q) and put it in T (add n to the result set). For every adjacent point m (n is the starting point and m is the ending point). Remove the edge (n, m). If m does not depend on the vertex, put b into Q. The vertex A does not depend on the vertex, which means there is no edge to the end of the A.","text":"Topological Sort Chinese version address Topological SortOverviewTopological sorting means ordering a Directed Acyclic Graph(DAG) to get an ordered linear sequence. In this way, it may be understood more abstractly. For example, a project consists of four subsections A, B, C, and D, and A depends on B and D. C depends on D. Now to develop a plan to write A, B, C, D the order of execution. At this point, you can use topological sorting, which is used to determine the order in which things happen. In topological sorting, if there is a path from the vertex A to the vertex B, B appears behind the A in the ranking result. Algorithm Introduction Create a queue Q and a topological ordered result queue T. Put all the nodes that do not depend on the vertex in the Q. When Q has vertices, perform the following steps. Take a vertex n from Q (delete n from Q) and put it in T (add n to the result set). For every adjacent point m (n is the starting point and m is the ending point). Remove the edge (n, m). If m does not depend on the vertex, put b into Q. The vertex A does not depend on the vertex, which means there is no edge to the end of the A. The above diagram is an example of a demonstration of the topological sort. Add B and C to the sorting result. Vertex B and vertex C are not dependent on the vertices, so C and C added to the result set T. Suppose ABCDEFG is stored sequentially, so visit B first and then C again. After accessing B, remove the edges (B, A) and (B, D) and add A and D to the queue Q. Similarly, remove the edges (C, F) and (C, G) and add F and G to Q. Add B to the sorted result, and then remove the edges (B, A) and (B, D); at this point, since A and D do not depend on vertices, add A and D to queue Q. The C is added to the sorting result, then the edge (C, F) and (C, G) are removed; at this time, since F has a dependency on the vertex D, G has a dependency on the vertex A, so it does not handle F and G. A, D is added to the sorting result in turn. After the first step, both A and D are not dependent on the vertex, accessing the A first and then accessing the D according to the storage order. After the access, the edges of the vertex A and the vertex D are deleted. Add E, F, G to the sorting result. C++ ImplementationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://HuCoco.com/categories/Algorithm/Sort/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"}]},{"title":"Breadth First Search","slug":"Breadth-First-Search","date":"2018-03-07T15:18:11.000Z","updated":"2018-03-07T16:04:30.235Z","comments":true,"path":"2018/03/07/Breadth-First-Search/","link":"","permalink":"http://HuCoco.com/2018/03/07/Breadth-First-Search/","excerpt":"Breadth First Search Chinese version address Breadth First SearchOverviewThe breadth first search algorithm, also known as “width first search” or “horizontal priority search”, is called BFS. From a vertex in the graph, each of the not visited adjacent points of the V is accessed in turn after accessing the starting vertex, then the adjacency points are accessed in turn from these adjacent points, and the adjacent points of the vertex to be accessed are accessed before the adjacent points of the vertices that are accessed, until all the adjacent points of the vertices are accessed. If the vertices are not accessed at this time, we need to select another vertex which has never been visited as a new starting point, repeat the above process until all the vertices in the graph are accessed. In other words, the process of breadth first search is the starting point and from near to far, access to the path and the path length of the starting vertex and the path length of 1,2… DiagramBreadth first search for undirected graphsThe following is an example of undirected graph, to demonstrate the depth-first search.","text":"Breadth First Search Chinese version address Breadth First SearchOverviewThe breadth first search algorithm, also known as “width first search” or “horizontal priority search”, is called BFS. From a vertex in the graph, each of the not visited adjacent points of the V is accessed in turn after accessing the starting vertex, then the adjacency points are accessed in turn from these adjacent points, and the adjacent points of the vertex to be accessed are accessed before the adjacent points of the vertices that are accessed, until all the adjacent points of the vertices are accessed. If the vertices are not accessed at this time, we need to select another vertex which has never been visited as a new starting point, repeat the above process until all the vertices in the graph are accessed. In other words, the process of breadth first search is the starting point and from near to far, access to the path and the path length of the starting vertex and the path length of 1,2… DiagramBreadth first search for undirected graphsThe following is an example of undirected graph, to demonstrate the depth-first search. Breadth first search of the graph above, starting with vertex A: Steps: Access to A. Access C, D, F in turn. After visiting A, next visit A’s adjoining point. the vertices A,B,C,D,E,F,G are stored in order, so first visit C, after visiting C, next to visit D and F. Access B, G, in turn. After C, D, and F are accessed in the second step, then their adjacency points are accessed in turn. Next first access the adjacency point B of C, and then access the adjacency point G of the F. Access to E. After accessing B and G in the third step, the adjacent points are accessed in turn. Only G has a adjacency point E, so access to the adjacency point E of the G. C++ ImplememtationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress Breadth first search for undirected graphsThe following is an example of directed graph, to demonstrate the Breadth first search. Breadth first search of the graph above, starting with vertex A: Steps: Access to A. Access to B. Access C, E, F in turn. After accessing the B, next to the other vertex of the B’s out-edge, that is, C, E, and F. Access D, G in turn. After accessing C, E, and F, the other vertices of the out-edge of their are accessed in turn. C++ ImplememtationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Search","slug":"Algorithm/Search","permalink":"http://HuCoco.com/categories/Algorithm/Search/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"}]},{"title":"Depth First Search","slug":"Depth-First-Search","date":"2018-03-07T14:47:44.000Z","updated":"2018-03-07T16:04:48.770Z","comments":true,"path":"2018/03/07/Depth-First-Search/","link":"","permalink":"http://HuCoco.com/2018/03/07/Depth-First-Search/","excerpt":"Depth First Search Chinese version address Depth First SearchOverviewDepth first search of the graph is similar to the preorder traversal of the tree. Suppose that the initial state is that all the vertices in the graph are not accessed, then starting from a vertex and first access to it, nextly, the depth first search traversal from each of its non-accessed adjacency points in turn, until all the vertices that have a path to the starting vertex in the graph are accessed. If there are other vertices that are not accessed, then choose another unvisited vertex as a starting point, repeat the above process until all graph vertices have been visited. DiagramDepth first search for undirected graphsThe following is an example of undirected graph, to demonstrate the depth first search.","text":"Depth First Search Chinese version address Depth First SearchOverviewDepth first search of the graph is similar to the preorder traversal of the tree. Suppose that the initial state is that all the vertices in the graph are not accessed, then starting from a vertex and first access to it, nextly, the depth first search traversal from each of its non-accessed adjacency points in turn, until all the vertices that have a path to the starting vertex in the graph are accessed. If there are other vertices that are not accessed, then choose another unvisited vertex as a starting point, repeat the above process until all graph vertices have been visited. DiagramDepth first search for undirected graphsThe following is an example of undirected graph, to demonstrate the depth first search. Depth first search of the graph above, starting with vertex A: Steps: Access to A. Access to C. Because the vertices A,B,C,D,E,F,G are stored in order in this paper, C is in front of D and F, so visit C first. Access to B. Because B before D, first visit B. Access to D. After having visited C’s adjacency point B at step 3, B has no unvisit adjacency points, thus, it returns to another adjacency point D that accesses C. Access to F. All adjacency point of B and C are accessed, so return to A and access to next adjaceny point of A. Access to G. Access to E. C++ ImplememtationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress Depth first search for directed graphsThe following is an example of directed graph, to demonstrate the depth first search. Depth first search of the graph above, starting with vertex A: Steps: Access to A. Access to B. After visiting A, the next vertex to which A should go is the vertex B that should be accessed next. Access to C. After visiting B, what should be followed is another vertex of B’s out-edge. Because C is the first one, so first visit it Access to E. Next to the other vertex of the out-edge of the C vertex. Access to D. Then visit the other vertices of E’s out edge, vertices B and D. Vertex B has already been visited, so visit vertex D. Access to F. Access to G. C++ ImplememtationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Search","slug":"Algorithm/Search","permalink":"http://HuCoco.com/categories/Algorithm/Search/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"}]},{"title":"Adjacency List Graph","slug":"Adjacency-List-Graph","date":"2018-03-05T16:40:11.000Z","updated":"2018-03-07T16:04:09.114Z","comments":true,"path":"2018/03/06/Adjacency-List-Graph/","link":"","permalink":"http://HuCoco.com/2018/03/06/Adjacency-List-Graph/","excerpt":"Adjacency List Graph Chinese version address Adjacency List GraphAdjacency List Undirected GraphAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency list. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains&lt;A,C&gt;, &lt;A,D&gt;, &lt;A,F&gt;, &lt;B,C&gt;, &lt;C,D&gt;, &lt;E,G&gt;, &lt;F,G&gt;, in total 7 edges. Since this is an undirected graph, the edge &lt;A,C&gt; and the edge &lt;C,A&gt; are the same edges. The table of edges is listed in alphabetical order..","text":"Adjacency List Graph Chinese version address Adjacency List GraphAdjacency List Undirected GraphAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency list. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains&lt;A,C&gt;, &lt;A,D&gt;, &lt;A,F&gt;, &lt;B,C&gt;, &lt;C,D&gt;, &lt;E,G&gt;, &lt;F,G&gt;, in total 7 edges. Since this is an undirected graph, the edge &lt;A,C&gt; and the edge &lt;C,A&gt; are the same edges. The table of edges is listed in alphabetical order.. Each vertex contains a linked list that records the index of vertexs. For example, the data of the nodes included in the linked list included in the second vertex (vertex C) is 0, 1, 3, and 0, 1, 3 corresponds to the index of A, B, D. C++ Definition1// Work in progress C++ Implementation1// Work in progress Adjacency Matrix Directed GraphAdjacency matrix directed graph refers to an directed graph represented by an adjacency list. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains &lt;A,B&gt;, &lt;B,C&gt;, &lt;B,E&gt;, &lt;B,F&gt;, &lt;C,E&gt;, &lt;D,C&gt;, &lt;E,B&gt;, &lt;E,D&gt;, &lt;F,G&gt;, in total 7 edges. Each vertex contains a linked list that records the index of vertexs. The linked list contains the index of the other vertex of the out-edge corresponding to this vertex. For example, the data of the first vertex (vertex B) in list is 2,4,5, this 2,4,5 corresponds to index of C, E, F, and C, E, F are the other vertices of B vertex’s out-edge. C++ Definition1// Work in progress C++ Implementation1// Work in progress","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Graph","slug":"Data-Structure/Graph","permalink":"http://HuCoco.com/categories/Data-Structure/Graph/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"}]},{"title":"Adjacency Matrix Graph","slug":"Adjacency-Matrix-Graph","date":"2018-03-05T16:40:02.000Z","updated":"2018-03-07T16:03:45.627Z","comments":true,"path":"2018/03/06/Adjacency-Matrix-Graph/","link":"","permalink":"http://HuCoco.com/2018/03/06/Adjacency-Matrix-Graph/","excerpt":"Adjacency Matrix Graph Chinese version address Adjacency Matrix GraphAdjacency Matrix Undirected GraphAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency matrix. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains, , , , , , , in total 7 edges. Since this is an undirected graph, the edge and the edge are the same edges. The table of edges is listed in alphabetical order.","text":"Adjacency Matrix Graph Chinese version address Adjacency Matrix GraphAdjacency Matrix Undirected GraphAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency matrix. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains, , , , , , , in total 7 edges. Since this is an undirected graph, the edge and the edge are the same edges. The table of edges is listed in alphabetical order. N/A A B C D E F G A 0 0 1 1 0 1 0 B 0 0 1 0 0 0 0 C 1 1 0 1 0 0 0 D 1 0 1 0 0 0 0 E 0 0 0 0 0 0 1 F 1 0 0 0 0 0 1 G 0 0 0 0 1 1 0 The matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that from the ith vertex to the jth vertex is a edge. A[i][j] = 0 indicates that they are not adjacent points. C++ Definition1// Work in progress C++ Implementation1// Work in progress Adjacency Matrix Directed GraphAdjacency matrix undirected graph refers to an directed graph represented by an adjacency matrix. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains , , , , , , , , , in total 7 edges. N/A A B C D E F G A 0 0 1 0 0 0 0 B 0 0 1 0 1 1 0 C 0 0 0 0 1 0 0 D 0 0 1 0 0 0 0 E 0 1 0 1 0 0 1 F 0 0 0 0 0 0 1 G 0 0 0 0 0 0 0 The matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that the ith vertex and the jth vertex are adjacent points. A[i][j] = 0 indicates that not a edge. C++ Definition1// Work in progress C++ Implementation1// Work in progress","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Graph","slug":"Data-Structure/Graph","permalink":"http://HuCoco.com/categories/Data-Structure/Graph/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"}]},{"title":"Basic Graph Theory","slug":"Basic-Graph-Theory","date":"2018-03-04T14:09:57.000Z","updated":"2018-03-07T16:06:32.906Z","comments":true,"path":"2018/03/04/Basic-Graph-Theory/","link":"","permalink":"http://HuCoco.com/2018/03/04/Basic-Graph-Theory/","excerpt":"Basic Graph Theory Chinese version address Graph TheoryThe definition of graphThe graph is composed of some points and the connection between these points. points are often called vertices, and the lines between points are called edges. It is usually written as G = (V,E). Types of GraphsAccording to whether the direction of the edge, the graph can be divided into: undirected and directed graph. Undirected graph","text":"Basic Graph Theory Chinese version address Graph TheoryThe definition of graphThe graph is composed of some points and the connection between these points. points are often called vertices, and the lines between points are called edges. It is usually written as G = (V,E). Types of GraphsAccording to whether the direction of the edge, the graph can be divided into: undirected and directed graph. Undirected graph The above graph is an undirected graph, and all the edges of the undirected graph are not directed. It is written as G0=(V1,{E1}). V1 = { A,B,C,D,E,F } V1 represents a set of vertices composed of A, B, C, D, E, F. E1 = { (A,B),(A,C),(B,C),(B,E),(B,F),(C,F),(C,D),(E,F),(C,E)} E1 is by the edge (A, B), the edge (A, C)… And so on, and so on. (A, C) represents the edge that is connected by the vertex A and the vertex C. Directed graph The graph above is a directed graph. Unlike an undirected graph, all the edges of the directed graph are directed. It is written as G2= (V2, {E2}). V2={ A,C,B,F,D,E,G } V2 represents a set of vertices composed of A, B, C, D, E, F, G. E2={ &lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt; } E2 is a , … And so on, and so on. In this, vector represents the directed edge of the vertex C that is directed by the vertex A. Adjacent &amp; DegreeAdjacentThe two vertices on an edge are called the adjacency points. For example, the vertex A and the vertex C in the above undirected graph are the adjacency points. In the digraph, except for the adjoining points; there are also the notions of &quot;In-Edge&quot; and &quot;Out-Edge&quot;. In-Edge is means which edge that end with the vertex. Out-Edge is means which edge that start with the vertex. For example, the B and E in graph G2 are adjacent points; is the Out-Edge of B, or the In-Edge of E. DegreeIn an undirected graph, the degree of a vertex is the number of edges adjacent to the vertex. For example, the degree of the vertex A in the above undirected graph is 2. In the digraph, there are also the notions of &quot;In-Degree&quot; and &quot;Out-Degree&quot; In-Degree is means the number of edges at the end of the vertex. Out-Degree is means the number of edges at the start of the vertex. Degree of vertex = In-Degree + Out-Degree Path &amp; CircuitPath: If a vertex sequence exists between the vertex (Vm) to the vertex (Vn). It means that Vm to Vn is a path Length of path: the number of edge in this path. Simple path: If the vertex of a path does not repeat, it is a simple path. Circuit: If the first vertex of the path is the same as the last vertex, it is a Circuit. Simple circuit: If the vertex of a circuit does not repeat, it is a simple circuit. Connected graphs and connected componentsConnected graph: For an undirected graph, there is an undirected path between any two vertices, and the undirected graph is called a connected graph. strongly connected graph: For a directed graph, if there is a directed path between any two vertices in the graph, the directed graph is called a strongly connected graph. Weight of GraphThis is special value in Huffman tree, it is means the value of a edge. Graph Storage StructuresThe storage structure of a graph is commonly used as adjacency matrix and adjacency list. Adjacency MatrixThe adjacency matrix refers to the representation of a graph by a matrix. It uses a matrix to describe the relationship between the vertices of the graph (and the right of the arcs or edges). Two arrays are usually used to implement the graph’s adjacency matrix: a one-dimensional array for storing vertex information and a two-dimensional array for saving edge information. The disadvantage of adjacency matrix is more space-consuming. Assuming that the number of vertices in the graph is n, the adjacency matrix is defined as: A[i][j] = 0 is means that there is no edge. A[i][j] = 1 is means that there are edge. The following undirected graph: The adjacency matrix of this undirected graph is as follows: N/A A B C D E F G A 0 0 1 1 0 1 0 B 0 0 1 0 0 0 0 C 1 1 0 1 0 0 0 D 1 0 1 0 0 0 0 E 0 0 0 0 0 0 1 F 1 0 0 0 0 0 1 G 0 0 0 0 1 1 0 The following directed graph: The adjacency matrix of this directed graph is as follows: N/A A B C D E F G A 0 0 1 0 0 0 0 B 0 0 1 0 1 1 0 C 0 0 0 0 1 0 0 D 0 0 1 0 0 0 0 E 0 1 0 1 0 0 1 F 0 0 0 0 0 0 1 G 0 0 0 0 0 0 0 Adjacency ListThe adjacency list is a chain storage representation method of a graph. It is an improved “adjacency matrix”, its disadvantage is that it is inconvenient to judge whether there is an edge between the two vertices, but it is less space relative to the adjacency matrix. The following undirected graph: The adjacency list of this undirected graph is as follows: The following directed graph: The adjacency list of this directed graph is as follows:","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Graph","slug":"Data-Structure/Graph","permalink":"http://HuCoco.com/categories/Data-Structure/Graph/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"}]},{"title":"RedBlackTree_III","slug":"RedBlackTree-III","date":"2018-03-02T15:38:19.000Z","updated":"2018-03-05T14:00:03.085Z","comments":true,"path":"2018/03/02/RedBlackTree-III/","link":"","permalink":"http://HuCoco.com/2018/03/02/RedBlackTree-III/","excerpt":"RedBlackTree III Chinese version address The Last Section Basic operation of red black treesDeleteThe method of deleting a node is the same as that of deleting a node in a binary search tree. Binary search tree Delete pseudo code123456789101112131415161718TREE-DELETE(T, z) if left[z] = NIL or right[z] = NIL then y ← z else y ← TREE-SUCCESSOR(z) if left[y] ≠ NIL then x ← left[y] else x ← right[y] if x ≠ NIL then p[x] ← p[y] if p[y] = NIL then root[T] ← x else if y = left[p[y]] then left[p[y]] ← x else right[p[y]] ← x if y ≠ z then key[z] ← key[y] copy y's satellite data into z return y","text":"RedBlackTree III Chinese version address The Last Section Basic operation of red black treesDeleteThe method of deleting a node is the same as that of deleting a node in a binary search tree. Binary search tree Delete pseudo code123456789101112131415161718TREE-DELETE(T, z) if left[z] = NIL or right[z] = NIL then y ← z else y ← TREE-SUCCESSOR(z) if left[y] ≠ NIL then x ← left[y] else x ← right[y] if x ≠ NIL then p[x] ← p[y] if p[y] = NIL then root[T] ← x else if y = left[p[y]] then left[p[y]] ← x else right[p[y]] ← x if y ≠ z then key[z] ← key[y] copy y's satellite data into z return y According to the node to be deleted according to the number of sons can be divided into three cases No child nodes. just set the child node of the parent node to NULL and delete the child node. Only one child node, the parent node’s child node pointer points to the grandson node, delete the son node. Two child nodes, After deleting the node, but also to ensure that the search binary tree structure. In this case, the largest element in the left child node or the smallest element in the right child node can be placed in the position of the node to be deleted to ensure the structure is unchanged. Binary search tree Delete pseudo code12345678910111213141516171819RB-DELETE(T, z)if left[z] = nil[T] or right[z] = nil[T] then y ← z else y ← TREE-SUCCESSOR(z) if left[y] ≠ nil[T] then x ← left[y] else x ← right[y] p[x] ← p[y] if p[y] = nil[T] then root[T] ← x else if y = left[p[y]] then left[p[y]] ← x else right[p[y]] ← x if y ≠ z then key[z] ← key[y] copy y's satellite data into z if color[y] = BLACK then RB-DELETE-FIXUP(T, x) return y After you delete a node, it may violate the feature of the red black tree. If you delete the red node, then the feature of red black tree remains. At this time do not do the correction operation. If the deleted node is a black node, the feature of the red black tree may be changed, and we want to make corrections to it So what are the feature of trees that will change? If the delete node is not the only node in the tree, then the number of black nodes to each leaf node of the delete node will change, and the property 5 is destroyed. If the deleted node’s only non-empty child node is red, and the deleted node’s parent node is also red, then the feature of 4 is destroyed. If the deleted node is the root node and its only non-empty child node is red, the new root node will be red after deletion, violating property 2. The above repair looks a bit complicated, here we use an analytical skills: begin to adjust the node from which the node was removed later, And think it has an extra black color. What is the meaning of an extra black here? We do not add the nodes of the red and black trees to another color of red and black. Here is just an assumption, and we think we are currently pointing to it, so there is an extra black. It can be thought that its black color is inherited from its parent after it was deleted. It can now hold two colors. If it was originally red, then it is red + black, and if it is black then its current color It is black + black. With this extra black, the feature of red-black tree 5 will remain unchanged. Now it is enough to resume other things as far as possible, and try to move all the possibilities to the root as far as possible. If it is the case, the recovery is relatively simple: The current node is red + black.The current node is set to black, the end of the red-black tree at this time the nature of all recovery. The current node is black + black and is the root node.do nothing, the end. But the following situation, it will be more complicated Case Description 1 The current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black). 2 The current node is black and black and the brother is black and both siblings have black children. 3 The current node color is black + black, brother node is black, brother’s left child is red, the right child is black. 4 The current node color is black-black, its sibling node is black, but the sibling node’s right child is red, the sibling node’s left child’s color is arbitrary Case DescriptionCase 1DescriptionThe current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black). Method Set the parent node to red. Set the brother nodes to black. Do left rotation on parent node. reset the brother nodes. pseudo code12345678while x ≠ root[T] and color[x] = BLACK do if x = left[p[x]] then w ← right[p[x]] if color[w] = RED then color[w] ← BLACK ▹ Case 1 color[p[x]] ← RED ▹ Case 1 LEFT-ROTATE(T, p[x]) ▹ Case 1 w ← right[p[x]] ▹ Case 1 Case 2DescriptionThe current node is black and black and the brother is black and both siblings have black children. Method Set brother node to red. Set current node to parent node. pseudo code123if color[left[w]] = BLACK and color[right[w]] = BLACK then color[w] ← RED ▹ Case 2 x ← p[x] ▹ Case 2 Case 3DescriptionThe current node color is black + black, brother node is black, brother’s left child is red, the right child is black. Method Set brother node’s left child node to black. Set brother node to red. Do right rotation on brother node. reset brother node. pseudo code12345else if color[right[w]] = BLACK then color[left[w]] ← BLACK ▹ Case 3 color[w] ← RED ▹ Case 3 RIGHT-ROTATE(T, w) ▹ Case 3 w ← right[p[x]] ▹ Case 3 Case 4DescriptionThe current node color is black-black, its sibling node is black, but the sibling node’s right child is red, the sibling node’s left child’s color is arbitrary Method Set the brother node to the color of parent node. Set parent node to black. Set the brother node’s right left node to black. Do right rotation on parent node. set current node to root node. pseudo code12345color[w] ← color[p[x]] ▹ Case 4 color[p[x]] ← BLACK ▹ Case 4 color[right[w]] ← BLACK ▹ Case 4 LEFT-ROTATE(T, p[x]) ▹ Case 4 x ← root[T] ▹ Case 4","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Tree","slug":"Data-Structure/Tree","permalink":"http://HuCoco.com/categories/Data-Structure/Tree/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Tree","slug":"Tree","permalink":"http://HuCoco.com/tags/Tree/"}]},{"title":"RedBlackTree_II","slug":"RedBlackTree-II","date":"2018-03-02T15:38:16.000Z","updated":"2018-03-03T14:24:17.860Z","comments":true,"path":"2018/03/02/RedBlackTree-II/","link":"","permalink":"http://HuCoco.com/2018/03/02/RedBlackTree-II/","excerpt":"RedBlackTree II Chinese version address The Last Section Basic operation of red black treesInsertInsert a node into the red-black tree, which steps need to be performed? think of the red-black tree as a binary search tree and insert the node. Set this node to red. Modify the tree by rotating and recoloring it to make it a red-black tree again.","text":"RedBlackTree II Chinese version address The Last Section Basic operation of red black treesInsertInsert a node into the red-black tree, which steps need to be performed? think of the red-black tree as a binary search tree and insert the node. Set this node to red. Modify the tree by rotating and recoloring it to make it a red-black tree again. Step DescriptionStep 1The red-black tree is a binary search tree, which is still a binary search tree after the node is inserted. This means that the key of the tree is still ordered. In addition, whether it is left-rotation or right-rotation, the tree is a binary search tree before rotation, and after rotation it must be a binary search tree. Step 2Why should set the node’s color to red? Because it is not violate 5 features. violate more less feature mean less things we need to deal with. Step 3So how many features it violate? As for feature 1, obviously not violate. As for feature 2, insert operation does not change the root node, so the color of root node is still black. As for feature 3, leaf node is null node, inserting non-null node does not affect feature. As for feature 4, Is possible to violate. Case DescriptionCase 1DescriptionThe current node’s parent node is red, and the current node’s grandparent node’s other child node (uncle node) is also red 1234while color[p[z]] = RED do if p[z] = left[p[p[z]]] then y ← right[p[p[z]]] if color[y] = RED Grandfather node must exist at this time, otherwise it is not black red tree before inserting. At this point is divided into the parent node is the grandfather’s left child or right child, according to symmetry, we just untie a direction on it. Here only consider the parent node left grandfather’s situation, as shown below. MethodStrategy is as follows: Sets the parent node to black. Sets the node of the uncle to black. set grandfather node to red. The grandfather node is set as the current node (red node). As shown in the following pseudo code: 1234then color[p[z]] ← BLACK ▹ Case 1 color[y] ← BLACK ▹ Case 1 color[p[p[z]]] ← RED ▹ Case 1 z ← p[p[z]] ▹ Case 1 Then, insert repair case 1 translates into insert repair case 2. Case 2DescriptionThe current node’s parent node is red, the uncle node is black, and the current node is the right child of its parent node MethodStrategy is as follows: Set the parent as the new current node. Do left rotation on current node. As shown in the following pseudo code: 123else if z = right[p[z]] then z ← p[z] ▹ Case 2 LEFT-ROTATE(T, z) ▹ Case 2 Insertion Repair Case 2 translates into insert repair case 3. Case 3DescriptionThe current node’s parent node is red, the uncle node is black, and the current node is the left child of its parent node MethodStrategy is as follows: Sets the parent node to black. set grandfather node to red. Do right rotation on grandfather node. As shown in the following pseudo code: 123color[p[z]] ← BLACK ▹ Case 3 color[p[p[z]]] ← RED ▹ Case 3 RIGHT-ROTATE(T, p[p[z]]) ▹ Case 3 Code ReferencePseudo code:Insert Pseudo Code123456789101112131415161718RB-INSERT(T, z) y ← nil[T] x ← root[T] while x ≠ nil[T] do y ← x if key[z] &lt; key[x] then x ← left[x] else x ← right[x] p[z] ← y if y = nil[T] then root[T] ← z else if key[z] &lt; key[y] then left[y] ← z else right[y] ← z left[z] ← nil[T] right[z] ← nil[T] color[z] ← RED RB-INSERT-FIXUP(T, z) Insert-Fixed Pseudo Code1234567891011121314151617RB-INSERT-FIXUP(T, z)while color[p[z]] = RED do if p[z] = left[p[p[z]]] then y ← right[p[p[z]]] if color[y] = RED then color[p[z]] ← BLACK ▹ Case 1 color[y] ← BLACK ▹ Case 1 color[p[p[z]]] ← RED ▹ Case 1 z ← p[p[z]] ▹ Case 1 else if z = right[p[z]] then z ← p[z] ▹ Case 2 LEFT-ROTATE(T, z) ▹ Case 2 color[p[z]] ← BLACK ▹ Case 3 color[p[p[z]]] ← RED ▹ Case 3 RIGHT-ROTATE(T, p[p[z]]) ▹ Case 3 else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) color[root[T]] ← BLACK C++ ImplementationInsert C++ Code1234567891011121314151617181920212223242526272829303132333435363738394041template &lt;class T&gt;bool RedBlackTree&lt;T&gt;::insert(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123; RedBlackNode&lt;T&gt;* y = nullptr; RedBlackNode&lt;T&gt;* x = root; while (x != nullptr) &#123; if(x-&gt;key == node-&gt;key)&#123; return false; &#125; y = x; if(node-&gt;key &lt; x-&gt;key) &#123; x = x-&gt;pLeft; &#125; else &#123; x = x-&gt;pRight; &#125; &#125; node-&gt;pParent = y; if(y != nullptr) &#123; if(node-&gt;key &lt; y-&gt;key) &#123; y-&gt;pLeft = node; &#125; else &#123; y-&gt;pRight = node; &#125; &#125; else &#123; root = node; &#125; set_red(node); insertFixUp(root, node); return true;&#125; Insert-Fixed C++ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455template &lt;class T&gt;void RedBlackTree&lt;T&gt;::insertFixUp(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123; RedBlackNode&lt;T&gt;* parent; RedBlackNode&lt;T&gt;* gparnet; while ((parent = get_parent(node))&amp;&amp;(is_red(parent))) &#123; gparnet = get_parent(parent); if(parent == gparnet-&gt;pLeft) &#123; RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pRight; if(uncle &amp;&amp; is_red(uncle)) &#123; set_black(uncle); set_black(parent); set_red(gparnet); node = gparnet; continue; &#125; if(parent-&gt;pRight == node) &#123; RedBlackNode&lt;T&gt;* tmp; leftRotate(root, parent); tmp = parent; parent = node; node = tmp; &#125; set_black(parent); set_red(gparnet); rightRotate(root, gparnet); &#125; else &#123; RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pLeft; if(uncle &amp;&amp; is_red(uncle)) &#123; set_black(uncle); set_black(parent); set_red(gparnet); node = gparnet; continue; &#125; if(parent-&gt;pLeft == node) &#123; RedBlackNode&lt;T&gt;* tmp; rightRotate(root, parent); tmp = parent; parent = node; node = tmp; &#125; set_black(parent); set_red(gparnet); leftRotate(root, gparnet); &#125; &#125; set_black(root);&#125; The Next Section","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Tree","slug":"Data-Structure/Tree","permalink":"http://HuCoco.com/categories/Data-Structure/Tree/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Tree","slug":"Tree","permalink":"http://HuCoco.com/tags/Tree/"}]},{"title":"RedBlackTree I","slug":"RedBlackTree-I","date":"2018-03-02T15:38:12.000Z","updated":"2018-03-03T14:23:47.253Z","comments":true,"path":"2018/03/02/RedBlackTree-I/","link":"","permalink":"http://HuCoco.com/2018/03/02/RedBlackTree-I/","excerpt":"RedBlackTree I Chinese version address Binary Tree ReviewThere are several features of binary tree: if the left subtree of any nodes is not null, the value of all nodes on the left subtree is less than the value of its root node. if the right subtree of any nodes is not null, the value of all nodes on the right subtree is greater than the value of its root node. the left and right subtrees of any node are also binary tree. No nodes with equal values Red Black Tree OverviewRed Black Tree is a special binary tree. each node of a red black tree has a bit to represenet the color, which can be red or black.","text":"RedBlackTree I Chinese version address Binary Tree ReviewThere are several features of binary tree: if the left subtree of any nodes is not null, the value of all nodes on the left subtree is less than the value of its root node. if the right subtree of any nodes is not null, the value of all nodes on the right subtree is greater than the value of its root node. the left and right subtrees of any node are also binary tree. No nodes with equal values Red Black Tree OverviewRed Black Tree is a special binary tree. each node of a red black tree has a bit to represenet the color, which can be red or black. Red Black Tree Features the color of each node is red or black. the color of root node is black. the color of each leaf node is black. if a node is red, the subnode of it must be black. The same number of black nodes is included on all paths from a node to the node’s descendant node. Notes: leaf node is means which node is null. Feature 5 to ensure that no path is twice as long as the other path. Thus, the red black tree is a relatively balanced binary tree. Application of red black treesThe application of the red-black tree is particularly extensive, mainly because it uses it to store ordered data. Its time complexity is O (lgn), which is very efficient. But its implementation is complicated, and insert, delete operation will pay more cost. Set and Map in STL TreeSet and TreeMap in Java Virtual memory management in Linux Basic operation of red black treesLeft Rotation12345 z x / / \\ --(左旋)--&gt; xy z / y Make left rotation on x node, and it will be a left node. Pseudo code123456789101112LEFT-ROTATE(T, x) y ← right[x] right[x] ← left[y] p[left[y]] ← x p[y] ← p[x] if p[x] = nil[T] then root[T] ← y else if x = left[p[x]] then left[p[x]] ← y else right[p[x]] ← y left[y] ← x p[x] ← y C++ Code1234567891011121314151617181920212223242526template &lt;class T&gt;void RedBlackTree&lt;T&gt;::leftRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *x) &#123; RedBlackNode&lt;T&gt; *y = x-&gt;pRight; x-&gt;pRight = y-&gt;pLeft; if(y-&gt;pLeft != nullptr) &#123; y-&gt;pLeft-&gt;pParent = x; &#125; y-&gt;pParent = x-&gt;pParent; if(x-&gt;pParent == nullptr) &#123; root = y; &#125; else &#123; if(x-&gt;pParent-&gt;pLeft == x) &#123; x-&gt;pParent-&gt;pLeft = y; &#125; else &#123; x-&gt;pParent-&gt;pRight = y; &#125; &#125; y-&gt;pLeft = x; x-&gt;pParent = y; &#125; Right Rotation12345 y x \\ / \\ --(右旋)--&gt; xy z \\ z Make right rotation on x node, and it will be a right node. Pseudo code123456789101112RIGHT-ROTATE(T, y) x ← left[y] left[y] ← right[x] p[right[x]] ← y p[x] ← p[y] if p[y] = nil[T] then root[T] ← x else if y = right[p[y]] then right[p[y]] ← x else left[p[y]] ← x right[x] ← y p[y] ← x C++ Code123456789101112131415161718192021222324252627template &lt;class T&gt;void RedBlackTree&lt;T&gt;::rightRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *y) &#123; RedBlackNode&lt;T&gt; *x = y-&gt;pLeft; y-&gt;pLeft = x-&gt;pRight; if(x-&gt;pRight != nullptr) &#123; x-&gt;pRight-&gt;pParent = y; &#125; x-&gt;pParent = y-&gt;pParent; if(y-&gt;pParent == nullptr) &#123; root = x; &#125; else &#123; if(y-&gt;pParent-&gt;pRight == y) &#123; y-&gt;pParent-&gt;pRight = x; &#125; else &#123; y-&gt;pParent-&gt;pLeft = x; &#125; &#125; x-&gt;pRight = y; y-&gt;pParent = x; &#125; The Next Section","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Tree","slug":"Data-Structure/Tree","permalink":"http://HuCoco.com/categories/Data-Structure/Tree/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Tree","slug":"Tree","permalink":"http://HuCoco.com/tags/Tree/"}]}]}