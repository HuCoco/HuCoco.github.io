{"meta":{"title":"HuCoco","subtitle":"HuCoco's Zone","description":null,"author":"HuCoco","url":"http://hucoco.com"},"pages":[{"title":"about","date":"2016-06-09T05:52:24.000Z","updated":"2016-06-09T05:52:24.000Z","comments":true,"path":"about/index.html","permalink":"http://hucoco.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"浅析const关键字","slug":"浅析const关键字","date":"2016-06-09T07:45:01.000Z","updated":"2016-06-09T09:01:41.000Z","comments":true,"path":"2016/06/09/浅析const关键字/","link":"","permalink":"http://hucoco.com/2016/06/09/浅析const关键字/","excerpt":"const关键字它允许你指定一个语义的约束，也就是不允许被改动的对象，而编译器会帮助你实施这样的约束，这有有助于在团队协作中不去违反这样的规则。const可以用到的地方很多，你可以在classes外部去修饰global或者namespace作用域中的常量，或者修饰文件、函数、区块作用域中被声明为static的对象，也可以用它修饰classes内部的成员变量，而面对指针，你可以可以指出是对于指针自身，还是指针所指物，或者两个都不是。12345char authorName[] = \"HookCoco\";char* name = authorName; //1const char* name = authorName; //2char* const name = authorName; //3const char* const name = authorName; //4 指针可修改，数据可修改 指针可修改，数据不可修改 指针不可修改，数据可修改 指针不可修改，数据不可修改","text":"const关键字它允许你指定一个语义的约束，也就是不允许被改动的对象，而编译器会帮助你实施这样的约束，这有有助于在团队协作中不去违反这样的规则。const可以用到的地方很多，你可以在classes外部去修饰global或者namespace作用域中的常量，或者修饰文件、函数、区块作用域中被声明为static的对象，也可以用它修饰classes内部的成员变量，而面对指针，你可以可以指出是对于指针自身，还是指针所指物，或者两个都不是。12345char authorName[] = \"HookCoco\";char* name = authorName; //1const char* name = authorName; //2char* const name = authorName; //3const char* const name = authorName; //4 指针可修改，数据可修改 指针可修改，数据不可修改 指针不可修改，数据可修改 指针不可修改，数据不可修改 简单来说如果const出现在星号的左边，表示被指物是常量，如果出现在右边，表示指针自身是常量，如果都出现，表示被指物和指针自身都是常量。而对于被指物是常量的写法有以下两种：12void f1(const char* name);void f2(char const * name); 这两种写法都是可行的，使用哪一种都可以，我习惯于用前者。 STL迭代器系以指针为根据塑模出来，所以迭代器的作用就像一个T指针，申明迭代器为const就想声明指针为const一样（T* const），它表示这个迭代器不能指向不同的东西，但是内容数据是可以修改的，如果你希望迭代器所指的东西不可被改动，你需要的是const_iterator:12345678std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; //1++iter; //2std::vector&lt;int&gt;::const_iterator cIter = vec.begin();*cIter = 10; //3++cIter; //4 上述代码不完全正确，你觉得哪些是对的，哪些是错的呢？ 这句是对的，因为iter的被指物是可以被修改的 这句不对，因为iter是const 这句不对，因为*cIter是const 这句是对的，可以改变cIter 好了热身已经结束了，const最有威力的作用是面对函数声明时的应用，在一个函数声明中，你可以在参数，函数自身，返回值使用const 让函数的返回值为一个常量值，往往可以降低因客户错误而造成的意外而又不至于放弃安全性和高效性，举个栗子！12class Rational &#123;...&#125;;const Rational operator* (const Rational&amp; lhs,const Rational&amp; rhs)； 很多人就要问了，为什么要返回一个const对象？原因很简单，避免某些人错误的使用这样的函数：12Rational a,b,c;(a * b) = c; 如果不返回const关键字，这样做就是可行的，编译器并不会阻止你敢这样的蠢事。1if( a * b = c) 如果你手误写出这样代码，编译器也是不会阻止你的。返回const常量可以避免没必要的赋值操作，进而可以避免造成更多的错误，何乐而不为呢？ const成员函数 将const实施与成员函数的目的，是为了确认该成员函数可以作用于const对象身上。这一类函数很重要，原因有二： 这样做使class接口比较容易被理解，因为知道哪些函数可以改动对象内容而哪些函数不行是很重要的一件事。 它们使“操作const”对象成为可能。 很多人是忽视这样一个事实：两个成员函数如果只是常量性不同，可以被重载。这是C++的一个很重要很重要很重的特性。考虑以下这个class，用于表现一个长文本：123456789class TextBlock&#123;public: ··· const char&amp; operator[](std::size_t position) const &#123; return text[position]; &#125; char&amp; operator[](std::size_t position) const &#123; return text[position]; &#125;private: std::string text;&#125;; TextBlock的operator[]s可被这样使用：1234TextBlock tb(\"Hello\");std::cout &lt;&lt; tb[0];const TextBlock ctb(\"World\");std::cout &lt;&lt; ctb[0]; 前者调用non-const函数，后者调用const函数。顺带提一下，真实的程序中const对象大多用于 passed by pointer-to-const 或者 passed reference-to-const，比如下面：12345void print(const TextBlock&amp; ctb)&#123; std::cout &lt;&lt; ctb[0] ···&#125; 回到刚刚的话题，只要重载operator[]并对不同的版本给予不同的返回值类型，就可以令const和non-const获得不同的处理：1234std::cout &lt;&lt; tb[0];tb[0] = 'X';std::cout &lt;&lt; ctb[0];ctb[0] = 'X'; 上面这段代码的最后一行很明显是错误的，因为ctb是const类型的对象，不允许修改数据。还有一点也需要注意，non-const operator[]方法的返回值为reference to char，而不是char，若果是后者的话，第二行的这样的语句也无法通过编译，那是因为如果函数的返回值是一个内置类型，那么改动函数返回值从来就不合法，即使是合法的，C++以by value返回对象这一个规则意味被改动的其实是tb.text[0]的副本，不是tb.text[0]本身，不搞清楚这点的话，很多初学者都会头疼，比如以前的我····2333333 这一次我们就讲到这里，下一次我们会更加深入的探讨const关键字，如果你有时间，你可以仔细的考虑下operator[]的两个方法，他们其实是有些问题的。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://hucoco.com/categories/编程语言/"},{"name":"C++","slug":"编程语言/C","permalink":"http://hucoco.com/categories/编程语言/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"}]}]}