{"meta":{"title":"HuCoco","subtitle":null,"description":null,"author":"Hu Ke","url":"http://HuCoco.com"},"pages":[{"title":"about","date":"2018-03-01T15:06:49.000Z","updated":"2018-03-01T15:06:49.223Z","comments":true,"path":"about/index.html","permalink":"http://HuCoco.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"BRDF","slug":"BRDF","date":"2018-07-12T14:07:13.000Z","updated":"2018-07-15T13:11:41.832Z","comments":true,"path":"2018/07/12/BRDF/","link":"","permalink":"http://HuCoco.com/2018/07/12/BRDF/","excerpt":"The BRDF, or Bidirectional Reflective Distribution Function is a function that takes as input the incoming (light) direction $\\omega_i$, the outgoing (view) direction $\\omega_o$, the surface normal $n$ and a surface parameter a that represents the microsurface’s roughness. The BRDF approximates how much each individual light ray $\\omega_i$ contributes to the final reflected light of an opaque surface given its material properties. For instance, if the surface has a perfectly smooth surface (like a mirror) the BRDF function would return 0.0 for all incoming light rays $\\omega_i$ except the one ray that has the same (reflected) angle as the outgoing ray $\\omega_o$ at which the function returns 1.0. A BRDF approximates the material’s reflective and refractive properties based on the previously discussed microfacet theory. For a BRDF to be physically plausible it has to respect the law of energy conservation i.e. the sum of reflected light should never exceed the amount of incoming light. Technically, Blinn-Phong is considered a BRDF taking the same $\\omega_i$ and $\\omega_o$ as inputs. However, Blinn-Phong is not considered physically based as it doesn’t adhere to the energy conservation principle. There are several physically based BRDFs out there to approximate the surface’s reaction to light. However, almost all real-time render pipelines use a BRDF known as the Cook-Torrance BRDF. The Cook-Torrance BRDF contains both a diffuse and specular part: f_r = k_d f_{lambert} + k_s f_{cook-torrance}","text":"The BRDF, or Bidirectional Reflective Distribution Function is a function that takes as input the incoming (light) direction $\\omega_i$, the outgoing (view) direction $\\omega_o$, the surface normal $n$ and a surface parameter a that represents the microsurface’s roughness. The BRDF approximates how much each individual light ray $\\omega_i$ contributes to the final reflected light of an opaque surface given its material properties. For instance, if the surface has a perfectly smooth surface (like a mirror) the BRDF function would return 0.0 for all incoming light rays $\\omega_i$ except the one ray that has the same (reflected) angle as the outgoing ray $\\omega_o$ at which the function returns 1.0. A BRDF approximates the material’s reflective and refractive properties based on the previously discussed microfacet theory. For a BRDF to be physically plausible it has to respect the law of energy conservation i.e. the sum of reflected light should never exceed the amount of incoming light. Technically, Blinn-Phong is considered a BRDF taking the same $\\omega_i$ and $\\omega_o$ as inputs. However, Blinn-Phong is not considered physically based as it doesn’t adhere to the energy conservation principle. There are several physically based BRDFs out there to approximate the surface’s reaction to light. However, almost all real-time render pipelines use a BRDF known as the Cook-Torrance BRDF. The Cook-Torrance BRDF contains both a diffuse and specular part: f_r = k_d f_{lambert} + k_s f_{cook-torrance} Diffuse PartHere kd is the earlier mentioned ratio of incoming light energy that gets refracted with ks being the ratio that gets reflected. The left side of the BRDF states the diffuse part of the equation denoted here as flambert. This is known as Lambertian diffuse similar to what we used for diffuse shading which is a constant factor denoted as: f_{lambert} = \\frac{c}{\\pi}With c being the albedo or surface color (think of the diffuse surface texture). The divide by pi is there to normalize the diffuse light as the earlier denoted integral that contains the BRDF is scaled by $\\pi$ You might wonder how this Lambertian diffuse relates to the diffuse term we’ve been using before: the surface color multiplied by the dot product between the surface’s normal and the light direction. The dot product is still there, but moved out of the BRDF as we find $n \\cdot \\omega_i$ at the end of the $L_o$ integral. There exist different equations for the diffuse part of the BRDF which tend to look more realistic, but are also more computationally expensive. As concluded by Epic Games however, the Lambertian diffuse is sufficient enough for most real-time rendering purposes. Specluar PartThe specular part of the BRDF is a bit more advanced and is described as: f_{cook-torrance} = \\frac{DFG}{4(\\omega_o \\cdot n)(\\omega_i \\cdot n)}he Cook-Torrance specular BRDF consists of three functions and a normalization factor in the denominator. Each of the D, F and G symbols represent a type of function that approximates a specific part of the surface’s reflective properties. These are defined as the normal Distribution function, the Fresnel equation and the Geometry function: Normal distribution function: approximates the amount the surface’s microfacets are aligned to the halfway vector influenced by the roughness of the surface; this is the primary function approximating the microfacets. Geometry function: describes the self-shadowing property of the microfacets. When a surface is relatively rough the surface’s microfacets can overshadow other microfacets thereby reducing the light the surface reflects. Fresnel equation: The Fresnel equation describes the ratio of surface reflection at different surface angles. Normal distribution functionThe normal distribution function D statistically approximates the relative surface area of microfacets exactly aligned to the (halfway) vector $h$. There are a multitude of NDFs defined that statistically approximate the general alignment of the microfacets given some roughness parameter and the one we’ll be using is known as the Trowbridge-Reitz GGX: NDF_{GGX}(n,h,\\alpha) = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2 - 1) + 1)^2}Here $h$ is the halfway vector to measure against the surface’s microfacets, with a being a measure of the surface’s roughness. If we take $h$ as the halfway vector between the surface normal and light direction over varying roughness parameters we get the following visual result: When the roughness is low (thus the surface is smooth) a highly concentrated number of microfacets are aligned to halfway vectors over a small radius. Due to this high concentration the NDF displays a very bright spot. On a rough surface however, where the microfacets are aligned in much more random directions, you’ll find a much larger number of halfway vectors h somewhat aligned to the microfacets, but less concentrated giving us the more grayish results. In GLSL code the Trowbridge-Reitz GGX normal distribution function would look a bit like this: 12345678910111213float NormalDistributionFunction(float NoH, float Roughness)&#123; float a = Roughness * Roughness; float a2 = a * a; float NdotH = max(NoH, 0.0f); float NdotH2 = NdotH * NdotH; float nom = a2; float denom = (NdotH2 * (a2 - 1.0) + 1.0); denom = 3.141592 * denom * denom; return nom / denom;&#125; Geometry functionThe geometry function statistically approximates the relative surface area where its micro surface-details overshadow each other causing light rays to be occluded. Similar to the NDF, the Geometry function takes a material’s roughness parameter as input with rougher surfaces having a higher probability of overshadowing microfacets. The geometry function we will use is a combination of the GGX and Schlick-Beckmann approximation known as Schlick-GGX: G_{schlickGGX}(n,v,k) = \\frac{n \\cdot v}{(n \\cdot v)(1-k) + k}Here $k$ is a remapping of α based on whether we’re using the geometry function for either direct lighting or IBL lighting: k_{direct} = \\frac{(\\alpha + 1)^2}{8}k_{IBL} = \\frac{\\alpha^2}{2}Note that the value of $\\alpha$ might differ based on how your engine translates roughness to $\\alpha$. In the following tutorials we’ll extensively discuss how and where this remapping becomes relevant. To effectively approximate the geometry we need to take account of both the view direction (geometry obstruction) and the light direction vector (geometry shadowing). We can take both into account using Smith’s method: G(n,v,l,k) = G_{sub}(n,v,k)G_{sub}(n,l,k)Using Smith’s method with Schlick-GGX as $G_{sub}$ gives the following visual appearance over varying roughness R: The geometry function is a multiplier between [0.0, 1.0] with white or 1.0 measuring no microfacet shadowing and black or 0.0 complete microfacet shadowing. In GLSL the geometry function translates to the following code: 123456789101112131415161718float GeometrychlickGGX(float NoV, float k)&#123; float nom = NoV; float denom = NoV * (1.0 - k) + k; return nom / denom;&#125;float GeometryFunction(vec3 N, vec3 V, vec3 L, float Roughness)&#123; float k = pow(Roughness + 1, 2) / 8.0f; float NoV = max(dot(N, V), 0.0); float NoL = max(dot(N, L), 0.0); float ggx1 = GeometrychlickGGX(NoV, k); float ggx2 = GeometrychlickGGX(NoL, k); return ggx1 * ggx2;&#125; Fresnel equationThe Fresnel equation (pronounced as Freh-nel) describes the ratio of light that gets reflected over the light that gets refracted, which varies over the angle we’re looking at a surface. The moment light hits a surface, based on the surface to view angle the Fresnel equation tells us the percentage of light that gets reflected. From this ratio of reflection and the energy conservation principle we can directly obtain the refracted portion of light from its remaining energy. Every surface or material has a level of base reflectivity when looking straight at its surface, but when looking at the surface from an angle all reflections become more apparent compared to the surface’s base reflectivity. You can check this for yourself by looking at your presumably wooden/metallic desk which has a certain level of base reflectivity from a perpendicular view angle, but by looking at your desk from an almost 90 degree angle you’ll see the reflections become much more apparent. All surfaces theoretically fully reflect light if seen from perfect 90-degree angles. This phenomenon is known as Fresnel and is described by the Fresnel equation. The Fresnel equation is a rather complex equation, but luckily the Fresnel equation can be approximated using the Fresnel-Schlick approximation: F_{schlick}(h,v,F_0) = F_0 + (1 - F_0)(1 - (h \\cdot v))^5$F_0$ represents the base reflectivity of the surface, which we calculate using something called the indices of refraction or IOR and as you can see on a sphere surface, the more we look towards the surface’s grazing angles (with the halfway-view angle reaching 90 degrees) the stronger the Fresnel and thus the reflections: There are a few subtleties involved with the Fresnel equation. One is that the Fresnel-Schlick approximation is only really defined for dielectric or non-metal surfaces. For conductor surfaces (metals) calculating the base reflectivity using their indices of refraction doesn’t properly hold and we need to use a different Fresnel equation for conductors altogether. As this is inconvenient we further approximate by pre-computing the surface’s response at normal incidence ($F0$) (at a 0 degree angle as if looking directly onto a surface) and interpolate this value based on the view angle as per the Fresnel-Schlick approximation such that we can use the same equation for both metals and non-metals. These specific attributes of metallic surfaces compared to dielectric surfaces gave rise to something called the metallic workflow where we author surface materials with an extra parameter known as metalness that describes whether a surface is either a metallic or a non-metallic surface. Theoretically the metalness of a surface is binary: it’s either a metal or it isn’t; it can’t be both. However, most render pipelines allow configuring the metalness of a surface linearly between 0.0 and 1.0. This is mostly because of the lack of material texture precision to describe for instance a surface having small dust/sand-like particles/scratches over a metallic surface. By balancing the metalness value around these small non-metallic like particles/scratches we get visually pleasable results. 123456vec3 FresnelEquation(vec3 N, vec3 V, vec3 F)&#123; float NoV = dot(N, V); vec3 res = F + (vec3(1.0f) - F) * pow(1.0f - NoV, 5); return res;&#125; Cook-Torrance reflectance equationWith every component of the Cook-Torrance BRDF described we can include the physically based BRDF into the now final reflectance equation: L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + k_s \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_iThis equation is however not fully mathematically correct. You may remember that the Fresnel term $F$ represents the ratio of light that gets reflected on a surface. This is effectively our ratio $k_s$, meaning the specular part of the reflectance equation implicitly contains the reflectance ratio $k_s$. Given this, our final final reflectance equation becomes: L_o(p,w_o) = \\int_\\pi(k_d \\frac{c}{\\pi} + \\frac{DFG}{4(w_o \\cdot n)(w_i \\cdot n)})L_i(p,w_i)n \\cdot w_idw_iThis equation now completely describes a physically based render model that is generally recognized as what we commonly understand as physically based rendering or PBR. Don’t worry if you didn’t yet completely understand how we’ll need to fit all the discussed mathematics together in code. In the next tutorials, we’ll explore how to utilize the reflectance equation to get much more physically plausible results in our rendered lighting and all the bits and pieces should slowly start to fit together. ReferenceLearn OpenGL PBR Theory","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"PBR","slug":"Graphics/PBR","permalink":"http://HuCoco.com/categories/Graphics/PBR/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"PBR","slug":"PBR","permalink":"http://HuCoco.com/tags/PBR/"}]},{"title":"The Reflection Equation","slug":"The-Reflectance-Equation","date":"2018-07-11T13:46:22.000Z","updated":"2018-07-11T15:04:18.934Z","comments":true,"path":"2018/07/11/The-Reflectance-Equation/","link":"","permalink":"http://HuCoco.com/2018/07/11/The-Reflectance-Equation/","excerpt":"OverviewPhysically based rendering strongly follows a more specialized version of the render equation known as the reflectance equation, which is the best model we have for simulating the visuals of light: L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_iTo understand the equation, we have to delve into a bit of radiometry. Radiometry is the measurement of electromagnetic radiation (including visible light). There are several radiometric quantities we can use to measure light over surfaces and directions, but we will only discuss a single one that’s relevant to the reflectance equation known as radiance, denoted here as $L$. Radiance is used to quantify the magnitude or strength of light coming from a single direction.","text":"OverviewPhysically based rendering strongly follows a more specialized version of the render equation known as the reflectance equation, which is the best model we have for simulating the visuals of light: L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_iTo understand the equation, we have to delve into a bit of radiometry. Radiometry is the measurement of electromagnetic radiation (including visible light). There are several radiometric quantities we can use to measure light over surfaces and directions, but we will only discuss a single one that’s relevant to the reflectance equation known as radiance, denoted here as $L$. Radiance is used to quantify the magnitude or strength of light coming from a single direction. Radiant fluxradiant flux $\\Phi$ is the transmitted energy of a light source measured in Watts. Light is a collective sum of energy over multiple different wavelengths, each wavelength associated with a particular (visible) color. The emitted energy of a light source can therefore be thought of as a function of all its different wavelengths. Wavelengths between 390nm to 700nm (nanometers) are considered part of the visible light spectrum i.e. wavelengths the human eye is able to perceive. Below you’ll find an image of the different energies per wavelength of daylight: The radiant flux measures the total area of this function of different wavelengths. Directly taking this measure of wavelengths as input in computer graphics is slightly impractical so we often make the simplification of representing radiant flux not as a function of varying wavelength strengths, but as a light color triplet encoded as RGB This encoding does come at quite a loss of information, but this is generally negligible for visual aspects. Solid anglethe solid angle denoted as $\\omega$ tells us the size or area of a shape projected onto a unit sphere. The area of the projected shape onto this unit sphere is known as the solid angle; you can visualize the solid angle as a direction with volume: Radiant intensityradiant intensity measures the amount of radiant flux per solid angle or the strength of a light source over a projected area onto the unit sphere. For instance, given an omnidirectional light that radiates equally in all directions the radiant intensity can give us its energy over a specific area (solid angle): The equation to describe the radiant intensity is defined as follows: I = \\frac{d\\Phi}{d\\omega}Where $I$ is the radiant flux $\\Phi$ over the solid angle $\\omega$. With knowledge of radiant flux, radiant intensity and the solid angle we can finally describe the equation for radiance, which is described as the total observed energy over an area $A$ over the solid angle $\\omega$ of a light of radiant intensity $\\Phi$: L = \\frac{d^2\\Phi}{dAd\\omega cos\\theta} Radiance is a radiometric measure of the amount of light in an area scaled by the incident (or incoming) angle $\\theta$ of the light to the surface’s normal as $cos\\theta$: light is weaker the less it directly radiates onto the surface and strongest when it is directly perpendicular to the surface. This is similar to our perception of diffuse lighting from the basic lighting tutorials as $cos\\theta$ directly corresponds to the dot product between the light’s direction vector and the surface’s normal: 1float cosTheta = dot(lightDir, N); The Reflection EquationThe radiance equation is quite useful as it consists of most physical quantities we’re interested in. If we consider the solid angle ω and the area A to be infinitely small, we can use radiance to measure the flux of a single ray of light hitting a single point in space. This relation allows us to calculate the radiance of a single light ray influencing a single (fragment) point; we effectively translate the solid angle ω into a direction vector ω, and A into a point p. This way we can directly use radiance in our shaders to calculate a single light ray’s per-fragment contribution. In fact, when it comes to radiance we generally care about all incoming light onto a point p which is the sum of all radiance known as irradiance. With knowledge of both radiance and irradiance we can get back to the reflectance equation: L_o(p,\\omega_o) = \\int_\\Omega f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n \\cdot \\omega_id\\omega_iWe now know that $L$ in the render equation represents the radiance of some point p and some incoming infinitely small solid angle $\\omega_i$ which can be thought of as an incoming direction vector $\\omega_i$. Remember that $cos\\theta$ scales the energy based on the light’s incident angle to the surface which we find in the reflectance equation as $n\\cdot \\omega_o$. The reflectance equation calculates the sum of reflected radiance $L_o(p,\\omega_o)$ of a point $p$ in direction $\\omega_o$ which is the outgoing direction to the viewer. Or to put it differently: $Lo$ measures the reflected sum of the lights’ irradiance onto point $p$ as viewed from $\\omega_o$. As the reflectance equation is based around irradiance which is the sum of all incoming radiance we measure light of not just a single incoming light direction, but of all incoming light directions within a hemisphere $\\Omega$ centered around point $p$. A hemisphere can be described as half a sphere aligned around a surface’s normal $n$: To calculate the total of values inside an area or, in the case of a hemisphere, a volume we use a mathematical construct called an integral denoted in the reflectance equation as $\\int$ over all incoming directions $d\\omega_i$ within the hemisphere $\\Omega$. An integral measures the area of a function, which can either be calculated analytically or numerically. As there is no analytical solution to both the render and reflectance equation we’ll want to numerically solve the integral discretely. This translates to taking the result of small discrete steps of the reflectance equation over the hemisphere $\\Omega$ and averaging their results over the step size. The reflectance equation sums up the radiance of all incoming light directions $\\omega_i$ over the hemisphere $\\Omega$ scaled by $f_r$ that hit point $p$ and returns the sum of reflected light $L_o$ in the viewer’s direction. The incoming radiance can come from light sources. Now the only unknown left is the $f_r$ symbol known as the BRDF or Bidirectional Reflective Distribution Function that scales or weighs the incoming radiance based on the surface’s material properties. ReferenceLearn OpenGL PBR Theory","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"PBR","slug":"Graphics/PBR","permalink":"http://HuCoco.com/categories/Graphics/PBR/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"PBR","slug":"PBR","permalink":"http://HuCoco.com/tags/PBR/"}]},{"title":"Theory of PBR","slug":"Theory-of-PBR","date":"2018-07-10T14:16:57.000Z","updated":"2018-07-10T15:15:37.795Z","comments":true,"path":"2018/07/10/Theory-of-PBR/","link":"","permalink":"http://HuCoco.com/2018/07/10/Theory-of-PBR/","excerpt":"OverviewPBR (Physically Base Rendering) is a rendering technique that are more or less based on the same underlying theory which more closely matches that of the physical world. the biggest difference between the physical rendering model and the traditional rendering method is that it can more accurately describe and draw the interaction between the light and the surface of the object.","text":"OverviewPBR (Physically Base Rendering) is a rendering technique that are more or less based on the same underlying theory which more closely matches that of the physical world. the biggest difference between the physical rendering model and the traditional rendering method is that it can more accurately describe and draw the interaction between the light and the surface of the object. Diffusion and ReflectionDiffusion and Reflection are two words that describe the most basic differences in light and surface interaction. When light hits the edge of the surface of the object, some of the light will reflect from the surface. On a smooth surface, which makes the surface looks like a mirror. Specular Reflection is often used to describe this effect. But not all of light will reflect form the surface, Usually some light will penetrate into the inside of the object. In this case, the light is either absorbed by the object (converted to heat) or scattered within the object. Some scattered light may return to the surface and be captured by the eye or camera. This is the well-known Diffuse. By the way, Diffuse and Subsurface Scattering are all describe the same phenomenon. Scattering is usually random in the direction, so albedo is a color that describes which color is most easily scattered back. Translucency and TransparencyIn some cases, diffuse reflections become more complicated—in materials with longer scattering distances, such as skin, wax, jade, and so on.In this case a simple color usually does not determine everything, and it also must consider the shape and thickness of the object.If these objects are thin enough, these objects usually have some light scattered from one surface and the nemitted from the other side. This phenomenon is called Translucent. If the scattering intensity is lower (such as glass), so that the scattered part is almost negligible, then the landscape on the other side of the object can directly enter the human eye through the object. This phenomenon is very far from the typical “difficulty near the surface” of the diffuse reflection, so a special shader is usually needed to simulate them. Mircofacet ModelAll the PBR techniques are based on the theory of microfacets. The theory describes that any surface at a microscopic scale can be described by tiny little perfectly reflective mirrors called microfacets. According to the roughness of a surface the alignment of these tiny little mirrors can differ quite a lot: The rougher a surface is, the more chaotically aligned each microfacet will be along the surface. The effect of these tiny-like mirror alignments is that when specifically talking about specular lighting/reflection the incoming light rays are more likely to scatter along completely different directions on rougher surfaces, resulting in a more widespread specular reflection. In contrast, on a smooth surface the light rays are more likely to reflect in roughly the same direction, giving us smaller and sharper reflections: Energy ConservationEnergy Conservation is describe a phenomenon: outgoing light energy should never exceed the incoming light energy (excluding emissive surfaces). Looking at the above image we see the specular reflection area increase, but also its brightness decrease at increasing roughness levels. If the specular intensity were to be the same at each pixel regardless of the size of the specular shape the rougher surfaces would emit much more energy, violating the energy conservation principle. This is why we see specular reflections more intensely on smooth surfaces and more dimly on rough surfaces. For energy conservation to hold we need to make a clear distinction between diffuse and specular light. The moment a light ray hits a surface, it gets split in both a refraction part and a reflection part. The reflection part is light that directly gets reflected and doesn’t enter the surface; this is what we know as specular lighting. The refraction part is the remaining light that enters the surface and gets absorbed; this is what we know as diffuse lighting. From physics, we know that light can effectively be considered a beam of energy that keeps moving forward until it loses all of its energy, the way a light beam loses energy is by collision. Each material consists of tiny little particles that can collide with the light ray as illustrated below. The particles absorb some or all of the light’s energy at each collision which is converted into heat. PBR materials Albedo: the albedo texture specifies for each texel the color of the surface, or the base reflectivity if that texel is metallic. This is largely similar to what we’ve been using before as a diffuse texture, but all lighting information is extracted from the texture. Diffuse textures often have slight shadows or darkened crevices inside the image which is something you don’t want in an albedo texture; it should only contain the color (or refracted absorption coefficients) of the surface. Normal: the normal map texture is exactly as we’ve been using before in the normal mapping tutorial. The normal map allows us to specify per fragment a unique normal to give the illusion that a surface is bumpier than its flat counterpart. Metallic: the metallic map specifies per texel whether a texel is either metallic or it isn’t. Based on how the PBR engine is set up, artists can author metalness as either grayscale values or as binary black or white. Roughness: the roughness map specifies how rough a surface is on a per texel basis. The sampled roughness value of the roughness influences the statistical microfacet orientations of the surface. A rougher surface gets wider and blurrier reflections, while a smooth surface gets focused and clear reflections. Some PBR engines expect a smoothness map instead of a roughness map which some artists find more intuitive, but these values get translated (1.0 - smoothness) to roughness the moment they’re sampled. AO: the ambient occlusion or AO map specifies an extra shadowing factor of the surface and potentially surrounding geometry. If we have a brick surface for instance, the albedo texture should have no shadowing information inside the brick’s crevices. The AO map however does specify these darkened edges as it’s more difficult for light to escape. Taking ambient occlusion in account at the end of the lighting stage can significantly boost the visual quality of your scene. The ambient occlusion map of a mesh/surface is either manually generated or pre-calculated in 3D modeling programs. ReferenceLearn OpenGL PBR Theory","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"PBR","slug":"Graphics/PBR","permalink":"http://HuCoco.com/categories/Graphics/PBR/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"PBR","slug":"PBR","permalink":"http://HuCoco.com/tags/PBR/"}]},{"title":"Do Ray Tracing","slug":"Do-Ray-Tracing","date":"2018-07-10T05:54:10.000Z","updated":"2018-07-10T07:28:42.935Z","comments":true,"path":"2018/07/10/Do-Ray-Tracing/","link":"","permalink":"http://HuCoco.com/2018/07/10/Do-Ray-Tracing/","excerpt":"Generate RayGenerate a ray that goes from the camera’s origin through the pixel location (pixelPosX, pixelPosY) of the camera. Note that pixelPosX and pixelPosY can be non-integer. The image origin is at the bottom-leftmost corner, that means: The bottom-leftmost corner of the image is (0, 0). The top-rightmost corner of the image is (imageWidth, imageHeight). The center of the bottom-leftmost pixel is (0.5, 0.5). The center of the top-rightmost pixel is (imageWidth-0.5, imageHeight-0.5). 12345Ray getRay( double pixelPosX, double pixelPosY ) const&#123; Vector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV; return Ray( mCOP, imgPos - mCOP );&#125;","text":"Generate RayGenerate a ray that goes from the camera’s origin through the pixel location (pixelPosX, pixelPosY) of the camera. Note that pixelPosX and pixelPosY can be non-integer. The image origin is at the bottom-leftmost corner, that means: The bottom-leftmost corner of the image is (0, 0). The top-rightmost corner of the image is (imageWidth, imageHeight). The center of the bottom-leftmost pixel is (0.5, 0.5). The center of the top-rightmost pixel is (imageWidth-0.5, imageHeight-0.5). 12345Ray getRay( double pixelPosX, double pixelPosY ) const&#123; Vector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV; return Ray( mCOP, imgPos - mCOP );&#125; Nearest SurfaceFind whether and where the ray hits some surface. Take the nearest hit point. 12345678910111213141516bool hasHitSomething = false;double nearest_t = DEFAULT_TMAX;SurfaceHitRecord nearestHitRec;for ( int i = 0; i &lt; scene.numSurfaces; i++ )&#123; SurfaceHitRecord tempHitRec; bool hasHit = scene.surfacep[i]-&gt;hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec ); if ( hasHit &amp;&amp; tempHitRec.t &lt; nearest_t ) &#123; hasHitSomething = true; nearest_t = tempHitRec.t; nearestHitRec = tempHitRec; &#125;&#125; ShadowAdd to result the phong lightin contributed by each point light source. Compute shadow if hasShadow is true. 123456789101112131415161718192021222324252627bool shadow = true;for(int i = 0 ; i &lt; scene.numPtLights ; i++)&#123; Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p; double MaxLength = (Lin).length(); double invLen = 1 / MaxLength; Vector3d L = (Lin)*invLen; if(hasShadow) &#123; Ray newRay(nearestHitRec.p,L); for(int j = 0 ; j &lt; scene.numSurfaces ; j++) &#123; if(scene.surfacep[j]-&gt;shadowHit(newRay, DEFAULT_TMIN, MaxLength)) &#123; shadow = false; break; &#125; &#125; if(shadow == false) &#123; continue; &#125; &#125; result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]);&#125; ReflectionAdd to result the reflection of the scene. 123456if(reflectLevels &gt; 0)&#123; Vector3d dir = mirrorReflect(V, N); Ray rRay(nearestHitRec.p,dir); result += nearestHitRec.mat_ptr-&gt;k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow);&#125; Hammersley SamplingWe know that binary numbers are used to represent data in the computer. The corresponding relations between decimal and binary systems are shown in the following table. Decimal Binary 1 1 2 10 3 11 4 100 And Hammersley Sampling is to generate uniformly distributed 2D random sampliong points by using this characteristics. It constructs a value by implementing a Radical Inverse method for a binary number. Its process is as follows Decimal Binary Radical Inverse Value 1 1 .1 = 1 * 1/2 0.5 2 10 .01 = 0 1/2 + 1 1/4 0.25 3 11 .11 = 1 1/2 + 1 1/4 0.75 4 100 .001 = 0 1/2 + 0 1/4 + 1 * 1/8 0.125 Constructing a set of 2D random sampling points for Hammersley Sampling \\phi(i) = RadicalInverse(i)P_i = (x_i,y_i) = (i/N,\\phi(i))Anti-AliasingIn ray tracing world, Anti-Aliasing method is simply, it only just increase the amount of sampling. Anti-Aliasing in GLSL123456for(uint i = 0 ; i &lt; NumSample; i++)&#123; vec2 offset = Hammersley(i, NumSample); Ray ray = getRay(float(pos.x) + offset.x, float(pos.y) + offset.y); // create ray from camera color += RayTrace(ray,ReflectLevels,HasShadow);&#125; Code12345678910111213141516171819202122for (uint32_t y = task-&gt;beginHeight; y &lt; task-&gt;endHeight; y++)&#123; for (uint32_t x = 0; x &lt; task-&gt;width; x++) &#123; Color pixelColor = Color(0, 0, 0); for (uint32_t i = 0; i &lt; task-&gt;numSample; i++) &#123; float xx; float yy; Math::Hammersley(i, task-&gt;numSample, &amp;xx, &amp;yy); double pixelPosX = x + xx; double pixelPosY = y + yy; Ray ray = task-&gt;scene-&gt;camera.getRay(pixelPosX, pixelPosY); pixelColor += Raytrace::TraceRay(ray, *task-&gt;scene, task-&gt;reflectLevels, task-&gt;hasShadow); &#125; pixelColor /= (float)task-&gt;numSample; pixelColor.clamp(); task-&gt;output-&gt;setPixel(x, y, pixelColor); &#125; // printf( \"%d \", y );&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Color Raytrace::TraceRay( const Ray &amp;ray, const Scene &amp;scene, int reflectLevels, bool hasShadow )&#123; Ray uRay( ray ); uRay.makeUnitDirection(); // Normalize ray direction. bool hasHitSomething = false; double nearest_t = DEFAULT_TMAX; SurfaceHitRecord nearestHitRec; for ( int i = 0; i &lt; scene.numSurfaces; i++ ) &#123; SurfaceHitRecord tempHitRec; bool hasHit = scene.surfacep[i]-&gt;hit( uRay, DEFAULT_TMIN, DEFAULT_TMAX, tempHitRec ); if ( hasHit &amp;&amp; tempHitRec.t &lt; nearest_t ) &#123; hasHitSomething = true; nearest_t = tempHitRec.t; nearestHitRec = tempHitRec; &#125; &#125; if ( !hasHitSomething ) return scene.backgroundColor; nearestHitRec.normal.makeUnitVector(); Vector3d N = nearestHitRec.normal; // Unit vector. Vector3d V = -uRay.direction(); // Unit vector. Color result( 0.0f, 0.0f, 0.0f ); // The result will be accumulated here. bool shadow = 1.0f; for(int i = 0 ; i &lt; scene.numPtLights ; i++) &#123; Vector3d Lin = scene.ptLight[i].position - nearestHitRec.p; double MaxLength = (Lin).length(); double invLen = 1 / MaxLength; Vector3d L = (Lin)*invLen; if(hasShadow) &#123; Ray newRay(nearestHitRec.p,L); for(int j = 0 ; j &lt; scene.numSurfaces ; j++) &#123; if(scene.surfacep[j]-&gt;shadowHit(newRay, DEFAULT_TMIN, MaxLength)) &#123; shadow = true; break; &#125; &#125; if(shadow == false) &#123; continue; &#125; &#125; result += computePhongLighting(L, N, V, *nearestHitRec.mat_ptr, scene.ptLight[i]); &#125; result += scene.amLight.I_a * nearestHitRec.mat_ptr-&gt;k_a; if(reflectLevels &gt; 0) &#123; Vector3d dir = mirrorReflect(V, N); Ray rRay(nearestHitRec.p,dir); result += nearestHitRec.mat_ptr-&gt;k_rg * TraceRay(rRay,scene,--reflectLevels,hasShadow); &#125; return result;&#125; ReferenceLearn OpenGL","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Lighting and Materials","slug":"Lighting_and_Materials","date":"2018-07-09T12:59:05.000Z","updated":"2018-07-10T07:29:02.512Z","comments":true,"path":"2018/07/09/Lighting_and_Materials/","link":"","permalink":"http://HuCoco.com/2018/07/09/Lighting_and_Materials/","excerpt":"LightingCaculate lighting effect is extremely complicated and it depends on way too many factors in real world, therefore we use a method based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the Phong lighting model. Phong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area.","text":"LightingCaculate lighting effect is extremely complicated and it depends on way too many factors in real world, therefore we use a method based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the Phong lighting model. Phong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area. In 1977 the Blinn-Phong lighting model was introduced by James F. Blinn as an extension to the Phong shading we’ve used so far. The Blinn-Phong model is largely similar, but approaches the specular model slightly different which as a result overcomes our problem. Instead of relying on a reflection vector we’re using a so called halfway vector that is a unit vector exactly halfway between the view direction and the light direction. The closer this halfway vector aligns with the surface’s normal vector, the higher the specular contribution. Getting the halfway vector is easy, we add the light’s direction vector and view vector together and normalize the result: \\overline{H} = \\frac{\\overline{V} + \\overline{H}} {\\begin{Vmatrix} \\overline{V} + \\overline{H} \\end{Vmatrix}}MatrialsThe major building blocks of the Phong model consist of 3 components: ambient, diffuse and specular lighting. Below you can see what these lighting components actually look like: Ambient lighting: even when it is dark there is usually still some light somewhere in the world (the moon, a distant light) so objects are almost never completely dark. To simulate this we use an ambient lighting constant that always gives the object some color. Diffuse lighting: simulates the directional impact a light object has on an object. This is the most visually significant component of the lighting model. The more a part of an object faces the light source, the brighter it becomes. 1ptLight.I_source * mat-&gt;k_d * NL Specular lighting: simulates the bright spot of a light that appears on shiny objects. Specular highlights are often more inclined to the color of the light than the color of the object. 123float RVn = pow( (float) dot( V, R ), (float) mat-&gt;n); \\\\Phong lighting modelfloat RVn = pow( (float) dot( N, H ), (float) mat-&gt;n); \\\\Blinn-Phong lighting modelptLight.I_source * mat-&gt;k_r * RVn); Phong lighting model1234567891011static Color computePhongLighting( const Vector3d &amp;L, const Vector3d &amp;N, const Vector3d &amp;V, const EMPMaterial* mat, const PointLightSource &amp;ptLight )&#123; Vector3d NN = ( dot( L, N ) &gt;= 0.0 )? N : -N; Vector3d R = mirrorReflect( L, NN ); float NL = (float) dot( NN, L ); float RVn = pow( (float) dot( V, R ), (float) mat-&gt;n ); return ptLight.I_source * ( mat-&gt;k_d * NL + mat-&gt;k_r * RVn );&#125; Blinn-Phong lighting model12345678910111213static Color computeBlinnPhongLighting(const Vector3d &amp;L, const Vector3d &amp;N, const Vector3d &amp;V, const EMPMaterial* mat, const PointLightSource &amp;ptLight)&#123; Vector3d NN = (dot(L, N) &gt;= 0.0) ? N : -N; Vector3d R = mirrorReflect(L, NN); Vector3d H = L + V; H = H.makeUnitVector(); float NL = (float)dot(NN, L); float RVn = pow((float)dot(N, H), (float)mat-&gt;n); return ptLight.I_source * (mat-&gt;k_d * NL + mat-&gt;k_r * RVn);&#125; those lighting models are experience model, it is not base on physically visual effect. physically based rendering is a collection of render techniques, these techniques will be introduced in other series of articles. Physically Based Rendering Series Catalogue, and the series is in progress. ReferenceLearn OpenGL","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Ray and Camera","slug":"Ray-and-Camera","date":"2018-07-07T08:08:16.000Z","updated":"2018-07-10T07:28:33.479Z","comments":true,"path":"2018/07/07/Ray-and-Camera/","link":"","permalink":"http://HuCoco.com/2018/07/07/Ray-and-Camera/","excerpt":"RayFinding ray-object intersection and computing surface normal is central to ray tracing. Ray representations: Two 3D vectors Ray origin position Ray direction vector Parametric form $P(t) = origin + t \\times direction$","text":"RayFinding ray-object intersection and computing surface normal is central to ray tracing. Ray representations: Two 3D vectors Ray origin position Ray direction vector Parametric form $P(t) = origin + t \\times direction$ Computing Reflection / Refraction Rays Snell’s law\\mu_1sin\\theta = \\mu_2sin\\phiReflectionR = 2 (N \\cdot L) N - LRefraction\\mu = \\frac{\\mu_1}{\\mu_2}T = -\\mu L + (\\mu (N \\cdot L) - \\sqrt{1 - \\mu^2 (1 - (N \\cdot L)^2)})NRecursive Ray TracingFor each reflection/refraction ray spawned, we can trace it just like tracing the original ray. When to stop recursion? When the surface is totally diffuse (and opaque) When reflected/refracted ray hits nothing When maximum recursion depth is reached When the contribution of the reflected/refracted ray to thecolor at the top level is too small $(K_{rg1} | K_{tg1}) \\times \\cdots \\times (k_{rg(n-1)}|k_{tg(n-1)}) &lt; threshold $ CameraCamera view &amp; image resolution Camera position and orientation in world coordinate frame Similar to gluLookAt() Field of view Similar to gluPerspective(), but no need near &amp; far plane Image resolution Number of pixels in each dimension 1234567891011121314151617181920212223242526Camera &amp;Camera::setCamera( const Vector3d &amp;eye, const Vector3d &amp;lookAt, const Vector3d &amp;upVector, double left, double right, double bottom, double top, double near, int image_width, int image_height )&#123; assert( image_width &gt; 0 &amp;&amp; image_height &gt; 0 ); mImageWidth = image_width; mImageHeight = image_height; mCOP = eye; Vector3d cop_n = (eye - lookAt).unitVector(); Vector3d cop_u = cross( upVector.unitVector(), cop_n ); Vector3d cop_v = cross( cop_n, cop_u ); mImageOrigin = mCOP + ( left * cop_u ) + ( bottom * cop_v ) + ( -near * cop_n ); mImageU = (right - left) * cop_u; mImageV = (top - bottom) * cop_v; return (*this);&#125;Ray getRay( double pixelPosX, double pixelPosY ) const&#123; Vector3d imgPos = mImageOrigin + (pixelPosX/mImageWidth) * mImageU + (pixelPosY/mImageHeight) * mImageV; return Ray( mCOP, imgPos - mCOP );&#125; ReferenceLearn OpenGL","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Various surfaces","slug":"Various-surfaces","date":"2018-07-06T15:28:40.000Z","updated":"2018-07-10T07:28:24.711Z","comments":true,"path":"2018/07/06/Various-surfaces/","link":"","permalink":"http://HuCoco.com/2018/07/06/Various-surfaces/","excerpt":"Ray-Plane IntersectionPlane is often represented in implicit form : Ax + By + Cz + D = 0Equivalent: N \\cdot P + D = 0where $N = [A B C]^T$ and $P = [x y z]^T$ To find ray-plane intersection, substitute ray equation $P(t)$ into plane equation: We get $N \\cdot P + D = 0$. Sovle for $t$ to get $t_0$. if $t_0$ is infinity, no intersection (ray is parallel to plane). Intersection point is $P(t_0)$. Verify that intersection is not behind ray origin. The normal at the intersection is $N$ (or $-N$)","text":"Ray-Plane IntersectionPlane is often represented in implicit form : Ax + By + Cz + D = 0Equivalent: N \\cdot P + D = 0where $N = [A B C]^T$ and $P = [x y z]^T$ To find ray-plane intersection, substitute ray equation $P(t)$ into plane equation: We get $N \\cdot P + D = 0$. Sovle for $t$ to get $t_0$. if $t_0$ is infinity, no intersection (ray is parallel to plane). Intersection point is $P(t_0)$. Verify that intersection is not behind ray origin. The normal at the intersection is $N$ (or $-N$) 12345678910111213141516bool Plane::hit( const Ray &amp;r, double tmin, double tmax, SurfaceHitRecord &amp;rec ) const &#123; Vector3d N( A, B, C ); double NRd = dot( N, r.direction() ); double NRo = dot( N, r.origin() ); double t = (-D - NRo) / NRd; if ( t &lt; tmin || t &gt; tmax ) &#123; return false; &#125; rec.t = t; rec.p = r.pointAtParam(t); rec.normal = N; rec.mat_ptr = matp; return true;&#125; Ray-Sphere IntersectionSphere (centered at origin) is often represented in implicit form: x^2 + y^2 + z^2 - r^2 = 0Equivalent: P \\cdot P - r^2 = 0To find ray-plane intersection, substitute ray equation P(t) into plane equation: We get $P \\cdot P - r^2 = 0$: P(t) \\cdot P(t) - r^2 = 0(R_o + tR_d) \\cdot (R_o + tR_d) - r^2 = 0R_d \\cdot R_dt^2 + 2R_d \\cdot R_o + R_o \\cdot R_o - r^2 = 0$R_o$ is ray origin, $R_d$ is ray direction. It is a quadratic equation in the form $at^2 + bt + c = 0$ $a = R_o \\cdot R_o = 1$ (Since $|R_d| = 1$) $b = 2R_d \\cdot R_o$ $c = R_o \\cdot R_o - r^2$ Discriminant: $d = b^2 + 4ac$ Solution: $t_\\pm = \\frac{-b\\pm\\sqrt{b^2 + 4ac}}{2a}$ Choose $t_0$ as the closest positive $t$ value ($t_+$ + or $t_-$) The normal at the intersection point is $P(t_0)/|P(t_0)|$ Very easy to compute, that is why most ray tracing images have spheres. 1234567891011121314151617181920212223bool Sphere::hit( const Ray &amp;r, double tmin, double tmax, SurfaceHitRecord &amp;rec ) const &#123; Vector3d Rd = r.direction(); Vector3d Ro = r.origin() - center; double a = dot(Rd,Rd); double b = 2.0 * dot(Rd, Ro); double c = dot(Ro,Ro) - pow(radius, 2); double d = pow(b, 2) - 4.0 * a * c; if(d &lt; 0) &#123; return false; &#125; double t = (-b - sqrt(d)) / (2.0f * a); if ( t &gt;= tmin &amp;&amp; t &lt;= tmax ) &#123; rec.t = t ; rec.p = r.pointAtParam(t); rec.normal = (Ro + t * Rd) / radius; rec.mat_ptr = matp; return true; &#125; return false;&#125; Ray-Box IntersectionTo find ray-box intersection: For each pair of parallel plane, find the distance to the first plane ($t_{near}$) and to the second plane ($t_{far}$). Keep the largest $t_{near}$ so far, and smallest $t_{far}$ so far. If largest $t_{near}$ &gt; smallest $t_{far}$ , no intersection. Otherwise, the intersection is at P(largest $t_{near}$ ) Ray-Triangle IntersectionFinding intersection between a ray and a general polygon is difficult. Compute ray-plane intersection Determine whether intersection is within polygon Tedious for non-convex polygon Interpolation of attributes at the vertices are not well-defined Much easier to find ray-triangle intersection Can use the barycentric coordinates method. Interpolation of attributes at the vertices are well-defined using the barycentric coordinates. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bool Triangle::hit( const Ray &amp;r, double tmin, double tmax, SurfaceHitRecord &amp;rec ) const &#123; double A = v0.x() - v1.x(); double B = v0.y() - v1.y(); double C = v0.z() - v1.z(); double D = v0.x() - v2.x(); double E = v0.y() - v2.y(); double F = v0.z() - v2.z(); double G = r.direction().x(); double H = r.direction().y(); double I = r.direction().z(); double J = v0.x() - r.origin().x(); double K = v0.y() - r.origin().y(); double L = v0.z() - r.origin().z(); double EIHF = E*I - H*F; double GFDI = G*F - D*I; double DHEG = D*H - E*G; double denom = (A*EIHF + B*GFDI + C*DHEG); double beta = (J*EIHF + K*GFDI + L*DHEG) / denom; if ( beta &lt; 0.0 || beta &gt; 1.0 ) return false; double AKJB = A*K - J*B; double JCAL = J*C - A*L; double BLKC = B*L - K*C; double gamma = (I*AKJB + H*JCAL + G*BLKC) / denom; if ( gamma &lt; 0.0 || beta + gamma &gt; 1.0 ) return false; double t = -(F*AKJB + E*JCAL + D*BLKC) / denom; if ( t &gt;= tmin &amp;&amp; t &lt;= tmax ) &#123; // We have a hit -- populat hit record. rec.t = t; rec.p = r.pointAtParam(t); double alpha = 1.0 - beta - gamma; rec.normal = alpha * n0 + beta * n1 + gamma * n2; rec.mat_ptr = matp; return true; &#125; return false;&#125; Barycentric CoordinatesThe barycentric coordinates of a point P on a triangle $ABC$ is ($ \\alpha $, $ \\beta $, $ \\gamma $) such that: P = \\alpha A + \\beta B + \\gamma Cwhere \\alpha + \\beta + \\gamma = 1and 0 \\leq \\alpha,\\beta,\\gamma \\leq 1We can rewrite it as: P = (1 - \\beta - \\gamma)A + \\beta B + \\gamma CP = A + \\beta(B-A) + \\gamma(C-A) To find ray-triangle intersection, we let: P(t) = A + \\beta(B-A) + \\gamma(C-A)R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)Solve for $t$, $\\beta$ and $\\gamma$ Intersection if $\\beta + \\gamma &lt; 1$ and $\\beta,\\gamma &gt; 0$ and $t &gt; 0$ Expand &amp;R_o + tR_d = A + \\beta(B-A) + \\gamma(C-A)&amp; \\begin{cases} R_{ox} + tR_{dx} = A_x + \\beta(B_x-A_x) + \\gamma(C_x + A_x) \\\\ R_{oy} + tR_{dy} = A_y + \\beta(B_y-A_y) + \\gamma(C_y + A_y) \\\\ R_{oz} + tR_{dz} = A_z + \\beta(B_z-A_z) + \\gamma(C_z + A_z) \\\\ \\end{cases}we have 3 equations and 3 unknowns here. Regroup and write in matrix form \\begin{bmatrix} A_x - B_x &A_x - C_x &R_{dx}\\\\ A_y - B_y &A_y - C_y &R_{dy}\\\\ A_z - B_z &A_z - C_z &R_{dz} \\end{bmatrix} \\begin{bmatrix} \\beta \\\\ \\gamma \\\\ t \\end{bmatrix} = \\begin{bmatrix} A_x - R_{ox} \\\\ A_y - R_{oy} \\\\ A_z - R_{oz} \\end{bmatrix}Use Cramer’s Rule to solve for $t$, $\\beta$ and $\\gamma$ \\beta = \\frac { \\begin{vmatrix} A_x - R_{ox} &A_x-C_x &R_{dx} \\\\ A_y - R_{oy} &A_y-C_y &R_{dy} \\\\ A_z - R_{oz} &A_z-C_z &R_{dz} \\end{vmatrix} } { |A| } \\gamma = \\frac { \\begin{vmatrix} A_x - B_{x} &A_x-R_{ox} &R_{dx} \\\\ A_y - B_{y} &A_y-R_{oy} &R_{dy} \\\\ A_z - B_{z} &A_z-R_{oz} &R_{dz} \\end{vmatrix} } { |A| } t= \\frac { \\begin{vmatrix} A_x - B_{x} &A_x - C_{x} &A_x-R_{ox} \\\\ A_y - B_{y} &A_x - C_{x} &A_y-R_{oy} \\\\ A_z - B_{z} &A_x - C_{x} &A_z-R_{oz} \\end{vmatrix} } { |A| }12345678910111213141516171819202122232425262728293031323334bool Triangle::hit( const Ray &amp;r, double tmin, double tmax, SurfaceHitRecord &amp;rec ) const &#123; Vector3d e1 = v1 - v0; Vector3d e2 = v2 - v0; Vector3d p = cross( r.direction(), e2 ); double a = dot( e1, p ); double f = 1.0 / a; Vector3d s = r.origin() - v0; double beta = f * dot( s, p ); if ( beta &lt; 0.0 || beta &gt; 1.0 ) &#123; return false; &#125; Vector3d q = cross( s, e1 ); double gamma = f * dot( r.direction(), q ); if ( gamma &lt; 0.0 || beta + gamma &gt; 1.0 ) &#123; return false; &#125; double t = f * dot( e2, q ); if ( t &gt;= tmin &amp;&amp; t &lt;= tmax ) &#123; rec.t = t; rec.p = r.pointAtParam(t); double alpha = 1.0 - beta - gamma; rec.normal = alpha * n0 + beta * n1 + gamma * n2; rec.mat_ptr = matp; return true; &#125; return false;&#125; Advantages of Barycentric Intersection Efficient No need to store plane equation Barycentric coordinates are useful for linear interpolation of normal vectors, texture coordinates, and other attributes at the vertices For example, the interpolated normal at $P$ is: N_p = (1 - \\beta - \\gamma)N_A + \\beta N_B + \\gamma N_Cand all vector should do a normalization. The “Epsilon” ProblemShould not accept intersection for very small positive $t$ May falsely intersect the surface at the ray origin Method 1: Use an epsilon value $\\varepsilon$ &gt; 0, and accept an intersection only if its $t &gt; \\varepsilon$. Method 2: When a new ray is spawned, advanced the ray origin by an epsilon distance $\\varepsilon$ in the ray direction ReferenceLearn OpenGL","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Ray Tracing Overview","slug":"Theory-of-Ray-Tracing","date":"2018-07-05T12:09:50.000Z","updated":"2018-07-10T07:28:00.431Z","comments":true,"path":"2018/07/05/Theory-of-Ray-Tracing/","link":"","permalink":"http://HuCoco.com/2018/07/05/Theory-of-Ray-Tracing/","excerpt":"Overview In 3D compute graphics, ray tracing is rendering technique for generating an visual image by tracing the path of light. it has better effect than either ray casting and scan-line rendering techniques. Typically, there are two question need be deal: What object has been seen? What color of the object is under the influence of light and environment? In nature, a ray will travel to a surface that stop ray traveling, or until out of energy eventually disappears.there are four things might happen with light ray: absorption, reflection, refraction, fluorescence,","text":"Overview In 3D compute graphics, ray tracing is rendering technique for generating an visual image by tracing the path of light. it has better effect than either ray casting and scan-line rendering techniques. Typically, there are two question need be deal: What object has been seen? What color of the object is under the influence of light and environment? In nature, a ray will travel to a surface that stop ray traveling, or until out of energy eventually disappears.there are four things might happen with light ray: absorption, reflection, refraction, fluorescence, Ray CastingIn ancient time, it was used for the study of perspective. The first ray tracing algorithm used for rendering was presented by Arthur Appel in 1968.[1] This algorithm has since been termed “ray casting”. The idea behind ray casting is to shoot rays from the eye, one per pixel, and find the closest object blocking the path of that ray. Think of an image as a screen-door, with each square in the screen being a pixel. This is then the object the eye sees through that pixel. Using the material properties and the effect of the lights in the scene, this algorithm can determine the shading of this object. The simplifying assumption is made that if a surface faces a light, the light will reach that surface and not be blocked or in shadow. The shading of the surface is computed using traditional 3D computer graphics shading models. One important advantage ray casting offered over older scanline algorithms was its ability to easily deal with non-planar surfaces and solids, such as cones and spheres. If a mathematical surface can be intersected by a ray, it can be rendered using ray casting. Elaborate objects can be created by using solid modeling techniques and easily rendered. Ray Tracingit almost like ray casting, but in ray tracing, it will generate some new ray from the closet intersection point. Reflection ray Refraction ray Shadow rays and this technique also called Recursive Ray Tracing. AdvantagesRay tracing’s popularity stems from its basis in a realistic simulation of lighting over other rendering methods (such as scanline rendering or ray casting). Effects such as reflections and shadows, which are difficult to simulate using other algorithms, are a natural result of the ray tracing algorithm. The computational independence of each ray makes ray tracing amenable to parallelization. DisadvantagesA serious disadvantage of ray tracing is performance (though it can in theory be faster than traditional scanline rendering depending on scene complexity vs. number of pixels on-screen). Scanline algorithms and other algorithms use data coherence to share computations between pixels, while ray tracing normally starts the process anew, treating each eye ray separately. However, this separation offers other advantages, such as the ability to shoot more rays as needed to perform spatial anti-aliasing and improve image quality where needed. Although it does handle interreflection and optical effects such as refraction accurately, traditional ray tracing is also not necessarily photorealistic. True photorealism occurs when the rendering equation is closely approximated or fully implemented. Implementing the rendering equation gives true photorealism, as the equation describes every physical effect of light flow. However, this is usually infeasible given the computing resources required. The realism of all rendering methods can be evaluated as an approximation to the equation. Ray tracing, if it is limited to Whitted’s algorithm, is not necessarily the most realistic. Methods that trace rays, but include additional techniques (photon mapping, path tracing), give far more accurate simulation of real-world lighting. Ray Tracing Detail ShadowAt each surface intersection point,a shadow ray is shot towards eachlight source to determine any occlusion between light source and surface point. ReferenceRay Tracing Wiki NUSRI Summer Programme 2016, 3D Graphics Rendering, Lecture 9 Ray Tracing, School of Computing National University of Singapore Learn OpenGL","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"Physically Based Rendering Catalogue","slug":"Physically-Based-Rendering-Catalogue","date":"2018-07-04T13:57:47.000Z","updated":"2018-07-11T14:11:54.960Z","comments":true,"path":"2018/07/04/Physically-Based-Rendering-Catalogue/","link":"","permalink":"http://HuCoco.com/2018/07/04/Physically-Based-Rendering-Catalogue/","excerpt":"","text":"This is catalogue of Physically Based Rendering, I will update it if I have free time.(It’s means I don’t know what time I will finish one of them.) Theory of Physically Based Rendering The Reflectance Equation BRDF Lighting IBL","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"PBR","slug":"Graphics/PBR","permalink":"http://HuCoco.com/categories/Graphics/PBR/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"PBR","slug":"PBR","permalink":"http://HuCoco.com/tags/PBR/"}]},{"title":"Ray Tracing Catalogue","slug":"Ray-Tracing-Catalogue","date":"2018-07-04T13:26:13.000Z","updated":"2018-07-10T07:24:41.125Z","comments":true,"path":"2018/07/04/Ray-Tracing-Catalogue/","link":"","permalink":"http://HuCoco.com/2018/07/04/Ray-Tracing-Catalogue/","excerpt":"","text":"This is catalogue of Ray Tracing, I will update it if I have free time.(It’s means I don’t know what time I will finish one of them.) Theory of ray tracing Ray and Scene Various surfaces Lighting and Materials Do ray tracing Coming soon… Ambient Occlusion Blur","categories":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/categories/Graphics/"},{"name":"Ray Tracing","slug":"Graphics/Ray-Tracing","permalink":"http://HuCoco.com/categories/Graphics/Ray-Tracing/"}],"tags":[{"name":"Graphics","slug":"Graphics","permalink":"http://HuCoco.com/tags/Graphics/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://HuCoco.com/tags/Ray-Tracing/"}]},{"title":"SSE Instruction List","slug":"SSE-Instruction-List","date":"2018-03-26T14:22:53.000Z","updated":"2018-03-26T14:50:20.776Z","comments":true,"path":"2018/03/26/SSE-Instruction-List/","link":"","permalink":"http://HuCoco.com/2018/03/26/SSE-Instruction-List/","excerpt":"","text":"move instruction Instruction Description movaps move 4 alignment single precision value to xmm register movups move 4 non-alignment single precision value to xmm register movss move 1 alignment single precision value to low 4 bytes of register movlps move 2 alignment single precision value to low 8 bytes of register movhps move 2 alignment single precision value to high 8 bytes of register movlhps move 2 alignment single precision value to high 8 bytes of register from low 8 bytes movhlps move 2 alignment single precision value to low 8 bytes of register from high 8 bytes basic operation instruction Instruction Description addps add operation subps sub operation mulps mul operation divps div operation rcpps rcp opeartion sqrtps sqrt operation rsqrtps rcp sqrt operation maxps get max operation minps get min operation andps and operation andnps negation operation orps or operation xorps xor operation compared instruction Instruction Description cmpps compared operation cmpss compared operation comiss compared and set eflags register ucomiss compared and set eflags register those instruction will return a value: Return Value Description 0 Equal to 1 Less-than 2 Less than or equal to 3 Disorder 4 Not equal to 5 Greater than 6 Greater than or equal to 7 Order","categories":[{"name":"SIMD","slug":"SIMD","permalink":"http://HuCoco.com/categories/SIMD/"},{"name":"SSE","slug":"SIMD/SSE","permalink":"http://HuCoco.com/categories/SIMD/SSE/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"SIMD","slug":"SIMD","permalink":"http://HuCoco.com/tags/SIMD/"},{"name":"SSE","slug":"SSE","permalink":"http://HuCoco.com/tags/SSE/"}]},{"title":"Sorting Algorithm","slug":"Sorting-Algorithm","date":"2018-03-10T05:07:14.000Z","updated":"2018-03-10T05:34:49.563Z","comments":true,"path":"2018/03/10/Sorting-Algorithm/","link":"","permalink":"http://HuCoco.com/2018/03/10/Sorting-Algorithm/","excerpt":"8 Kind of Sorting AlgorithmBubble sort1234567def bubble_sort(lists): count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists","text":"8 Kind of Sorting AlgorithmBubble sort1234567def bubble_sort(lists): count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists Insertion sort1234567891011def insert_sort(lists): count = len(lists) for i in range(1, count): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j + 1] = lists[j] lists[j] = key j -= 1 return lists Shell Sort123456789101112131415161718def shell_sort(lists): count = len(lists) step = 2 group = count // step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lists[j] while k &gt;= 0: if lists[k] &gt; key: lists[k + group] = lists[k] lists[k] = key k -= group j += group group //= step return lists Selection Sort123456789def select_sort(lists): count = len(lists) for i in range(0, count): min = i for j in range(i + 1, count): if lists[min] &gt; lists[j]: min = j lists[min], lists[i] = lists[i], lists[min] return lists heap sort1234567891011121314151617181920212223def adjust_heap(lists, i, size): lchild = 2 * i + 1 rchild = 2 * i + 2 max = i if i &lt; size // 2: if lchild &lt; size and lists[lchild] &gt; lists[max]: max = lchild if rchild &lt; size and lists[rchild] &gt; lists[max]: max = rchild if max != i: lists[max], lists[i] = lists[i], lists[max] adjust_heap(lists, max, size) def build_heap(lists, size): for i in range(0, (size//2))[::-1]: adjust_heap(lists, i, size) def heap_sort(lists): size = len(lists) build_heap(lists, size) for i in range(0, size)[::-1]: lists[0], lists[i] = lists[i], lists[0] adjust_heap(lists, 0, i) Fast sorting1234567891011121314151617def quick_sort(lists, left, right): if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return lists Merging sorting123456789101112131415161718192021def merge(left, right): i, j = 0, 0 result = [] while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return result def merge_sort(lists): if len(lists) &lt;= 1: return lists num = len(lists) // 2 left = merge_sort(lists[:num]) right = merge_sort(lists[num:]) return merge(left, right)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://HuCoco.com/categories/Algorithm/Sort/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://HuCoco.com/tags/Python/"},{"name":"Sort","slug":"Sort","permalink":"http://HuCoco.com/tags/Sort/"}]},{"title":"N-Queens Problem","slug":"N-Queens-Problem","date":"2018-03-09T13:51:43.000Z","updated":"2018-03-09T14:43:00.190Z","comments":true,"path":"2018/03/09/N-Queens-Problem/","link":"","permalink":"http://HuCoco.com/2018/03/09/N-Queens-Problem/","excerpt":"N-Queens ProblemOverviewThe eight queens problem is a question with chess as the background: how to place eight queens on an 8×8 chess board so that no queen can directly eat other queens? In order to achieve this purpose, any two queens are not in the same horizontal, vertical or diagonal. The eight queen problem can be extended to the more general N-Queens Problem. more information about n-queens problem please google it. C++ Code123456789101112int NQueens(int n) &#123; int upperlim = (1 &lt;&lt; n) - 1, sum = 0; std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123; if(row == upperlim) &#123;++sum;return;&#125; for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123; pos = cur &amp; (-cur); cur -= pos; &#125; &#125;; dfs(0,0,0); return sum;&#125;","text":"N-Queens ProblemOverviewThe eight queens problem is a question with chess as the background: how to place eight queens on an 8×8 chess board so that no queen can directly eat other queens? In order to achieve this purpose, any two queens are not in the same horizontal, vertical or diagonal. The eight queen problem can be extended to the more general N-Queens Problem. more information about n-queens problem please google it. C++ Code123456789101112int NQueens(int n) &#123; int upperlim = (1 &lt;&lt; n) - 1, sum = 0; std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123; if(row == upperlim) &#123;++sum;return;&#125; for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123; pos = cur &amp; (-cur); cur -= pos; &#125; &#125;; dfs(0,0,0); return sum;&#125; Introductioninitialization1upperlim = (1 &lt;&lt; n) - 1, sum = 0; Upperlim value is n-bit binary 1. Recursive Function1234567std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123; if(row == upperlim) &#123;++sum;return;&#125; for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123; pos = cur &amp; (-cur); cur -= pos; &#125;&#125;; The function has three parameters: row : row ld : Left diagonal rd : Right diagonal Use these three parameters to determine whether a queen can be placed in a certain position. DiagramHere is a step-by-step illustration of the Six Queens question. 12345row = 000001ld = 000010rd = 000000cur = 111100pos = 000100 12345row = 000101ld = 001100rd = 000010 cur = 110000pos = 010000 12345row = 010101ld = 111000rd = 001001 cur = 000010pos = 000010 12345row = 010111ld = 110100rd = 000101 cur = 001000pos = 001000 12345row = 011111ld = 111000rd = 000110cur = 000000pos = 000000 The first round of search is completed, there is a kind of thought is the depth first search, is to find a solution and then press forward to the enemy’s capital to find second solution, because the eight queens problem belongs to the scope of the graph, so the idea of graph theory can be found in this problem.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Problems","slug":"Algorithm/Problems","permalink":"http://HuCoco.com/categories/Algorithm/Problems/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"},{"name":"Backtracking","slug":"Backtracking","permalink":"http://HuCoco.com/tags/Backtracking/"}]},{"title":"Topological Sort","slug":"Topological-Sort","date":"2018-03-08T12:14:15.000Z","updated":"2018-03-08T12:43:16.271Z","comments":true,"path":"2018/03/08/Topological-Sort/","link":"","permalink":"http://HuCoco.com/2018/03/08/Topological-Sort/","excerpt":"Topological Sort Chinese version address Topological SortOverviewTopological sorting means ordering a Directed Acyclic Graph(DAG) to get an ordered linear sequence. In this way, it may be understood more abstractly. For example, a project consists of four subsections A, B, C, and D, and A depends on B and D. C depends on D. Now to develop a plan to write A, B, C, D the order of execution. At this point, you can use topological sorting, which is used to determine the order in which things happen. In topological sorting, if there is a path from the vertex A to the vertex B, B appears behind the A in the ranking result. Algorithm Introduction Create a queue Q and a topological ordered result queue T. Put all the nodes that do not depend on the vertex in the Q. When Q has vertices, perform the following steps. Take a vertex n from Q (delete n from Q) and put it in T (add n to the result set). For every adjacent point m (n is the starting point and m is the ending point). Remove the edge (n, m). If m does not depend on the vertex, put b into Q. The vertex A does not depend on the vertex, which means there is no edge to the end of the A.","text":"Topological Sort Chinese version address Topological SortOverviewTopological sorting means ordering a Directed Acyclic Graph(DAG) to get an ordered linear sequence. In this way, it may be understood more abstractly. For example, a project consists of four subsections A, B, C, and D, and A depends on B and D. C depends on D. Now to develop a plan to write A, B, C, D the order of execution. At this point, you can use topological sorting, which is used to determine the order in which things happen. In topological sorting, if there is a path from the vertex A to the vertex B, B appears behind the A in the ranking result. Algorithm Introduction Create a queue Q and a topological ordered result queue T. Put all the nodes that do not depend on the vertex in the Q. When Q has vertices, perform the following steps. Take a vertex n from Q (delete n from Q) and put it in T (add n to the result set). For every adjacent point m (n is the starting point and m is the ending point). Remove the edge (n, m). If m does not depend on the vertex, put b into Q. The vertex A does not depend on the vertex, which means there is no edge to the end of the A. The above diagram is an example of a demonstration of the topological sort. Add B and C to the sorting result. Vertex B and vertex C are not dependent on the vertices, so C and C added to the result set T. Suppose ABCDEFG is stored sequentially, so visit B first and then C again. After accessing B, remove the edges (B, A) and (B, D) and add A and D to the queue Q. Similarly, remove the edges (C, F) and (C, G) and add F and G to Q. Add B to the sorted result, and then remove the edges (B, A) and (B, D); at this point, since A and D do not depend on vertices, add A and D to queue Q. The C is added to the sorting result, then the edge (C, F) and (C, G) are removed; at this time, since F has a dependency on the vertex D, G has a dependency on the vertex A, so it does not handle F and G. A, D is added to the sorting result in turn. After the first step, both A and D are not dependent on the vertex, accessing the A first and then accessing the D according to the storage order. After the access, the edges of the vertex A and the vertex D are deleted. Add E, F, G to the sorting result. C++ ImplementationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://HuCoco.com/categories/Algorithm/Sort/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"}]},{"title":"Breadth First Search","slug":"Breadth-First-Search","date":"2018-03-07T15:18:11.000Z","updated":"2018-03-07T16:04:30.235Z","comments":true,"path":"2018/03/07/Breadth-First-Search/","link":"","permalink":"http://HuCoco.com/2018/03/07/Breadth-First-Search/","excerpt":"Breadth First Search Chinese version address Breadth First SearchOverviewThe breadth first search algorithm, also known as “width first search” or “horizontal priority search”, is called BFS. From a vertex in the graph, each of the not visited adjacent points of the V is accessed in turn after accessing the starting vertex, then the adjacency points are accessed in turn from these adjacent points, and the adjacent points of the vertex to be accessed are accessed before the adjacent points of the vertices that are accessed, until all the adjacent points of the vertices are accessed. If the vertices are not accessed at this time, we need to select another vertex which has never been visited as a new starting point, repeat the above process until all the vertices in the graph are accessed. In other words, the process of breadth first search is the starting point and from near to far, access to the path and the path length of the starting vertex and the path length of 1,2… DiagramBreadth first search for undirected graphsThe following is an example of undirected graph, to demonstrate the depth-first search.","text":"Breadth First Search Chinese version address Breadth First SearchOverviewThe breadth first search algorithm, also known as “width first search” or “horizontal priority search”, is called BFS. From a vertex in the graph, each of the not visited adjacent points of the V is accessed in turn after accessing the starting vertex, then the adjacency points are accessed in turn from these adjacent points, and the adjacent points of the vertex to be accessed are accessed before the adjacent points of the vertices that are accessed, until all the adjacent points of the vertices are accessed. If the vertices are not accessed at this time, we need to select another vertex which has never been visited as a new starting point, repeat the above process until all the vertices in the graph are accessed. In other words, the process of breadth first search is the starting point and from near to far, access to the path and the path length of the starting vertex and the path length of 1,2… DiagramBreadth first search for undirected graphsThe following is an example of undirected graph, to demonstrate the depth-first search. Breadth first search of the graph above, starting with vertex A: Steps: Access to A. Access C, D, F in turn. After visiting A, next visit A’s adjoining point. the vertices A,B,C,D,E,F,G are stored in order, so first visit C, after visiting C, next to visit D and F. Access B, G, in turn. After C, D, and F are accessed in the second step, then their adjacency points are accessed in turn. Next first access the adjacency point B of C, and then access the adjacency point G of the F. Access to E. After accessing B and G in the third step, the adjacent points are accessed in turn. Only G has a adjacency point E, so access to the adjacency point E of the G. C++ ImplememtationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress Breadth first search for undirected graphsThe following is an example of directed graph, to demonstrate the Breadth first search. Breadth first search of the graph above, starting with vertex A: Steps: Access to A. Access to B. Access C, E, F in turn. After accessing the B, next to the other vertex of the B’s out-edge, that is, C, E, and F. Access D, G in turn. After accessing C, E, and F, the other vertices of the out-edge of their are accessed in turn. C++ ImplememtationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Search","slug":"Algorithm/Search","permalink":"http://HuCoco.com/categories/Algorithm/Search/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"}]},{"title":"Depth First Search","slug":"Depth-First-Search","date":"2018-03-07T14:47:44.000Z","updated":"2018-03-07T16:04:48.770Z","comments":true,"path":"2018/03/07/Depth-First-Search/","link":"","permalink":"http://HuCoco.com/2018/03/07/Depth-First-Search/","excerpt":"Depth First Search Chinese version address Depth First SearchOverviewDepth first search of the graph is similar to the preorder traversal of the tree. Suppose that the initial state is that all the vertices in the graph are not accessed, then starting from a vertex and first access to it, nextly, the depth first search traversal from each of its non-accessed adjacency points in turn, until all the vertices that have a path to the starting vertex in the graph are accessed. If there are other vertices that are not accessed, then choose another unvisited vertex as a starting point, repeat the above process until all graph vertices have been visited. DiagramDepth first search for undirected graphsThe following is an example of undirected graph, to demonstrate the depth first search.","text":"Depth First Search Chinese version address Depth First SearchOverviewDepth first search of the graph is similar to the preorder traversal of the tree. Suppose that the initial state is that all the vertices in the graph are not accessed, then starting from a vertex and first access to it, nextly, the depth first search traversal from each of its non-accessed adjacency points in turn, until all the vertices that have a path to the starting vertex in the graph are accessed. If there are other vertices that are not accessed, then choose another unvisited vertex as a starting point, repeat the above process until all graph vertices have been visited. DiagramDepth first search for undirected graphsThe following is an example of undirected graph, to demonstrate the depth first search. Depth first search of the graph above, starting with vertex A: Steps: Access to A. Access to C. Because the vertices A,B,C,D,E,F,G are stored in order in this paper, C is in front of D and F, so visit C first. Access to B. Because B before D, first visit B. Access to D. After having visited C’s adjacency point B at step 3, B has no unvisit adjacency points, thus, it returns to another adjacency point D that accesses C. Access to F. All adjacency point of B and C are accessed, so return to A and access to next adjaceny point of A. Access to G. Access to E. C++ ImplememtationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress Depth first search for directed graphsThe following is an example of directed graph, to demonstrate the depth first search. Depth first search of the graph above, starting with vertex A: Steps: Access to A. Access to B. After visiting A, the next vertex to which A should go is the vertex B that should be accessed next. Access to C. After visiting B, what should be followed is another vertex of B’s out-edge. Because C is the first one, so first visit it Access to E. Next to the other vertex of the out-edge of the C vertex. Access to D. Then visit the other vertices of E’s out edge, vertices B and D. Vertex B has already been visited, so visit vertex D. Access to F. Access to G. C++ ImplememtationAdjacency Matrix Version1// Work in progress Adjacency List Version1// Work in progress","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/categories/Algorithm/"},{"name":"Search","slug":"Algorithm/Search","permalink":"http://HuCoco.com/categories/Algorithm/Search/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://HuCoco.com/tags/Algorithm/"}]},{"title":"Adjacency List Graph","slug":"Adjacency-List-Graph","date":"2018-03-05T16:40:11.000Z","updated":"2018-03-07T16:04:09.114Z","comments":true,"path":"2018/03/06/Adjacency-List-Graph/","link":"","permalink":"http://HuCoco.com/2018/03/06/Adjacency-List-Graph/","excerpt":"Adjacency List Graph Chinese version address Adjacency List GraphAdjacency List Undirected GraphAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency list. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains&lt;A,C&gt;, &lt;A,D&gt;, &lt;A,F&gt;, &lt;B,C&gt;, &lt;C,D&gt;, &lt;E,G&gt;, &lt;F,G&gt;, in total 7 edges. Since this is an undirected graph, the edge &lt;A,C&gt; and the edge &lt;C,A&gt; are the same edges. The table of edges is listed in alphabetical order..","text":"Adjacency List Graph Chinese version address Adjacency List GraphAdjacency List Undirected GraphAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency list. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains&lt;A,C&gt;, &lt;A,D&gt;, &lt;A,F&gt;, &lt;B,C&gt;, &lt;C,D&gt;, &lt;E,G&gt;, &lt;F,G&gt;, in total 7 edges. Since this is an undirected graph, the edge &lt;A,C&gt; and the edge &lt;C,A&gt; are the same edges. The table of edges is listed in alphabetical order.. Each vertex contains a linked list that records the index of vertexs. For example, the data of the nodes included in the linked list included in the second vertex (vertex C) is 0, 1, 3, and 0, 1, 3 corresponds to the index of A, B, D. C++ Definition1// Work in progress C++ Implementation1// Work in progress Adjacency Matrix Directed GraphAdjacency matrix directed graph refers to an directed graph represented by an adjacency list. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains &lt;A,B&gt;, &lt;B,C&gt;, &lt;B,E&gt;, &lt;B,F&gt;, &lt;C,E&gt;, &lt;D,C&gt;, &lt;E,B&gt;, &lt;E,D&gt;, &lt;F,G&gt;, in total 7 edges. Each vertex contains a linked list that records the index of vertexs. The linked list contains the index of the other vertex of the out-edge corresponding to this vertex. For example, the data of the first vertex (vertex B) in list is 2,4,5, this 2,4,5 corresponds to index of C, E, F, and C, E, F are the other vertices of B vertex’s out-edge. C++ Definition1// Work in progress C++ Implementation1// Work in progress","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Graph","slug":"Data-Structure/Graph","permalink":"http://HuCoco.com/categories/Data-Structure/Graph/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"}]},{"title":"Adjacency Matrix Graph","slug":"Adjacency-Matrix-Graph","date":"2018-03-05T16:40:02.000Z","updated":"2018-03-07T16:03:45.627Z","comments":true,"path":"2018/03/06/Adjacency-Matrix-Graph/","link":"","permalink":"http://HuCoco.com/2018/03/06/Adjacency-Matrix-Graph/","excerpt":"Adjacency Matrix Graph Chinese version address Adjacency Matrix GraphAdjacency Matrix Undirected GraphAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency matrix. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains, , , , , , , in total 7 edges. Since this is an undirected graph, the edge and the edge are the same edges. The table of edges is listed in alphabetical order.","text":"Adjacency Matrix Graph Chinese version address Adjacency Matrix GraphAdjacency Matrix Undirected GraphAdjacency matrix undirected graph refers to an undirected graph represented by an adjacency matrix. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains, , , , , , , in total 7 edges. Since this is an undirected graph, the edge and the edge are the same edges. The table of edges is listed in alphabetical order. N/A A B C D E F G A 0 0 1 1 0 1 0 B 0 0 1 0 0 0 0 C 1 1 0 1 0 0 0 D 1 0 1 0 0 0 0 E 0 0 0 0 0 0 1 F 1 0 0 0 0 0 1 G 0 0 0 0 1 1 0 The matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that from the ith vertex to the jth vertex is a edge. A[i][j] = 0 indicates that they are not adjacent points. C++ Definition1// Work in progress C++ Implementation1// Work in progress Adjacency Matrix Directed GraphAdjacency matrix undirected graph refers to an directed graph represented by an adjacency matrix. The above graph contains 7 vertices of A, B, C, D, E, F, G, and it also contains , , , , , , , , , in total 7 edges. N/A A B C D E F G A 0 0 1 0 0 0 0 B 0 0 1 0 1 1 0 C 0 0 0 0 1 0 0 D 0 0 1 0 0 0 0 E 0 1 0 1 0 0 1 F 0 0 0 0 0 0 1 G 0 0 0 0 0 0 0 The matrix above is a schematic of the adjacency matrix in memory. A[i][j] = 1 means that the ith vertex and the jth vertex are adjacent points. A[i][j] = 0 indicates that not a edge. C++ Definition1// Work in progress C++ Implementation1// Work in progress","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Graph","slug":"Data-Structure/Graph","permalink":"http://HuCoco.com/categories/Data-Structure/Graph/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"}]},{"title":"Basic Graph Theory","slug":"Basic-Graph-Theory","date":"2018-03-04T14:09:57.000Z","updated":"2018-03-07T16:06:32.906Z","comments":true,"path":"2018/03/04/Basic-Graph-Theory/","link":"","permalink":"http://HuCoco.com/2018/03/04/Basic-Graph-Theory/","excerpt":"Basic Graph Theory Chinese version address Graph TheoryThe definition of graphThe graph is composed of some points and the connection between these points. points are often called vertices, and the lines between points are called edges. It is usually written as G = (V,E). Types of GraphsAccording to whether the direction of the edge, the graph can be divided into: undirected and directed graph. Undirected graph","text":"Basic Graph Theory Chinese version address Graph TheoryThe definition of graphThe graph is composed of some points and the connection between these points. points are often called vertices, and the lines between points are called edges. It is usually written as G = (V,E). Types of GraphsAccording to whether the direction of the edge, the graph can be divided into: undirected and directed graph. Undirected graph The above graph is an undirected graph, and all the edges of the undirected graph are not directed. It is written as G0=(V1,{E1}). V1 = { A,B,C,D,E,F } V1 represents a set of vertices composed of A, B, C, D, E, F. E1 = { (A,B),(A,C),(B,C),(B,E),(B,F),(C,F),(C,D),(E,F),(C,E)} E1 is by the edge (A, B), the edge (A, C)… And so on, and so on. (A, C) represents the edge that is connected by the vertex A and the vertex C. Directed graph The graph above is a directed graph. Unlike an undirected graph, all the edges of the directed graph are directed. It is written as G2= (V2, {E2}). V2={ A,C,B,F,D,E,G } V2 represents a set of vertices composed of A, B, C, D, E, F, G. E2={ &lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt; } E2 is a , … And so on, and so on. In this, vector represents the directed edge of the vertex C that is directed by the vertex A. Adjacent &amp; DegreeAdjacentThe two vertices on an edge are called the adjacency points. For example, the vertex A and the vertex C in the above undirected graph are the adjacency points. In the digraph, except for the adjoining points; there are also the notions of &quot;In-Edge&quot; and &quot;Out-Edge&quot;. In-Edge is means which edge that end with the vertex. Out-Edge is means which edge that start with the vertex. For example, the B and E in graph G2 are adjacent points; is the Out-Edge of B, or the In-Edge of E. DegreeIn an undirected graph, the degree of a vertex is the number of edges adjacent to the vertex. For example, the degree of the vertex A in the above undirected graph is 2. In the digraph, there are also the notions of &quot;In-Degree&quot; and &quot;Out-Degree&quot; In-Degree is means the number of edges at the end of the vertex. Out-Degree is means the number of edges at the start of the vertex. Degree of vertex = In-Degree + Out-Degree Path &amp; CircuitPath: If a vertex sequence exists between the vertex (Vm) to the vertex (Vn). It means that Vm to Vn is a path Length of path: the number of edge in this path. Simple path: If the vertex of a path does not repeat, it is a simple path. Circuit: If the first vertex of the path is the same as the last vertex, it is a Circuit. Simple circuit: If the vertex of a circuit does not repeat, it is a simple circuit. Connected graphs and connected componentsConnected graph: For an undirected graph, there is an undirected path between any two vertices, and the undirected graph is called a connected graph. strongly connected graph: For a directed graph, if there is a directed path between any two vertices in the graph, the directed graph is called a strongly connected graph. Weight of GraphThis is special value in Huffman tree, it is means the value of a edge. Graph Storage StructuresThe storage structure of a graph is commonly used as adjacency matrix and adjacency list. Adjacency MatrixThe adjacency matrix refers to the representation of a graph by a matrix. It uses a matrix to describe the relationship between the vertices of the graph (and the right of the arcs or edges). Two arrays are usually used to implement the graph’s adjacency matrix: a one-dimensional array for storing vertex information and a two-dimensional array for saving edge information. The disadvantage of adjacency matrix is more space-consuming. Assuming that the number of vertices in the graph is n, the adjacency matrix is defined as: A[i][j] = 0 is means that there is no edge. A[i][j] = 1 is means that there are edge. The following undirected graph: The adjacency matrix of this undirected graph is as follows: N/A A B C D E F G A 0 0 1 1 0 1 0 B 0 0 1 0 0 0 0 C 1 1 0 1 0 0 0 D 1 0 1 0 0 0 0 E 0 0 0 0 0 0 1 F 1 0 0 0 0 0 1 G 0 0 0 0 1 1 0 The following directed graph: The adjacency matrix of this directed graph is as follows: N/A A B C D E F G A 0 0 1 0 0 0 0 B 0 0 1 0 1 1 0 C 0 0 0 0 1 0 0 D 0 0 1 0 0 0 0 E 0 1 0 1 0 0 1 F 0 0 0 0 0 0 1 G 0 0 0 0 0 0 0 Adjacency ListThe adjacency list is a chain storage representation method of a graph. It is an improved “adjacency matrix”, its disadvantage is that it is inconvenient to judge whether there is an edge between the two vertices, but it is less space relative to the adjacency matrix. The following undirected graph: The adjacency list of this undirected graph is as follows: The following directed graph: The adjacency list of this directed graph is as follows:","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Graph","slug":"Data-Structure/Graph","permalink":"http://HuCoco.com/categories/Data-Structure/Graph/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Graph","slug":"Graph","permalink":"http://HuCoco.com/tags/Graph/"}]},{"title":"RedBlackTree_III","slug":"RedBlackTree-III","date":"2018-03-02T15:38:19.000Z","updated":"2018-03-05T14:00:03.085Z","comments":true,"path":"2018/03/02/RedBlackTree-III/","link":"","permalink":"http://HuCoco.com/2018/03/02/RedBlackTree-III/","excerpt":"RedBlackTree III Chinese version address The Last Section Basic operation of red black treesDeleteThe method of deleting a node is the same as that of deleting a node in a binary search tree. Binary search tree Delete pseudo code123456789101112131415161718TREE-DELETE(T, z) if left[z] = NIL or right[z] = NIL then y ← z else y ← TREE-SUCCESSOR(z) if left[y] ≠ NIL then x ← left[y] else x ← right[y] if x ≠ NIL then p[x] ← p[y] if p[y] = NIL then root[T] ← x else if y = left[p[y]] then left[p[y]] ← x else right[p[y]] ← x if y ≠ z then key[z] ← key[y] copy y's satellite data into z return y","text":"RedBlackTree III Chinese version address The Last Section Basic operation of red black treesDeleteThe method of deleting a node is the same as that of deleting a node in a binary search tree. Binary search tree Delete pseudo code123456789101112131415161718TREE-DELETE(T, z) if left[z] = NIL or right[z] = NIL then y ← z else y ← TREE-SUCCESSOR(z) if left[y] ≠ NIL then x ← left[y] else x ← right[y] if x ≠ NIL then p[x] ← p[y] if p[y] = NIL then root[T] ← x else if y = left[p[y]] then left[p[y]] ← x else right[p[y]] ← x if y ≠ z then key[z] ← key[y] copy y's satellite data into z return y According to the node to be deleted according to the number of sons can be divided into three cases No child nodes. just set the child node of the parent node to NULL and delete the child node. Only one child node, the parent node’s child node pointer points to the grandson node, delete the son node. Two child nodes, After deleting the node, but also to ensure that the search binary tree structure. In this case, the largest element in the left child node or the smallest element in the right child node can be placed in the position of the node to be deleted to ensure the structure is unchanged. Binary search tree Delete pseudo code12345678910111213141516171819RB-DELETE(T, z)if left[z] = nil[T] or right[z] = nil[T] then y ← z else y ← TREE-SUCCESSOR(z) if left[y] ≠ nil[T] then x ← left[y] else x ← right[y] p[x] ← p[y] if p[y] = nil[T] then root[T] ← x else if y = left[p[y]] then left[p[y]] ← x else right[p[y]] ← x if y ≠ z then key[z] ← key[y] copy y's satellite data into z if color[y] = BLACK then RB-DELETE-FIXUP(T, x) return y After you delete a node, it may violate the feature of the red black tree. If you delete the red node, then the feature of red black tree remains. At this time do not do the correction operation. If the deleted node is a black node, the feature of the red black tree may be changed, and we want to make corrections to it So what are the feature of trees that will change? If the delete node is not the only node in the tree, then the number of black nodes to each leaf node of the delete node will change, and the property 5 is destroyed. If the deleted node’s only non-empty child node is red, and the deleted node’s parent node is also red, then the feature of 4 is destroyed. If the deleted node is the root node and its only non-empty child node is red, the new root node will be red after deletion, violating property 2. The above repair looks a bit complicated, here we use an analytical skills: begin to adjust the node from which the node was removed later, And think it has an extra black color. What is the meaning of an extra black here? We do not add the nodes of the red and black trees to another color of red and black. Here is just an assumption, and we think we are currently pointing to it, so there is an extra black. It can be thought that its black color is inherited from its parent after it was deleted. It can now hold two colors. If it was originally red, then it is red + black, and if it is black then its current color It is black + black. With this extra black, the feature of red-black tree 5 will remain unchanged. Now it is enough to resume other things as far as possible, and try to move all the possibilities to the root as far as possible. If it is the case, the recovery is relatively simple: The current node is red + black.The current node is set to black, the end of the red-black tree at this time the nature of all recovery. The current node is black + black and is the root node.do nothing, the end. But the following situation, it will be more complicated Case Description 1 The current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black). 2 The current node is black and black and the brother is black and both siblings have black children. 3 The current node color is black + black, brother node is black, brother’s left child is red, the right child is black. 4 The current node color is black-black, its sibling node is black, but the sibling node’s right child is red, the sibling node’s left child’s color is arbitrary Case DescriptionCase 1DescriptionThe current node is black + black and the sibling node is red (in this case, the children of the parent node and sibling nodes are divided into black). Method Set the parent node to red. Set the brother nodes to black. Do left rotation on parent node. reset the brother nodes. pseudo code12345678while x ≠ root[T] and color[x] = BLACK do if x = left[p[x]] then w ← right[p[x]] if color[w] = RED then color[w] ← BLACK ▹ Case 1 color[p[x]] ← RED ▹ Case 1 LEFT-ROTATE(T, p[x]) ▹ Case 1 w ← right[p[x]] ▹ Case 1 Case 2DescriptionThe current node is black and black and the brother is black and both siblings have black children. Method Set brother node to red. Set current node to parent node. pseudo code123if color[left[w]] = BLACK and color[right[w]] = BLACK then color[w] ← RED ▹ Case 2 x ← p[x] ▹ Case 2 Case 3DescriptionThe current node color is black + black, brother node is black, brother’s left child is red, the right child is black. Method Set brother node’s left child node to black. Set brother node to red. Do right rotation on brother node. reset brother node. pseudo code12345else if color[right[w]] = BLACK then color[left[w]] ← BLACK ▹ Case 3 color[w] ← RED ▹ Case 3 RIGHT-ROTATE(T, w) ▹ Case 3 w ← right[p[x]] ▹ Case 3 Case 4DescriptionThe current node color is black-black, its sibling node is black, but the sibling node’s right child is red, the sibling node’s left child’s color is arbitrary Method Set the brother node to the color of parent node. Set parent node to black. Set the brother node’s right left node to black. Do right rotation on parent node. set current node to root node. pseudo code12345color[w] ← color[p[x]] ▹ Case 4 color[p[x]] ← BLACK ▹ Case 4 color[right[w]] ← BLACK ▹ Case 4 LEFT-ROTATE(T, p[x]) ▹ Case 4 x ← root[T] ▹ Case 4","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Tree","slug":"Data-Structure/Tree","permalink":"http://HuCoco.com/categories/Data-Structure/Tree/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Tree","slug":"Tree","permalink":"http://HuCoco.com/tags/Tree/"}]},{"title":"RedBlackTree_II","slug":"RedBlackTree-II","date":"2018-03-02T15:38:16.000Z","updated":"2018-03-03T14:24:17.860Z","comments":true,"path":"2018/03/02/RedBlackTree-II/","link":"","permalink":"http://HuCoco.com/2018/03/02/RedBlackTree-II/","excerpt":"RedBlackTree II Chinese version address The Last Section Basic operation of red black treesInsertInsert a node into the red-black tree, which steps need to be performed? think of the red-black tree as a binary search tree and insert the node. Set this node to red. Modify the tree by rotating and recoloring it to make it a red-black tree again.","text":"RedBlackTree II Chinese version address The Last Section Basic operation of red black treesInsertInsert a node into the red-black tree, which steps need to be performed? think of the red-black tree as a binary search tree and insert the node. Set this node to red. Modify the tree by rotating and recoloring it to make it a red-black tree again. Step DescriptionStep 1The red-black tree is a binary search tree, which is still a binary search tree after the node is inserted. This means that the key of the tree is still ordered. In addition, whether it is left-rotation or right-rotation, the tree is a binary search tree before rotation, and after rotation it must be a binary search tree. Step 2Why should set the node’s color to red? Because it is not violate 5 features. violate more less feature mean less things we need to deal with. Step 3So how many features it violate? As for feature 1, obviously not violate. As for feature 2, insert operation does not change the root node, so the color of root node is still black. As for feature 3, leaf node is null node, inserting non-null node does not affect feature. As for feature 4, Is possible to violate. Case DescriptionCase 1DescriptionThe current node’s parent node is red, and the current node’s grandparent node’s other child node (uncle node) is also red 1234while color[p[z]] = RED do if p[z] = left[p[p[z]]] then y ← right[p[p[z]]] if color[y] = RED Grandfather node must exist at this time, otherwise it is not black red tree before inserting. At this point is divided into the parent node is the grandfather’s left child or right child, according to symmetry, we just untie a direction on it. Here only consider the parent node left grandfather’s situation, as shown below. MethodStrategy is as follows: Sets the parent node to black. Sets the node of the uncle to black. set grandfather node to red. The grandfather node is set as the current node (red node). As shown in the following pseudo code: 1234then color[p[z]] ← BLACK ▹ Case 1 color[y] ← BLACK ▹ Case 1 color[p[p[z]]] ← RED ▹ Case 1 z ← p[p[z]] ▹ Case 1 Then, insert repair case 1 translates into insert repair case 2. Case 2DescriptionThe current node’s parent node is red, the uncle node is black, and the current node is the right child of its parent node MethodStrategy is as follows: Set the parent as the new current node. Do left rotation on current node. As shown in the following pseudo code: 123else if z = right[p[z]] then z ← p[z] ▹ Case 2 LEFT-ROTATE(T, z) ▹ Case 2 Insertion Repair Case 2 translates into insert repair case 3. Case 3DescriptionThe current node’s parent node is red, the uncle node is black, and the current node is the left child of its parent node MethodStrategy is as follows: Sets the parent node to black. set grandfather node to red. Do right rotation on grandfather node. As shown in the following pseudo code: 123color[p[z]] ← BLACK ▹ Case 3 color[p[p[z]]] ← RED ▹ Case 3 RIGHT-ROTATE(T, p[p[z]]) ▹ Case 3 Code ReferencePseudo code:Insert Pseudo Code123456789101112131415161718RB-INSERT(T, z) y ← nil[T] x ← root[T] while x ≠ nil[T] do y ← x if key[z] &lt; key[x] then x ← left[x] else x ← right[x] p[z] ← y if y = nil[T] then root[T] ← z else if key[z] &lt; key[y] then left[y] ← z else right[y] ← z left[z] ← nil[T] right[z] ← nil[T] color[z] ← RED RB-INSERT-FIXUP(T, z) Insert-Fixed Pseudo Code1234567891011121314151617RB-INSERT-FIXUP(T, z)while color[p[z]] = RED do if p[z] = left[p[p[z]]] then y ← right[p[p[z]]] if color[y] = RED then color[p[z]] ← BLACK ▹ Case 1 color[y] ← BLACK ▹ Case 1 color[p[p[z]]] ← RED ▹ Case 1 z ← p[p[z]] ▹ Case 1 else if z = right[p[z]] then z ← p[z] ▹ Case 2 LEFT-ROTATE(T, z) ▹ Case 2 color[p[z]] ← BLACK ▹ Case 3 color[p[p[z]]] ← RED ▹ Case 3 RIGHT-ROTATE(T, p[p[z]]) ▹ Case 3 else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) color[root[T]] ← BLACK C++ ImplementationInsert C++ Code1234567891011121314151617181920212223242526272829303132333435363738394041template &lt;class T&gt;bool RedBlackTree&lt;T&gt;::insert(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123; RedBlackNode&lt;T&gt;* y = nullptr; RedBlackNode&lt;T&gt;* x = root; while (x != nullptr) &#123; if(x-&gt;key == node-&gt;key)&#123; return false; &#125; y = x; if(node-&gt;key &lt; x-&gt;key) &#123; x = x-&gt;pLeft; &#125; else &#123; x = x-&gt;pRight; &#125; &#125; node-&gt;pParent = y; if(y != nullptr) &#123; if(node-&gt;key &lt; y-&gt;key) &#123; y-&gt;pLeft = node; &#125; else &#123; y-&gt;pRight = node; &#125; &#125; else &#123; root = node; &#125; set_red(node); insertFixUp(root, node); return true;&#125; Insert-Fixed C++ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455template &lt;class T&gt;void RedBlackTree&lt;T&gt;::insertFixUp(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123; RedBlackNode&lt;T&gt;* parent; RedBlackNode&lt;T&gt;* gparnet; while ((parent = get_parent(node))&amp;&amp;(is_red(parent))) &#123; gparnet = get_parent(parent); if(parent == gparnet-&gt;pLeft) &#123; RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pRight; if(uncle &amp;&amp; is_red(uncle)) &#123; set_black(uncle); set_black(parent); set_red(gparnet); node = gparnet; continue; &#125; if(parent-&gt;pRight == node) &#123; RedBlackNode&lt;T&gt;* tmp; leftRotate(root, parent); tmp = parent; parent = node; node = tmp; &#125; set_black(parent); set_red(gparnet); rightRotate(root, gparnet); &#125; else &#123; RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pLeft; if(uncle &amp;&amp; is_red(uncle)) &#123; set_black(uncle); set_black(parent); set_red(gparnet); node = gparnet; continue; &#125; if(parent-&gt;pLeft == node) &#123; RedBlackNode&lt;T&gt;* tmp; rightRotate(root, parent); tmp = parent; parent = node; node = tmp; &#125; set_black(parent); set_red(gparnet); leftRotate(root, gparnet); &#125; &#125; set_black(root);&#125; The Next Section","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Tree","slug":"Data-Structure/Tree","permalink":"http://HuCoco.com/categories/Data-Structure/Tree/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Tree","slug":"Tree","permalink":"http://HuCoco.com/tags/Tree/"}]},{"title":"RedBlackTree I","slug":"RedBlackTree-I","date":"2018-03-02T15:38:12.000Z","updated":"2018-03-03T14:23:47.253Z","comments":true,"path":"2018/03/02/RedBlackTree-I/","link":"","permalink":"http://HuCoco.com/2018/03/02/RedBlackTree-I/","excerpt":"RedBlackTree I Chinese version address Binary Tree ReviewThere are several features of binary tree: if the left subtree of any nodes is not null, the value of all nodes on the left subtree is less than the value of its root node. if the right subtree of any nodes is not null, the value of all nodes on the right subtree is greater than the value of its root node. the left and right subtrees of any node are also binary tree. No nodes with equal values Red Black Tree OverviewRed Black Tree is a special binary tree. each node of a red black tree has a bit to represenet the color, which can be red or black.","text":"RedBlackTree I Chinese version address Binary Tree ReviewThere are several features of binary tree: if the left subtree of any nodes is not null, the value of all nodes on the left subtree is less than the value of its root node. if the right subtree of any nodes is not null, the value of all nodes on the right subtree is greater than the value of its root node. the left and right subtrees of any node are also binary tree. No nodes with equal values Red Black Tree OverviewRed Black Tree is a special binary tree. each node of a red black tree has a bit to represenet the color, which can be red or black. Red Black Tree Features the color of each node is red or black. the color of root node is black. the color of each leaf node is black. if a node is red, the subnode of it must be black. The same number of black nodes is included on all paths from a node to the node’s descendant node. Notes: leaf node is means which node is null. Feature 5 to ensure that no path is twice as long as the other path. Thus, the red black tree is a relatively balanced binary tree. Application of red black treesThe application of the red-black tree is particularly extensive, mainly because it uses it to store ordered data. Its time complexity is O (lgn), which is very efficient. But its implementation is complicated, and insert, delete operation will pay more cost. Set and Map in STL TreeSet and TreeMap in Java Virtual memory management in Linux Basic operation of red black treesLeft Rotation12345 z x / / \\ --(左旋)--&gt; xy z / y Make left rotation on x node, and it will be a left node. Pseudo code123456789101112LEFT-ROTATE(T, x) y ← right[x] right[x] ← left[y] p[left[y]] ← x p[y] ← p[x] if p[x] = nil[T] then root[T] ← y else if x = left[p[x]] then left[p[x]] ← y else right[p[x]] ← y left[y] ← x p[x] ← y C++ Code1234567891011121314151617181920212223242526template &lt;class T&gt;void RedBlackTree&lt;T&gt;::leftRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *x) &#123; RedBlackNode&lt;T&gt; *y = x-&gt;pRight; x-&gt;pRight = y-&gt;pLeft; if(y-&gt;pLeft != nullptr) &#123; y-&gt;pLeft-&gt;pParent = x; &#125; y-&gt;pParent = x-&gt;pParent; if(x-&gt;pParent == nullptr) &#123; root = y; &#125; else &#123; if(x-&gt;pParent-&gt;pLeft == x) &#123; x-&gt;pParent-&gt;pLeft = y; &#125; else &#123; x-&gt;pParent-&gt;pRight = y; &#125; &#125; y-&gt;pLeft = x; x-&gt;pParent = y; &#125; Right Rotation12345 y x \\ / \\ --(右旋)--&gt; xy z \\ z Make right rotation on x node, and it will be a right node. Pseudo code123456789101112RIGHT-ROTATE(T, y) x ← left[y] left[y] ← right[x] p[right[x]] ← y p[x] ← p[y] if p[y] = nil[T] then root[T] ← x else if y = right[p[y]] then right[p[y]] ← x else left[p[y]] ← x right[x] ← y p[y] ← x C++ Code123456789101112131415161718192021222324252627template &lt;class T&gt;void RedBlackTree&lt;T&gt;::rightRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *y) &#123; RedBlackNode&lt;T&gt; *x = y-&gt;pLeft; y-&gt;pLeft = x-&gt;pRight; if(x-&gt;pRight != nullptr) &#123; x-&gt;pRight-&gt;pParent = y; &#125; x-&gt;pParent = y-&gt;pParent; if(y-&gt;pParent == nullptr) &#123; root = x; &#125; else &#123; if(y-&gt;pParent-&gt;pRight == y) &#123; y-&gt;pParent-&gt;pRight = x; &#125; else &#123; y-&gt;pParent-&gt;pLeft = x; &#125; &#125; x-&gt;pRight = y; y-&gt;pParent = x; &#125; The Next Section","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/categories/Data-Structure/"},{"name":"Tree","slug":"Data-Structure/Tree","permalink":"http://HuCoco.com/categories/Data-Structure/Tree/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://HuCoco.com/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://HuCoco.com/tags/Data-Structure/"},{"name":"Tree","slug":"Tree","permalink":"http://HuCoco.com/tags/Tree/"}]}]}