{"meta":{"title":"HuCoco's Blog","subtitle":"HuCoco's Blog","description":null,"author":"HuCoco","url":"http://hucoco.com"},"pages":[{"title":"","date":"2016-08-23T04:35:46.000Z","updated":"2016-08-23T04:35:45.000Z","comments":true,"path":"googleac21bd289bda003b.html","permalink":"http://hucoco.com/googleac21bd289bda003b.html","excerpt":"","text":"google-site-verification: googleac21bd289bda003b.html"},{"title":"这就是我","date":"2016-06-09T05:52:24.000Z","updated":"2016-06-09T13:27:03.000Z","comments":true,"path":"about/index.html","permalink":"http://hucoco.com/about/index.html","excerpt":"","text":"现在还是学生一枚，主要对C++比较熟悉，其他语言也都有了解，也就凑合这用吧，反正我没点全栈天赋，重点在图形学（学习中）和智能识别（准备折腾折腾） 业余生活也就崇拜下暴雪爸爸，打球，看书，看电影这些事。 还有就是不断的更新博客。 E-mail:hook@hucoco.com Github:@HuCoco 项目经验 学习阶段，使用Cocos2d-x各种模仿移动端小游戏，比如《Flappy brid》、《别踩白块》、《2048》等等 实验阶段，自己捣腾制作休闲游戏《PewPewPew》。 闲暇时间制作休闲游戏《Pixel Adventures》。 最后捣腾点稍微完整的游戏——《元素传奇》，麻雀虽小但是五脏俱全嘛。"},{"title":"img","date":"2016-06-09T12:50:37.000Z","updated":"2016-06-09T12:50:37.000Z","comments":true,"path":"img/index.html","permalink":"http://hucoco.com/img/index.html","excerpt":"","text":""}],"posts":[{"title":"CPU_光线追踪_Part1","slug":"CPU-光线追踪-Part1","date":"2016-08-16T09:13:12.000Z","updated":"2016-08-18T10:35:33.000Z","comments":true,"path":"2016/08/16/CPU-光线追踪-Part1/","link":"","permalink":"http://hucoco.com/2016/08/16/CPU-光线追踪-Part1/","excerpt":"简述这一部分的内容会详细记录如何实现光线追踪算法，该算法在CPU中完成计算，且是非实时的，最后的结果为渲染好的一张图片。 这一部分完成会，还会有一个使用OpenGL实现实时光线追踪。 首先我们需要准备建立这个项目，你需要如下东西： 一个熟悉的C++的IDE，我用的Xcode FreeImage库（当然也可以使用其他图像库，例如OpenCV等） 相关数学资料（后面会详细介绍，例如空间解析几何，线性代数等） 相关IDE就不在这里多说废话了，这里重点说下FreeImage在MacOS平台下的配置问题。 首先我们需要去下载一个FreeImage库，我使用的版本是3.1.5.4这个版本，其他版本配置问题可能会有差异，下面为每一步的详细步骤。","text":"简述这一部分的内容会详细记录如何实现光线追踪算法，该算法在CPU中完成计算，且是非实时的，最后的结果为渲染好的一张图片。 这一部分完成会，还会有一个使用OpenGL实现实时光线追踪。 首先我们需要准备建立这个项目，你需要如下东西： 一个熟悉的C++的IDE，我用的Xcode FreeImage库（当然也可以使用其他图像库，例如OpenCV等） 相关数学资料（后面会详细介绍，例如空间解析几何，线性代数等） 相关IDE就不在这里多说废话了，这里重点说下FreeImage在MacOS平台下的配置问题。 首先我们需要去下载一个FreeImage库，我使用的版本是3.1.5.4这个版本，其他版本配置问题可能会有差异，下面为每一步的详细步骤。 Step 1 – 修改 Makefile 文件Step 1.1找到Makefile.osx文件，这个是MacOS平台下的Makefile配置信息，但是官方提供的配置信息已经不能完成MacOS下的编译工作，所以需要全部替换为一下配置信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# -*- Makefile -*-# Mac OSX makefile for FreeImageinclude Makefile.srcs# General configuration variables:CC_I386 = ClangCC_X86_64 = ClangCPP_I386 = Clang++CPP_X86_64 = Clang++COMPILERFLAGS = -Os -fexceptions -fvisibility=hidden -DNO_LCMS -D__ANSI__ -mmacosx-version-min=10.7 -DDISABLE_PERF_MEASUREMENT #-g -DDEBUGCOMPILERFLAGS_I386 = -arch i386COMPILERFLAGS_X86_64 = -arch x86_64COMPILERPPFLAGS = -Wno-ctor-dtor-privacy -D__ANSI__ -stdlib=libc++INCLUDE +=INCLUDE_I386 = -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkINCLUDE_X86_64 = -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkCFLAGS_I386 = $(COMPILERFLAGS) $(COMPILERFLAGS_I386) $(INCLUDE) $(INCLUDE_I386)CFLAGS_X86_64 = $(COMPILERFLAGS) $(COMPILERFLAGS_X86_64) $(INCLUDE) $(INCLUDE_X86_64)CPPFLAGS_I386 = $(COMPILERPPFLAGS) $(CFLAGS_I386)CPPFLAGS_X86_64 = $(COMPILERPPFLAGS) $(CFLAGS_X86_64)LIBRARIES_I386 = -Wl,-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkLIBRARIES_X86_64 = -Wl,-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkLIBTOOL = libtoolLIPO = lipoTARGET = freeimageSTATICLIB = lib$(TARGET).aSHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).dylibLIBNAME = lib$(TARGET).$(VER_MAJOR).dylibHEADER = Source/FreeImage.h.SUFFIXES: .o-i386 .o-x86_64MODULES_I386 = $(SRCS:.c=.o-i386)MODULES_X86_64 = $(SRCS:.c=.o-x86_64)MODULES_I386 := $(MODULES_I386:.cpp=.o-i386)MODULES_X86_64 := $(MODULES_X86_64:.cpp=.o-x86_64)PREFIX = /usr/localINSTALLDIR = $(PREFIX)/libINCDIR = $(PREFIX)/includedefault: allall: distdist: FreeImage cp *.a Dist cp Source/FreeImage.h Dist# cp *.dylib DistFreeImage: $(STATICLIB)#$(STATICLIB) $(SHAREDLIB)$(STATICLIB): $(STATICLIB)-x86_64 $(LIPO) -create $(STATICLIB)-x86_64 -output $(STATICLIB)#$(STATICLIB): $(STATICLIB)-i386 $(STATICLIB)-x86_64# $(LIPO) -create $(STATICLIB)-i386 $(STATICLIB)-x86_64 -output $(STATICLIB)$(STATICLIB)-i386: $(MODULES_I386) $(LIBTOOL) -arch_only i386 -o $@ $(MODULES_I386)$(STATICLIB)-x86_64: $(MODULES_X86_64) $(LIBTOOL) -arch_only x86_64 -o $@ $(MODULES_X86_64)$(SHAREDLIB): $(SHAREDLIB)-i386 $(SHAREDLIB)-x86_64 $(LIPO) -create $(SHAREDLIB)-i386 $(SHAREDLIB)-x86_64 -output $(SHAREDLIB)$(SHAREDLIB)-i386: $(MODULES_I386) $(CPP_I386) -arch i386 -dynamiclib $(LIBRARIES_I386) -o $@ $(MODULES_I386)$(SHAREDLIB)-x86_64: $(MODULES_X86_64) $(CPP_X86_64) -arch x86_64 -dynamiclib $(LIBRARIES_X86_64) -o $@ $(MODULES_X86_64).c.o-i386: $(CC_I386) $(CFLAGS_I386) -c $&lt; -o $@.c.o-x86_64: $(CC_X86_64) $(CFLAGS_X86_64) -c $&lt; -o $@.cpp.o-i386: $(CPP_I386) $(CPPFLAGS_I386) -c $&lt; -o $@.cpp.o-x86_64: $(CPP_X86_64) $(CPPFLAGS_X86_64) -c $&lt; -o $@install: install -d -m 755 -o root -g wheel $(INCDIR) $(INSTALLDIR) install -m 644 -o root -g wheel $(HEADER) $(INCDIR) install -m 644 -o root -g wheel $(SHAREDLIB) $(STATICLIB) $(INSTALLDIR) ranlib -sf $(INSTALLDIR)/$(STATICLIB) ln -sf $(SHAREDLIB) $(INSTALLDIR)/$(LIBNAME)clean: rm -f core Dist/*.* u2dtmp* $(MODULES_I386) $(MODULES_X86_64) $(STATICLIB) $(STATICLIB)-i386 $(STATICLIB)-x86_64 $(SHAREDLIB) $(SHAREDLIB)-i386 $(SHAREDLIB)-x86_64 Step 1.2我们需要根据自己的系统信息来修改一下配置信息，以便和我们的MaxOS SDK版本对应，为gcc/g++编译做好准备工作。 找到以下代码： 12345678INCLUDE_I386 = -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkINCLUDE_X86_64 = -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkCFLAGS_I386 = $(COMPILERFLAGS) $(COMPILERFLAGS_I386) $(INCLUDE) $(INCLUDE_I386)CFLAGS_X86_64 = $(COMPILERFLAGS) $(COMPILERFLAGS_X86_64) $(INCLUDE) $(INCLUDE_X86_64)CPPFLAGS_I386 = $(COMPILERPPFLAGS) $(CFLAGS_I386)CPPFLAGS_X86_64 = $(COMPILERPPFLAGS) $(CFLAGS_X86_64)LIBRARIES_I386 = -Wl,-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkLIBRARIES_X86_64 = -Wl,-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk 关注MacOSX10.11.sdk这个地方，这个是当前系统版本对应的SDK，根据自己的版本号来设置。下面为两种看自己系统版本号的方法，第二种会更加准确。 你可以在关于本机中看到你的系统版本号 在Applications找到Xcode，并右键点击显示包内容，按以下顺序进入到SDKs文件夹中：Contents--Developer--Platforms--MacOSX.platform--Developer--SDKs，这个文件夹中的SDK都可以使用，一般情况下只会有一种SDK，也就是当前版本的SDK，使用那一个就对了。 Step 2 – 修改 FreeImage 中的错误顺着以下路径找到ImfAutoArray.h文件： Source--OpenEXR--IlmImf 之后再这个文件的相应位置添加如下一句话： 1#include&lt;cstring&gt; 或者其他和这个string库匹配的头文件也可以。 这里可能是FreeImage制作者的一点小马虎吧。 Step 3 – 开始编译打开CMD，跳转到对应的FreeImage文件下，然后输入make，接下来就是等待成功吧。 如果有额外问题，可以联系我，我们一起解决它。 完成编译后，你会看的到该目录下Dist文件下有一个FreeImage.a以及FreeImage.h，你可以找一个固定的地方存放他们，也可以不动他们。 Step 4 – 配置项目文件这里我们需要一个使用Xcode创建一个Command Line Tool项目，如果使用的Windows平台，可以使用Win32控制台程序项目，这里我只介绍MacOS下Xcode的配置。 选中TARGETS中的对应项目，点击到Build Phases中，在Link Binary With Libraryes中，将刚刚的FreeImage.a加入进去。 再点击到Build Setting，找到Search Paths部分，在Library Search和User Header Search Path中加入FreeImage.a对应的目录 修改Always Search User Path改为Yes Step 5 – 配置完成下一片，会实现一些基础数据类，顺带也可以熟悉下C++。 如果有错误，欢迎指正。","categories":[{"name":"图形学","slug":"图形学","permalink":"http://hucoco.com/categories/图形学/"},{"name":"光线追踪","slug":"图形学/光线追踪","permalink":"http://hucoco.com/categories/图形学/光线追踪/"},{"name":"CPU计算","slug":"图形学/光线追踪/CPU计算","permalink":"http://hucoco.com/categories/图形学/光线追踪/CPU计算/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"http://hucoco.com/tags/图形学/"},{"name":"FreeImage","slug":"FreeImage","permalink":"http://hucoco.com/tags/FreeImage/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://hucoco.com/tags/光线追踪/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://hucoco.com/tags/Ray-Tracing/"}]},{"title":"深入探讨const关键字","slug":"深入探讨const关键字","date":"2016-06-09T10:33:58.000Z","updated":"2016-06-09T10:37:11.000Z","comments":true,"path":"2016/06/09/深入探讨const关键字/","link":"","permalink":"http://hucoco.com/2016/06/09/深入探讨const关键字/","excerpt":"这一次我准备用一个实际的例子来更加深入的探讨const关键字，可能这个例子不是特别的符合要求。这个例子的需求是这样的：我们需要一个画折线的对象，这个对象可以添加新的点，也可以删除的点，为了方便实践，我们规定这个折线最多由20个点组成，并且可以输出当前点的个数和所有点的信息。首先我们来分析一下需求： 创建这样的一个简单对象，我们需要一个Point类和Line类，而且他们的关系属于has-a，所以应该用组合的方式实现。 Point类中需要存储点的坐标信息，并且可以修改和获取这些信息。 Line类中需要存储点的信息，并且可以修改和获取这些信息，以及获取总共的点的数量，删除的点的功能。","text":"这一次我准备用一个实际的例子来更加深入的探讨const关键字，可能这个例子不是特别的符合要求。这个例子的需求是这样的：我们需要一个画折线的对象，这个对象可以添加新的点，也可以删除的点，为了方便实践，我们规定这个折线最多由20个点组成，并且可以输出当前点的个数和所有点的信息。首先我们来分析一下需求： 创建这样的一个简单对象，我们需要一个Point类和Line类，而且他们的关系属于has-a，所以应该用组合的方式实现。 Point类中需要存储点的坐标信息，并且可以修改和获取这些信息。 Line类中需要存储点的信息，并且可以修改和获取这些信息，以及获取总共的点的数量，删除的点的功能。 首先看看Point.h123456789101112131415class Point&#123;private: int x; int y; bool isInit;public: Point(); Point(const int&amp; _x,const int&amp; _y); void updateXY(const int&amp; _x,const int&amp; _y); int getX() const &#123;return x;&#125; int getY() const &#123;return y;&#125; bool getIsInit() const &#123;return isInit;&#125; void display() const;&#125;; x,y表示点的坐标，isInit表示这个点是否被初始化。 有参构造函数中和updateXY方法中，参数我们使用的const reference to int的类型，这样做的原因是因为我们只需要传递这个值进入这个方法。 而在get以及display方法中，我们只需要传递某一个值出去，并不需要函数去修改某些变量，所以我们将方法标记为const。 接下来我们在看看Point.cpp1234567891011121314151617181920Point::Point():x(0),y(0),isInit(false)&#123; &#125;Point::Point(const int&amp; _x,const int&amp; _y):x(_x),y(_y),isInit(true)&#123; &#125;void Point::updateXY(const int &amp;_x, const int &amp;_y)&#123; x = _x; y = _y;&#125;void Point::display() const&#123; printf(\"(%d,%d)\\n\",x,y);&#125; 实现很简单，但是这里我需要谈谈另外一个话题，关于初始化的问题。我相信很多初学者都是这样实现第一个无参构造函数的：123456Point::Point()&#123; x = 0; y = 0; isInit = false;&#125; 这样的做法叫做赋值，而非初始化，C++有一条这样的规定，在成员变量的初始化动作发生在进入构造函数本体之前。换句话说，你应该使用参数列表去初始化所有的成员变量，就像示例代码中所实现的一样。这样做符合C++规定并在效率也会更高。 接下来回归正题，我们来细谈Line类的实现，我们先谈谈成员变量：1234567class Line&#123;private: Point pointArray[20]; int count; bool countIsValid;&#125; 我们需要一个长度为20的Point的数组，这个没什么好多说的。 count变量用来表示当前Line中所存储的点的数量，countIsValid用来表示点的数量是否发生的变化 接下来我们来看看怎么实现所有需要的函数，首先是构造函数：123Line::Line():count(0),countIsValid(true)&#123;&#125; 构造函数的实现方法我上面说过了，还是请记住构造函数，并不是赋值函数。接下来是添加点的函数实现：123456789101112void Line::addPoint(const Point &amp;_new)&#123; for(int i = 0 ; i &lt; 20 ; i++) &#123; if(!pointArray[i].getIsInit()) &#123; pointArray[i] = _new; break; &#125; &#125; countIsValid = false;&#125; 参数我们只是需要值就行，而不是需要对象，所以我们使用const reference类型进行传递就行了，函数中我们遍历到我们第一个没有使用的空间时，便使用这一空间存储当前传入的数据。 这段实现很不合实际，但是我只想想为后面最关键的部分做铺垫而已，大家就不要吐槽了。 123456789101112131415void Line::deletePointByIndex(const int &amp;_index)&#123; for(int i = _index;i&lt;=20;i++) &#123; if(pointArray[i+1].getIsInit()) &#123; pointArray[i] = pointArray[i+1]; pointArray[i+1] = Point(); &#125; else &#123; break; &#125; &#125;&#125; 根据下标删除一个点，然后将后面的点前向靠拢的一个操作。没有什么特别的地方。接下来就这一次的重点，重载[]：123456789101112const Point&amp; Line::operator[] (const int&amp; _index) const&#123; if(_index &gt;= 20) &#123; throw \"Error\"; &#125; if(!pointArray[_index].getIsInit()) &#123; throw \"Error\"; &#125; return pointArray[_index];&#125; 第一个if语句用来表示下标超出的范围，然后抛出一个错误，第二个下标用来检测当前点是不是有有效数据，如果没有就会抛出一个错误，错误处理实现的很简单，因为这不是重点。这里我们返回的是一个const Point&amp;类型的值并且函数也为const类型，因为我们不希望函数修改任何值，只是用来返回一个值。然后我们发现返回的这个值并不能被操作，这个不是我们想要的，于是我们需要再次重载一个返回Point&amp;类型的函数，但是如果我们的类特别复杂，前面的检查方法十分的复杂，我们再这样写一遍就特别的麻烦，对了我们有粘贴复制，但整体代码会显得很长，或与又有人说，可以把检查方法写一成一个函数，但是并有这样的必要，因为这样的函数并非广泛使用，下面我就来说一种特别的方法：1234Point&amp; Line::operator[] (const int&amp; _index)&#123; return const_cast&lt;Point&amp;&gt;(static_cast&lt;const Line&amp;&gt;(*this)[_index]);&#125; 首先我们将本对象转化为一个const Line&amp;的对象，因为我们只想使用值并不想修改static_cast(this)帮助我们完成了这样的想法，然后我们使用了static_cast(this)[_index]返回的const Point&amp;类型的值，但是我们需要去掉const关键字，这里使用了const_cast()这个方法，它可以帮我们去掉const关键字。这样我们就可以做这样的事情了：123Line l1;l1.addPoint(Point(3,3));l1[0].display(); 接下来我们来说说怎么实现返回当前点的总和，上面那段烂代码也是为了这段代码出现的必要，因为它要告诉大家一个重要的关键字。12345678910111213141516int Line::getPointCount() const&#123; if(!countIsValid) &#123; count = 0; for(int i = 0 ; i &lt; 20 ; i++) &#123; if(pointArray[i].getIsInit()) &#123; count++; &#125; &#125; countIsValid = true; &#125; return count;&#125; 作为一个获取某个值的函数，它同样被设置成为了const类型，但是我们在这个函数中改变了count和countIsValid的量，为了完成这个方法，我们需要修改一个成员变量的类型：12mutable int count;mutable bool countIsValid; mutable这个关键字，允许这个变量在任何地方都可以被修改，即使它在const函数内。这样大家都懂了吧。 好了其他的函数都不重要了，代码怎么实现的也不重要，关键是他们使用的方法，如果你已经完全掌握了上面的方法，现在你可以自己写一个String类。const能帮助你完成安全性的工作。 下一次我们会分享一些构造/析构/赋值运算相关的内容。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://hucoco.com/categories/编程语言/"},{"name":"C++","slug":"编程语言/C","permalink":"http://hucoco.com/categories/编程语言/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"}]},{"title":"浅析const关键字","slug":"浅析const关键字","date":"2016-06-09T07:45:01.000Z","updated":"2016-06-09T09:01:41.000Z","comments":true,"path":"2016/06/09/浅析const关键字/","link":"","permalink":"http://hucoco.com/2016/06/09/浅析const关键字/","excerpt":"const关键字它允许你指定一个语义的约束，也就是不允许被改动的对象，而编译器会帮助你实施这样的约束，这有有助于在团队协作中不去违反这样的规则。const可以用到的地方很多，你可以在classes外部去修饰global或者namespace作用域中的常量，或者修饰文件、函数、区块作用域中被声明为static的对象，也可以用它修饰classes内部的成员变量，而面对指针，你可以可以指出是对于指针自身，还是指针所指物，或者两个都不是。12345char authorName[] = \"HookCoco\";char* name = authorName; //1const char* name = authorName; //2char* const name = authorName; //3const char* const name = authorName; //4 指针可修改，数据可修改 指针可修改，数据不可修改 指针不可修改，数据可修改 指针不可修改，数据不可修改","text":"const关键字它允许你指定一个语义的约束，也就是不允许被改动的对象，而编译器会帮助你实施这样的约束，这有有助于在团队协作中不去违反这样的规则。const可以用到的地方很多，你可以在classes外部去修饰global或者namespace作用域中的常量，或者修饰文件、函数、区块作用域中被声明为static的对象，也可以用它修饰classes内部的成员变量，而面对指针，你可以可以指出是对于指针自身，还是指针所指物，或者两个都不是。12345char authorName[] = \"HookCoco\";char* name = authorName; //1const char* name = authorName; //2char* const name = authorName; //3const char* const name = authorName; //4 指针可修改，数据可修改 指针可修改，数据不可修改 指针不可修改，数据可修改 指针不可修改，数据不可修改 简单来说如果const出现在星号的左边，表示被指物是常量，如果出现在右边，表示指针自身是常量，如果都出现，表示被指物和指针自身都是常量。而对于被指物是常量的写法有以下两种：12void f1(const char* name);void f2(char const * name); 这两种写法都是可行的，使用哪一种都可以，我习惯于用前者。 STL迭代器系以指针为根据塑模出来，所以迭代器的作用就像一个T指针，申明迭代器为const就想声明指针为const一样（T* const），它表示这个迭代器不能指向不同的东西，但是内容数据是可以修改的，如果你希望迭代器所指的东西不可被改动，你需要的是const_iterator:12345678std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; //1++iter; //2std::vector&lt;int&gt;::const_iterator cIter = vec.begin();*cIter = 10; //3++cIter; //4 上述代码不完全正确，你觉得哪些是对的，哪些是错的呢？ 这句是对的，因为iter的被指物是可以被修改的 这句不对，因为iter是const 这句不对，因为*cIter是const 这句是对的，可以改变cIter 好了热身已经结束了，const最有威力的作用是面对函数声明时的应用，在一个函数声明中，你可以在参数，函数自身，返回值使用const 让函数的返回值为一个常量值，往往可以降低因客户错误而造成的意外而又不至于放弃安全性和高效性，举个栗子！12class Rational &#123;...&#125;;const Rational operator* (const Rational&amp; lhs,const Rational&amp; rhs)； 很多人就要问了，为什么要返回一个const对象？原因很简单，避免某些人错误的使用这样的函数：12Rational a,b,c;(a * b) = c; 如果不返回const关键字，这样做就是可行的，编译器并不会阻止你敢这样的蠢事。1if( a * b = c) 如果你手误写出这样代码，编译器也是不会阻止你的。返回const常量可以避免没必要的赋值操作，进而可以避免造成更多的错误，何乐而不为呢？ const成员函数 将const实施与成员函数的目的，是为了确认该成员函数可以作用于const对象身上。这一类函数很重要，原因有二： 这样做使class接口比较容易被理解，因为知道哪些函数可以改动对象内容而哪些函数不行是很重要的一件事。 它们使“操作const”对象成为可能。 很多人是忽视这样一个事实：两个成员函数如果只是常量性不同，可以被重载。这是C++的一个很重要很重要很重的特性。考虑以下这个class，用于表现一个长文本：123456789class TextBlock&#123;public: ··· const char&amp; operator[](std::size_t position) const &#123; return text[position]; &#125; char&amp; operator[](std::size_t position) const &#123; return text[position]; &#125;private: std::string text;&#125;; TextBlock的operator[]s可被这样使用：1234TextBlock tb(\"Hello\");std::cout &lt;&lt; tb[0];const TextBlock ctb(\"World\");std::cout &lt;&lt; ctb[0]; 前者调用non-const函数，后者调用const函数。顺带提一下，真实的程序中const对象大多用于 passed by pointer-to-const 或者 passed reference-to-const，比如下面：12345void print(const TextBlock&amp; ctb)&#123; std::cout &lt;&lt; ctb[0] ···&#125; 回到刚刚的话题，只要重载operator[]并对不同的版本给予不同的返回值类型，就可以令const和non-const获得不同的处理：1234std::cout &lt;&lt; tb[0];tb[0] = 'X';std::cout &lt;&lt; ctb[0];ctb[0] = 'X'; 上面这段代码的最后一行很明显是错误的，因为ctb是const类型的对象，不允许修改数据。还有一点也需要注意，non-const operator[]方法的返回值为reference to char，而不是char，若果是后者的话，第二行的这样的语句也无法通过编译，那是因为如果函数的返回值是一个内置类型，那么改动函数返回值从来就不合法，即使是合法的，C++以by value返回对象这一个规则意味被改动的其实是tb.text[0]的副本，不是tb.text[0]本身，不搞清楚这点的话，很多初学者都会头疼，比如以前的我····2333333 这一次我们就讲到这里，下一次我们会更加深入的探讨const关键字，如果你有时间，你可以仔细的考虑下operator[]的两个方法，他们其实是有些问题的。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://hucoco.com/categories/编程语言/"},{"name":"C++","slug":"编程语言/C","permalink":"http://hucoco.com/categories/编程语言/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"}]},{"title":"慎用#define","slug":"慎用-define","date":"2016-06-08T10:33:38.000Z","updated":"2016-06-09T10:37:21.000Z","comments":true,"path":"2016/06/08/慎用-define/","link":"","permalink":"http://hucoco.com/2016/06/08/慎用-define/","excerpt":"在我们学习C的时候，会常常使用到 #define 关键字来定义一些我们需要的元素，比如：1#define MATH_PI 3.1415 记号MATH_PI可能从未被编译器看见，也可能在编译器开始处理源码之前它就被预编译处理器移走了。于是MATH_PI有可能没进入记号表内。之后当以使用它时但获得了一个错误信息，可能你没法办很快的找到是哪里出现的问题，因为这个错误信息可能会提到3.1415而不是MATH_PI，若果他是你的小伙伴写的那一部分，但你并不知道，这可能会折腾你很久，处理这样的问题就非常的浪费时间。解决的办法很简单，就是以一个常量来替换上述的宏：1const double MathPI = 3.1415; 这样MathPI可能会被编译器看到并记入记号表内，这样就绝不会出现刚刚的情况。 这里在说一些题外话：我们在以不同的方式定义元素的时候，应该按照定于方式的规范来命名，比如这里的宏，我们使用的全大写+下划线来表示，而常量我们使用另外一种命名方式来表示，以此我们就可以区分不同的方式定义的元素。","text":"在我们学习C的时候，会常常使用到 #define 关键字来定义一些我们需要的元素，比如：1#define MATH_PI 3.1415 记号MATH_PI可能从未被编译器看见，也可能在编译器开始处理源码之前它就被预编译处理器移走了。于是MATH_PI有可能没进入记号表内。之后当以使用它时但获得了一个错误信息，可能你没法办很快的找到是哪里出现的问题，因为这个错误信息可能会提到3.1415而不是MATH_PI，若果他是你的小伙伴写的那一部分，但你并不知道，这可能会折腾你很久，处理这样的问题就非常的浪费时间。解决的办法很简单，就是以一个常量来替换上述的宏：1const double MathPI = 3.1415; 这样MathPI可能会被编译器看到并记入记号表内，这样就绝不会出现刚刚的情况。 这里在说一些题外话：我们在以不同的方式定义元素的时候，应该按照定于方式的规范来命名，比如这里的宏，我们使用的全大写+下划线来表示，而常量我们使用另外一种命名方式来表示，以此我们就可以区分不同的方式定义的元素。 当我们使用const来代替#define时，有两种特殊的情况需要提一下。 定义常量指针由于常量定义通常放在头文件内，这样便于被不同的源码包含，因此有必要将指针声明为const，若要定义一个不变的指针，就必须const两次：1const char* const authorName = \"Hook\"; 为什么要这样做，在后面的文章中我会讲到。这里还会有更好的方法，我也更建议使用下面这样的方法。1const std::string authorName(\"Hook\"); Class专有常量为了将常量的作用于限制在类中，就必须把常量成为类的一个成员，为了保证只有一份这样的实体，就必须让它成为一个static成员123456class BaseSkill&#123; pirvate: static const double CoolDownTime = 2.5; ...&#125; 但是这种写法并不好，因为C++要求每一个元素都应该有它的定义式，而这种写法是声明式，所以建议使用一下的这种方式：*.h123456class BaseSkill&#123; pirvate: static const double CoolDownTime; ...&#125; *.cpp1const double BaseSkill::CoolDownTime = 2.5; 这样的功能#define就没有办法完成，因为#define对作用域是不敏感的，只要#define被定义，直到它被#undef，否则它将一直有用，所有任何有封装性的方法都不能使用它。倘若Class在编译期间就需要使用一个常量又该怎么办呢，比如我们需要声明一个数组，编译器必须要在编译期间就要直到这个数组的长度，但这时候编译器不允许static const常量来完整这个任务，这里就需要用到一种就做“the enum hack”的补偿做法。 因为一个枚举类型的数值可以当做ints来使用 1234567class DataBuffer&#123; private: enum &#123; BufferLength = 100 &#125;; int Buffer[BufferLength]; ...&#125; enum是很值得我们深度认识的元素，它比较像#define而不像const，这也是它优秀的地方。 接下来我们回到#define上来，通常我们习惯用#define去写一些宏函数，这东西很棒，但是需要格外的注意一些情况，比如下面这段代码：1#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) :(b)) 这个应该不难理解，选取a和b中较大的作为f(int)的参数传入。这里再说点其他的，书写宏函数时，实参一定要用括号包起来，不然你会经历绝望。当然就算我们括起来了，接下来也会经历绝望。123int a = 4,b = 2;CALL_WITH_MAX(++a,b);CALL_WITH_MAX(++a,b+8); 你能想象结果是什么么？12f(5);f(10); 我想大部分会认为是上面这个结果，但是你错了，我们完全还原一下函数：12f((++a)&gt;(b) ? (++a):(b))f((++a)&gt;(b+8) ? (++a):(b+8)) 现在应该清楚了吧！a的值取决于a被使用的次数，而且这样的错误使我们不能明确控制的，但是template inline函数会完全解决这个问题。12345template&lt;typename T&gt;inline void callWithMax(const T&amp; a,const T&amp; b)&#123; f(a &gt; b ? a :b)&#125; T可以代表你所需要的一切类型，只要他们能拿来比较，大的一个就会成为f的参数传入，而且你也可以把它作为某一个类的成员，宏是没有办法完成的。 好了，这一章就到这里，简单概括一下： 对于常量，使用const或者enum来代替#define 对于函数，使用template inline来代替#define 下一次我们会来细细的讨论下const这个关键字。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://hucoco.com/categories/编程语言/"},{"name":"C++","slug":"编程语言/C","permalink":"http://hucoco.com/categories/编程语言/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"}]},{"title":"MacOS 配置 Hexo","slug":"MacOS-配置-Hexo","date":"2016-06-05T16:09:16.000Z","updated":"2016-06-09T16:22:52.000Z","comments":true,"path":"2016/06/06/MacOS-配置-Hexo/","link":"","permalink":"http://hucoco.com/2016/06/06/MacOS-配置-Hexo/","excerpt":"前言 Hexo基于Node.js，由台湾大神tommy351开发，可以实现一个静态网页组成的博客，而且更轻更快，使用也相当的简单。只要安装了Git和Node.js，我们就可以在电脑上快速的用Hexo来写作，Hexo同样支持评论、分类、标签、图片等。 特性 快速Hexo基于Node.js，支持多线程，几百篇文章也可以几秒生成。 流畅支持GitHub Flavored Markdown和Octopress的插件。 扩展Hexo支持EJS、Swig和Stylus，通过插件支持Haml、Jade、Less 下面就来给大家介绍下Hexo静态博客环境搭建的方法。","text":"前言 Hexo基于Node.js，由台湾大神tommy351开发，可以实现一个静态网页组成的博客，而且更轻更快，使用也相当的简单。只要安装了Git和Node.js，我们就可以在电脑上快速的用Hexo来写作，Hexo同样支持评论、分类、标签、图片等。 特性 快速Hexo基于Node.js，支持多线程，几百篇文章也可以几秒生成。 流畅支持GitHub Flavored Markdown和Octopress的插件。 扩展Hexo支持EJS、Swig和Stylus，通过插件支持Haml、Jade、Less 下面就来给大家介绍下Hexo静态博客环境搭建的方法。 先整理一下思路1.首先hexo是基于nodejs，所以需要安装nodejs（之前没有安装过的话）。2.安装nodejs的方法很多的，因为为了简单，而且网上的很多教程也是用的homebrew安装方式，我也就用的这个。3.安装homebrew方式很简单，因为mac自带了ruby，一句话就能搞定。4.hexo提交部署需要git部署到github，所以需要安装git工具。5.整理一下安装顺序，（homebrew-nodejs-hexo-git）— 1.安装homebrew打开终端，输入下面代码： ruby -e “$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”稍等片刻安装完成就可以了，因为正在下载，如果没有网速的话，可以关闭或者按下‘Ctrk+C’来结束进程并重新下载。值得注意的是输入这行代码也可能会提醒你输入的过旧，需要输入新的代码，只用复制那段代码然后轻敲回车就OK。 2.安装nodejs用homebrew安装，一句话搞定。 brew install node 3.安装hexo可以使用nodejs自带的npm进行安装。 npm install -g hexo 3.1创建hexo文件夹待安装完成之后，在自己想要的位置新建一个文件夹，例如在根目录新建。打开终端输入： mkdir blog cd blog hexo init 3.2安装依赖包 npm install 4.安装git安装好之后建议注册一个github账号，如果没有的话。 4.1homebrew安装 sudo brew install git 4.2配置 4.2.1检查SSH key cd ~/.ssh 4.2.2备份已有的key mkdir key_backup mv id_rsa* key_backup 4.2.3生成SSH key ssh-keygen -t rsa -C &quot;xxxx@xxxx.com&quot; xxxx@xxxx为自己的github账号。 4.2.4将SSH key添加到github 登录到gitHub页面，Account Settings-&gt;SSH Public Keys-&gt;Add another key将生成的key(id_rsa.pub文件）内容copy到输入框中，save。id_rsa.pub文件放在.ssh这个隐藏文件夹之下，因为当前就在这个目录，所以直接打开。 ls open id_rsa.pub 打开这个文件推荐使用Sublime Text 2(下同),复制里面的东西，然后到在网页上保存。 4.2.5测试连接 ssh git@github.com 如果现实连接成功，那就可以，不可以请重复以上步骤，找出错误的原因，或者把显示的错误信息代码复制到谷歌上面搜索。 4.2.6设置个人信息 git config --global user.name &quot;xxx” git config --global user.email &quot;xxx@xxx.com&quot; xxx是你自己的github的账号，xxx@xxx.com是注册邮箱。 5.创建github上面的repository 在自己的github主页右下角，创建一个新的repositpry。我的github账号是HuCoco，那么我就应该创建的repository名字为HuCoco.github.io. 6.部署在自己创建的blog下找到_config.yml这个文件并编辑，在最下面添加如下的语句。网址的HuCoco替换成自己账号即可。 deploy: type: git repository: http://github.com/HuCoco/HuCoco.github.io.git branch: master PS:三个冒号之后需要留一个空格，不然会引起错误。 至此，hexo博客的搭建已经完成，接下来可以执行下面代码在本地运行,查看效果 cd blog hexo g hexo s 然后在浏览器中输入localhost:4000就可以看到了。如果没有错误的话，可以执行 hexo d 完成之后，我们的博客就完全搭建起来了。在浏览器中输入HuCoco.github.io就可以访问了，去看看你的成果吧！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://hucoco.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hucoco.com/tags/Hexo/"}]},{"title":"Windows 配置 Hexo","slug":"Windows-配置-Hexo","date":"2016-06-04T16:08:57.000Z","updated":"2016-06-09T16:21:40.000Z","comments":true,"path":"2016/06/05/Windows-配置-Hexo/","link":"","permalink":"http://hucoco.com/2016/06/05/Windows-配置-Hexo/","excerpt":"先说一些废话 Hexo基于Node.js，由台湾大神tommy351开发，可以实现一个静态网页组成的博客，而且更轻更快，使用也相当的简单。只要安装了Git和Node.js，我们就可以在电脑上快速的用Hexo来写作，Hexo同样支持评论、分类、标签、图片等。 特性 快速Hexo基于Node.js，支持多线程，几百篇文章也可以几秒生成。 流畅支持GitHub Flavored Markdown和Octopress的插件。 扩展Hexo支持EJS、Swig和Stylus，通过插件支持Haml、Jade、Less 下面就来给大家介绍下Hexo静态博客环境搭建的方法。","text":"先说一些废话 Hexo基于Node.js，由台湾大神tommy351开发，可以实现一个静态网页组成的博客，而且更轻更快，使用也相当的简单。只要安装了Git和Node.js，我们就可以在电脑上快速的用Hexo来写作，Hexo同样支持评论、分类、标签、图片等。 特性 快速Hexo基于Node.js，支持多线程，几百篇文章也可以几秒生成。 流畅支持GitHub Flavored Markdown和Octopress的插件。 扩展Hexo支持EJS、Swig和Stylus，通过插件支持Haml、Jade、Less 下面就来给大家介绍下Hexo静态博客环境搭建的方法。 Hexo安装方法一、下载Git msysGit下载地址 进入上面的页面,点击Download会进入下载页面，找到Downloads部分，根据自己系统的情况选择下载32位或者64位的安装包，下载完成后进行安装。 二、下在Node.jsNode.js下载地址同样进入上面的界面，点击INSTALL下载安装包，下载完成后并安装。 三、安装Hexo完成上面两步后，此时当我们在桌面点击鼠标右键时，会有一系列新的选项，这里我们需要用到的Git Bash，接下来我们会用命令行来完成剩余的工作。 1.安装Hexo根据上面的方法，打开Git Bash控制台，之后系统会打开一个窗口，窗口内是黑色的背景和一堆英文，看不懂没有关系跟着步骤一步一步做就行。在控制台中输入以下命令：npm install -g hexo之后系统会自动去Git上下载并安装Hexo，接下来会一直循环显示/-\\这三个符号，这表示系统在下载需要的文件。但是根据笔者遇到的情况，使用npm安装可能会出现卡住的现象导致无法正常安装，解决的办法就是修改npm的安装源，大家可以选择以下方法中的一个即可（正常下载的朋友就略过这里）1. 通过config命令： npm config set registry http://registry.cnpmjs.org npm info underscore2. 通过命令行指定 npm -registry http://registry.cnpmjs.org info underscore然后再来执行一次最开始的命令：npm install -g hexo耐心等待一会儿，Hexo就下载好了。2.生成Hexo静态博客 选一个适合的地方存放博客文件 cd命令可以在命令行中快速指定到一个地址，比如： cd D:\\ D: 这样可以快速的指定要一个地址上去，然后是创建一个文件夹进行归类管理 mkdir blog 这样在D盘我们就创建了一个名字为blog的文件夹。接下来我们在进入blog文件夹中，同样使用cd命令。 cd blog 此时我们进入了我们选好的地址中，执行以下命令： hexo init 然后你会看到以下的反馈： [info] Copying data [info] You are almost done! Don&#39;t forget to run &#39;npm install&#39;... 所以接下来就要执行 npm install 等待他完成后我们可以进去到文件夹中看到以下目录： node_modules： Hexo的功能JavaScript文件 public：生成静态网页文件 scaffolds：工具模板 source： /_drafts-草稿文件夹 /_posts-文章文件夹 themes：用来存放皮肤的文件夹 _config.yml：全局配置文件 db.json：json格式的静态常量数据库 查看生成的静态网页 进入到blog的地址后，执行如下的命令： hexo generate 用来生成静态网页相关的文件，这些文件会存储在public中，也可使用简单的命令hexo g 然后再输入hexo server或者hexo s这样可以在本地查看自己生成的网页，现在打开浏览器（推荐使用的浏览器是Chrome和FireFox）,在地址栏输入localhost:4000或者点击这里 最后最初始的工作就做完了，下一步的任务就是如何吧网页托管到GitHub上，这样别人也能开你的博客了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://hucoco.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hucoco.com/tags/Hexo/"}]}]}