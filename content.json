{"meta":{"title":"HuCoco's Blog","subtitle":"HuCoco's Blog","description":null,"author":"HuCoco","url":"http://hucoco.com"},"pages":[{"title":"这就是我","date":"2016-06-09T05:52:24.000Z","updated":"2016-06-09T13:27:02.000Z","comments":true,"path":"about/index.html","permalink":"http://hucoco.com/about/index.html","excerpt":"","text":"现在还是学生一枚，主要对C++比较熟悉，其他语言也都有了解，也就凑合这用吧，反正我没点全栈天赋，重点在图形学（学习中）和智能识别（准备折腾折腾） 业余生活也就崇拜下暴雪爸爸，打球，看书，看电影这些事。 还有就是不断的更新博客。 E-mail:hook@hucoco.com Github:@HuCoco 项目经验 学习阶段，使用Cocos2d-x各种模仿移动端小游戏，比如《Flappy brid》、《别踩白块》、《2048》等等 实验阶段，自己捣腾制作休闲游戏《PewPewPew》。 闲暇时间制作休闲游戏《Pixel Adventures》。 最后捣腾点稍微完整的游戏——《元素传奇》，麻雀虽小但是五脏俱全嘛。"},{"title":"img","date":"2016-06-09T12:50:37.000Z","updated":"2016-06-09T12:50:36.000Z","comments":true,"path":"img/index.html","permalink":"http://hucoco.com/img/index.html","excerpt":"","text":""}],"posts":[{"title":"拓扑排序","slug":"Graph/TopologicalOrder","date":"2016-11-24T06:21:11.000Z","updated":"2016-12-11T06:38:56.000Z","comments":true,"path":"2016/11/24/Graph/TopologicalOrder/","link":"","permalink":"http://hucoco.com/2016/11/24/Graph/TopologicalOrder/","excerpt":"拓扑拓扑排序介绍拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。 这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。 在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。","text":"拓扑拓扑排序介绍拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。 这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。 在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。 拓扑排序算法拓扑排序算法的基本步骤： 构造一个队列Q 和 拓扑排序的结果队列T； 把所有没有依赖顶点的节点放入Q； 当Q还有顶点的时候，执行下面步骤： 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)； 对n每一个邻接点m(n是起点，m是终点)； 去掉边(n,m); 如果m没有依赖顶点，则把m放入Q;注：顶点A没有依赖顶点，是指不存在以A为终点的边。 以上图为例，来对拓扑排序进行演示。 将B和C加入到排序结果中。 顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边(B,A)和(B,D)，并将A和D加入到队列Q中。同样的，去掉边(C,F)和(C,G)，并将F和G加入到Q中。 将B加入到排序结果中，然后去掉边(B,A)和(B,D)；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。 将C加入到排序结果中，然后去掉边(C,F)和(C,G)；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。 将A,D依次加入到排序结果中。 第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。 将E,F,G依次加入到排序结果中。 因此访问顺序是：B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; F -&gt; G 拓扑排序实现拓扑排序是对有向无向图的排序。 邻接矩阵图实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void GraphByMatrix::topologicalSort() &#123; if(m_Type == GraphType::Undirected) &#123; std::cout &lt;&lt; \"[TopSort Error] This is undirected graph!\" &lt;&lt;std::endl; return; &#125; int i,j,k; int index = 0; int head = 0; int rear = 0; int* queue; int* ins; std::string* tops; ins = new int[m_VexNum]; queue = new int[m_VexNum]; tops = new std::string[m_VexNum]; memset(ins, 0, m_VexNum * sizeof(int)); memset(queue, 0, m_VexNum * sizeof(int)); memset(tops, 0, m_VexNum * sizeof(std::string)); for(i = 0 ; i &lt; m_VexNum ; i++) &#123; for(k = firstVertex(i) ; k &gt;=0 ; k = nextVertex(i, k)) &#123; ins[k]++; &#125; &#125; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; if(ins[i] == 0) &#123; queue[rear++] = i; &#125; &#125; while (head != rear) &#123; j = queue[head++]; tops[index++] = m_pVexs[j]; for(k = firstVertex(j) ; k &gt;= 0 ; k = nextVertex(j, k)) &#123; ins[k]--; if(ins[k] == 0) &#123; queue[rear++] = k; &#125; &#125; &#125; if(index != m_VexNum) &#123; std::cout &lt;&lt; \"[TopSort Error] Have cycle!\" &lt;&lt;std::endl; delete[] queue; delete[] ins; delete[] tops; return; &#125; std::cout &lt;&lt; \"TopSort: \"; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; std::cout &lt;&lt; tops[i] &lt;&lt; \" \"; &#125; std::cout &lt;&lt; std::endl; delete[] queue; delete[] ins; delete[] tops; return;&#125; 邻接表图实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void GraphByList::topologicalSort() &#123; if(m_Type == GraphType::Undirected) &#123; std::cout &lt;&lt; \"[TopSort Error] This is undirected graph!\" &lt;&lt;std::endl; return; &#125; int i,j; int index = 0; int head = 0; int rear = 0; int* queue; int* ins; std::string* tops; ENode* p; ins = new int[m_VexNum]; queue = new int[m_VexNum]; tops = new std::string[m_VexNum]; memset(ins, 0, m_VexNum * sizeof(int)); memset(queue, 0, m_VexNum * sizeof(int)); memset(tops, 0, m_VexNum * sizeof(std::string)); for(i = 0 ; i &lt; m_VexNum ; i++) &#123; p = m_pVexs[i].firstEdge; while (p != nullptr) &#123; ins[p-&gt;m_Vex]++; p = p-&gt;next; &#125; &#125; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; if(ins[i] == 0) &#123; queue[rear++] = i; &#125; &#125; while (head != rear) &#123; j = queue[head++]; tops[index++] = m_pVexs[j].m_Data; p = m_pVexs[j].firstEdge; while (p != nullptr) &#123; ins[p-&gt;m_Vex]--; if(ins[p-&gt;m_Vex] == 0) &#123; queue[rear++] = p-&gt;m_Vex; &#125; p = p-&gt;next; &#125; &#125; if(index != m_VexNum) &#123; std::cout &lt;&lt; \"[TopSort Error] Have cycle!\" &lt;&lt;std::endl; delete[] queue; delete[] ins; delete[] tops; return; &#125; std::cout &lt;&lt; \"TopSort: \"; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; std::cout &lt;&lt; tops[i] &lt;&lt; \" \"; &#125; std::cout &lt;&lt; std::endl; delete[] queue; delete[] ins; delete[] tops; return;&#125; 源码邻接矩阵图头文件 邻接矩阵图源文件 邻接表图头文件 邻接表图源文件","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"图","slug":"数据结构/图","permalink":"http://hucoco.com/categories/数据结构/图/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hucoco.com/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"图","slug":"图","permalink":"http://hucoco.com/tags/图/"}]},{"title":"广度优先搜索","slug":"Graph/BFS","date":"2016-11-22T06:04:58.000Z","updated":"2016-12-11T06:19:14.000Z","comments":true,"path":"2016/11/22/Graph/BFS/","link":"","permalink":"http://hucoco.com/2016/11/22/Graph/BFS/","excerpt":"广度优先搜索广度优先搜索介绍广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。 它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。 广度优先搜索图解无向图的广度优先搜索下面以”无向图”为例，来对广度优先搜索进行演示。","text":"广度优先搜索广度优先搜索介绍广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。 它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。 广度优先搜索图解无向图的广度优先搜索下面以”无向图”为例，来对广度优先搜索进行演示。 第1步：访问A。第2步：依次访问C,D,F。 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 第3步：依次访问B,G。 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 第4步：访问E。 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。 因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E 有向图的广度优先搜索下面以”有向图”为例，来对广度优先搜索进行演示。 第1步：访问A。 第2步：访问B。 第3步：依次访问C,E,F。 在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 第4步：依次访问D,G。 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。 因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G 算法实现用邻接矩阵图实现： 123456789101112131415161718192021222324252627282930313233void GraphByMatrix::BreadthFirstSearch() &#123; int head = 0; int rear = 0; int* queue = new int[m_VexNum]; int* visited = new int[m_VexNum]; int i,j,k; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; visited[i] = 0; &#125; std::cout &lt;&lt; \"Breadth First Search: \"; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; if(!visited[i]) &#123; visited[i] = 1; std::cout &lt;&lt; m_pVexs[i] &lt;&lt; \" \"; queue[rear++] = i; &#125; while (head != rear) &#123; j = queue[head++]; for(k = firstVertex(j) ; k &gt;= 0 ; k = nextVertex(j, k)) &#123; if(!visited[k]) &#123; visited[k] = 1; std::cout &lt;&lt; m_pVexs[k] &lt;&lt; \" \"; queue[rear++] = k; &#125; &#125; &#125; &#125; std::cout &lt;&lt; std::endl; delete[] queue; delete[] visited;&#125; 用邻接表图实现： 12345678910111213141516171819202122232425262728293031323334353637void GraphByList::BreadthFirstSearch() &#123; int head = 0; int rear = 0; int* queue = new int[m_VexNum]; bool* visited = new bool[m_VexNum]; int i,j,k; ENode* p; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; visited[i] = false; &#125; std::cout &lt;&lt; \"Breadth First Search: \"; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; if(!visited[i]) &#123; visited[i] = true; std::cout &lt;&lt; m_pVexs[i].m_Data &lt;&lt; \" \"; queue[rear++] = i; &#125; while (head != rear) &#123; j = queue[head++]; p = m_pVexs[j].firstEdge; while(p != nullptr) &#123; k = p-&gt;m_Vex; if(!visited[k]) &#123; visited[k] = true; std::cout &lt;&lt; m_pVexs[k].m_Data &lt;&lt; \" \"; queue[rear++] = k; &#125; p = p-&gt;next; &#125; &#125; &#125; std::cout &lt;&lt; std::endl; delete[] queue; delete[] visited;&#125; 源码邻接矩阵图头文件 邻接矩阵图源文件 邻接表图头文件 邻接表图源文件","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"图","slug":"数据结构/图","permalink":"http://hucoco.com/categories/数据结构/图/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hucoco.com/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"图","slug":"图","permalink":"http://hucoco.com/tags/图/"}]},{"title":"深度优先搜索","slug":"Graph/DFS","date":"2016-11-20T02:47:36.000Z","updated":"2016-12-11T06:17:30.000Z","comments":true,"path":"2016/11/20/Graph/DFS/","link":"","permalink":"http://hucoco.com/2016/11/20/Graph/DFS/","excerpt":"深度优先搜索深度优先搜索介绍图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。 它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 显然，深度优先搜索是一个递归的过程，当然也可以使用迭代来实现，但在这里使用递归来实现。（对，我就是懒！） 深度优先搜索图解无向图的深度优先搜索下面以”无向图”为例，来对深度优先搜索进行演示。","text":"深度优先搜索深度优先搜索介绍图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。 它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 显然，深度优先搜索是一个递归的过程，当然也可以使用迭代来实现，但在这里使用递归来实现。（对，我就是懒！） 深度优先搜索图解无向图的深度优先搜索下面以”无向图”为例，来对深度优先搜索进行演示。 对上面的图进行深度优先遍历，从顶点A开始： 访问A。 访问(A的邻接点)C。 在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。 访问(C的邻接点)B。 在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 访问(C的邻接点)D。 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 访问(A的邻接点)F。 前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 访问(F的邻接点)G。 访问(G的邻接点)E。 因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E 有向图的深度优先搜索下面以”有向图”为例，来对深度优先搜索进行演示。 对上面的图G2进行深度优先遍历，从顶点A开始。 访问A。 访问B。 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 访问C。 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 访问E。 接下来访问C的出边的另一个顶点，即顶点E。 访问D。 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 访问F。 接下应该回溯”访问A的出边的另一个顶点F”。 访问G。 因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G 算法实现实现邻接矩阵图的深度优先搜索，我们需要两个辅助函数 12345678910111213int GraphByMatrix::firstVertex(int v) &#123; int i; if(v &lt; 0 || v &gt;(m_VexNum-1)) &#123; return -1; &#125; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; if(m_pMatrix[v][i] == 1)&#123; return i; &#125; &#125; return -1;&#125; 这个函数会返回索引为v的顶点的第一个邻接点，邻接点的顺序根据存储顺序来判定。 12345678910111213int GraphByMatrix::nextVertex(int v, int w) &#123; int i; if(v &lt; 0 || v &gt;(m_VexNum-1) || w &lt; 0 || w &gt; (m_VexNum-1)) &#123; return -1; &#125; for(i = w + 1 ; i &lt; m_VexNum ; i++) &#123; if(m_pMatrix[v][i] == 1)&#123; return i; &#125; &#125; return -1;&#125; 上面这个函数会返回索引为v的顶点，相对于邻接点索引为w的顶点的下一个顶点。 接下来是邻接矩阵图的深度优先搜索 1234567891011121314151617181920212223242526272829void GraphByMatrix::DepthFirstSearch(int i, int *visited) &#123; int w; visited[i] = 1; std::cout &lt;&lt; m_pVexs[i] &lt;&lt; \" \"; for(w = firstVertex(i); w &gt;= 0 ; w = nextVertex(i, w)) &#123; if(!visited[w]) &#123; DepthFirstSearch(w, visited); &#125; &#125;&#125;void GraphByMatrix::DepthFirstSearch() &#123; int i; int* visited = new int[m_VexNum]; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; visited[i] = 0; &#125; std::cout &lt;&lt; \"Depth First Search: \"; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; if(!visited[i]) &#123; DepthFirstSearch(i, visited); &#125; &#125; std::cout &lt;&lt; std::endl; delete[] visited;&#125; 然后是邻接表的深度优先搜索： 12345678910111213141516171819202122232425262728293031void GraphByList::DepthFirstSearch(int i, bool *visited) &#123; ENode* p; visited[i] = true; std::cout &lt;&lt; m_pVexs[i].m_Data &lt;&lt; \" \"; p = m_pVexs[i].firstEdge; while (p != nullptr) &#123; if(!visited[p-&gt;m_Vex]) &#123; DepthFirstSearch(p-&gt;m_Vex, visited); &#125; p = p-&gt;next; &#125;&#125;void GraphByList::DepthFirstSearch() &#123; int i; bool* visited = new bool[m_VexNum]; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; visited[i] = false; &#125; std::cout &lt;&lt; \"Depth First Search: \"; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; if(!visited[i]) &#123; DepthFirstSearch(i, visited); &#125; &#125; std::cout &lt;&lt; std::endl; delete[] visited;&#125; 这里可以将DepthFirstSearch()的实现放到Graph基类上。 源码邻接矩阵图头文件 邻接矩阵图源文件 邻接表图头文件 邻接表图源文件","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"图","slug":"数据结构/图","permalink":"http://hucoco.com/categories/数据结构/图/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hucoco.com/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"图","slug":"图","permalink":"http://hucoco.com/tags/图/"}]},{"title":"邻接表图","slug":"Graph/GraphByList","date":"2016-11-18T14:37:47.000Z","updated":"2016-12-11T02:44:40.000Z","comments":true,"path":"2016/11/18/Graph/GraphByList/","link":"","permalink":"http://hucoco.com/2016/11/18/Graph/GraphByList/","excerpt":"邻接表图邻接表无向图 上面的图包含了”A,B,C,D,E,F,G”共7个顶点，而且包含了”(A,C),(A,D),(A,F),(B,C),(C,D),(E,G),(F,G)”共7条边。 上图右边的矩阵是在内存中的邻接表示意图。每一个顶点都包含一条链表，该链表记录了”该顶点的邻接点的序号”。例如，第2个顶点(顶点C)包含的链表所包含的节点的数据分别是”0,1,3”；而这”0,1,3”分别对应”A,B,D”的序号，”A,B,D”都是C的邻接点。就是通过这种方式记录图的信息的。","text":"邻接表图邻接表无向图 上面的图包含了”A,B,C,D,E,F,G”共7个顶点，而且包含了”(A,C),(A,D),(A,F),(B,C),(C,D),(E,G),(F,G)”共7条边。 上图右边的矩阵是在内存中的邻接表示意图。每一个顶点都包含一条链表，该链表记录了”该顶点的邻接点的序号”。例如，第2个顶点(顶点C)包含的链表所包含的节点的数据分别是”0,1,3”；而这”0,1,3”分别对应”A,B,D”的序号，”A,B,D”都是C的邻接点。就是通过这种方式记录图的信息的。 邻接表有向图 上面的图包含了”A,B,C,D,E,F,G”共7个顶点，而且包含了”(A,B),(B,C),(B,E),(B,F),(C,E),(D,C),(E,B),(E,D),(F,G)”共9条边。 上图右边的矩阵是在内存中的邻接表示意图。每一个顶点都包含一条链表，该链表记录了”该顶点所对应的出边的另一个顶点的序号”。例如，第1个顶点(顶点B)包含的链表所包含的节点的数据分别是”2,4,5”；而这”2,4,5”分别对应”C,E,F”的序号，”C,E,F”都属于B的出边的另一个顶点 邻接表图实现定义12345678910111213141516171819202122232425262728293031323334353637#include \"Graph.hpp\"#include &lt;string&gt;class GraphByList : public Graph &#123;private: class ENode &#123; public: int m_Vex; ENode* next; ENode() &#123; next = nullptr; &#125; &#125;; class VNode &#123; public: std::string m_Data; ENode* firstEdge; &#125;;public: GraphByList(const GraphType&amp; type,std::string vexs[], int vlen, std::string edges[][2], int elen); virtual ~GraphByList(); virtual int getPosition(std::string str); virtual void print(); virtual void DepthFirstSearch(); virtual void BreadthFirstSearch(); virtual void topologicalSort();private: void push_back(ENode* list,ENode* node); void DepthFirstSearch(int i,bool* visited);private: int m_VexNum; int m_EdgeNum; VNode* m_pVexs; const GraphType m_Type;&#125;; m_VexNum是顶点数，m_EdgeNum是边数；m_pVexs则是保存顶点信息的一维数组。 VNode是邻接表顶点对应的结构体。 m_Data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。 ENode是邻接表顶点所包含的链表的节点对应的结构体。 m_Vex是该节点所对应的顶点在m_pVexs中的索引，而next是指向下一个节点的。 构造1234567891011121314151617181920212223242526272829303132333435363738394041424344GraphByList::GraphByList(const GraphType&amp; type,std::string vexs[], int vlen, std::string edges[][2], int elen):m_Type(type),m_VexNum(vlen),m_EdgeNum(elen) &#123; std::string str1,str2; int i,p1,p2; m_pVexs = new VNode[m_VexNum]; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; m_pVexs[i].m_Data = vexs[i]; m_pVexs[i].firstEdge = nullptr; &#125; for(i = 0 ; i &lt; m_EdgeNum ; i++) &#123; str1 = edges[i][0]; str2 = edges[i][1]; p1 = getPosition(str1); p2 = getPosition(str2); ENode* node = new ENode; node-&gt;m_Vex = p2; if(m_pVexs[p1].firstEdge == nullptr) &#123; m_pVexs[p1].firstEdge = node; &#125; else &#123; push_back(m_pVexs[p1].firstEdge, node); &#125; if(m_Type == GraphType::Undirected) &#123; ENode* node = new ENode; node-&gt;m_Vex = p1; if(m_pVexs[p2].firstEdge == nullptr) &#123; m_pVexs[p2].firstEdge = node; &#125; else &#123; push_back(m_pVexs[p2].firstEdge, node); &#125; &#125; &#125;&#125; 这里需要区分有向图和无向图： 1234567891011if(m_Type == GraphType::Undirected) &#123; ENode* node = new ENode; node-&gt;m_Vex = p1; if(m_pVexs[p2].firstEdge == nullptr) &#123; m_pVexs[p2].firstEdge = node; &#125; else &#123; push_back(m_pVexs[p2].firstEdge, node); &#125;&#125; 这里给出一组测试数据： 123456789101112131415161718192021222324252627282930313233343536//节点数组std::string vexs[] = &#123;\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"&#125;;//无向图边数据std::string edges[][2] = &#123; &#123;\"A\",\"C\"&#125;, &#123;\"A\",\"D\"&#125;, &#123;\"A\",\"F\"&#125;, &#123;\"B\",\"C\"&#125;, &#123;\"C\",\"D\"&#125;, &#123;\"E\",\"G\"&#125;, &#123;\"F\",\"G\"&#125;&#125;;//有向图边数据std::string edges2[][2] = &#123; &#123;\"A\",\"B\"&#125;, &#123;\"B\",\"C\"&#125;, &#123;\"B\",\"E\"&#125;, &#123;\"B\",\"F\"&#125;, &#123;\"C\",\"E\"&#125;, &#123;\"D\",\"C\"&#125;, &#123;\"E\",\"B\"&#125;, &#123;\"E\",\"D\"&#125;, &#123;\"F\",\"G\"&#125;&#125;;int vlen = sizeof(vexs)/sizeof(vexs[0]);int elen = sizeof(edges)/sizeof(edges[0]);int elen2 = sizeof(edges2)/sizeof(edges2[0]);Graph* graph3 = GraphCreator::create(GRAPH_LIST | GRAPH_DIRECTION, vexs,vlen,edges,elen);graph3-&gt;print();std::cout &lt;&lt; std::endl;Graph* graph4 = GraphCreator::create(GRAPH_LIST | GRAPH_UNDIRECTION, vexs,vlen,edges2,elen2);graph4-&gt;print();std::cout &lt;&lt; std::endl; 头文件源码：GraphByList.hpp 源文件源码：GraphByList.cpp","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"图","slug":"数据结构/图","permalink":"http://hucoco.com/categories/数据结构/图/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"图","slug":"图","permalink":"http://hucoco.com/tags/图/"}]},{"title":"邻接矩阵图","slug":"Graph/GraphByMatrix","date":"2016-11-16T00:37:39.000Z","updated":"2016-12-11T02:44:57.000Z","comments":true,"path":"2016/11/16/Graph/GraphByMatrix/","link":"","permalink":"http://hucoco.com/2016/11/16/Graph/GraphByMatrix/","excerpt":"邻接矩阵图邻接矩阵无向图邻接矩阵无向图是指通过邻接矩阵表示的无向图。 上面的图包含了&quot;A,B,C,D,E,F,G&quot;共7个顶点，而且包含了&quot;(A,C),(A,D),(A,F),(B,C),(C,D),(E,G),(F,G)&quot;共7条边。由于这是无向图，所以边(A,C)和边(C,A)是同一条边；这里列举边时，是按照字母先后顺序列举的。","text":"邻接矩阵图邻接矩阵无向图邻接矩阵无向图是指通过邻接矩阵表示的无向图。 上面的图包含了&quot;A,B,C,D,E,F,G&quot;共7个顶点，而且包含了&quot;(A,C),(A,D),(A,F),(B,C),(C,D),(E,G),(F,G)&quot;共7条边。由于这是无向图，所以边(A,C)和边(C,A)是同一条边；这里列举边时，是按照字母先后顺序列举的。 N/A A B C D E F G A 0 0 1 1 0 1 0 B 0 0 1 0 0 0 0 C 1 1 0 1 0 0 0 D 1 0 1 0 0 0 0 E 0 0 0 0 0 0 1 F 1 0 0 0 0 0 1 G 0 0 0 0 1 1 0 上图右边的矩阵是在内存中的邻接矩阵示意图。A[i][j]=1表示第i个顶点与第j个顶点是邻接点，A[i][j]=0则表示它们不是邻接点；而A[i][j]表示的是第i行第j列的值；例如，A[1,2]=1，表示第1个顶点(即顶点B)和第2个顶点(C)是邻接点。 邻接矩阵有向图 上面的图包含了”A,B,C,D,E,F,G”共7个顶点，而且包含了&quot;&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,E&gt;,&lt;B,F&gt;,&lt;C,E&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;E,D&gt;,&lt;F,G&gt;&quot;共9条边。 N/A A B C D E F G A 0 1 0 0 0 0 0 B 0 0 1 0 1 1 0 C 0 0 0 0 1 0 0 D 0 0 1 0 0 0 0 E 0 1 0 1 0 0 1 F 0 0 0 0 0 0 1 G 0 0 0 0 0 0 0 上图右边的矩阵是在内存中的邻接矩阵示意图。A[i][j]=1表示第i个顶点到第j个顶点是一条边，A[i][j]=0则表示不是一条边；而A[i][j]表示的是第i行第j列的值；例如，A[1,2]=1，表示第1个顶点(即顶点B)到第2个顶点(C)是一条边。 邻接矩阵图定义12345678910111213141516171819202122#include \"Graph.hpp\"#include &lt;string&gt;class GraphByMatrix : public Graph &#123;public: GraphByMatrix(const GraphType&amp; m_Type,std::string vexs[], int vlen, std::string edges[][2], int elen); virtual ~GraphByMatrix(); virtual int getPosition(std::string str); virtual void print(); virtual void DepthFirstSearch(); virtual void BreadthFirstSearch(); virtual void topologicalSort();private: void DepthFirstSearch(int i,int* visited); int firstVertex(int v); int nextVertex(int v,int w);private: std::string* m_pVexs; int m_VexNum; int m_EdgeNum; bool** m_pMatrix; const GraphType m_Type; 继承与Graph基类统一接口。 m_pVexs用于保存顶点，m_VexNum是顶点数，m_EdgeNum是边数；m_pMatrix则是用于保存矩阵信息的二维数组。例如，m_pMatrix[i][j]=1，则表示”顶点i(即m_pVexs[i])”和”顶点j(即m_pVexs[j])”是邻接点，且顶点i是起点，顶点j是终点。 构造123456789101112131415161718192021222324252627282930GraphByMatrix::GraphByMatrix(const GraphType&amp; type,std::string vexs[], int vlen, std::string edges[][2], int elen):m_Type(type),m_VexNum(vlen),m_EdgeNum(elen) &#123; int i,p1,p2; m_pVexs = new std::string[m_VexNum]; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; m_pVexs[i] = vexs[i]; &#125; m_pMatrix = new bool*[m_VexNum]; for(i = 0 ; i &lt; m_VexNum ; i++) &#123; m_pMatrix[i] = new bool[m_VexNum]; for(int j = 0 ; j &lt; m_VexNum ; j++) &#123; m_pMatrix[i][j] = false; &#125; &#125; for(i = 0 ; i &lt; m_EdgeNum ; i++) &#123; p1 = getPosition(edges[i][0]); p2 = getPosition(edges[i][1]); m_pMatrix[p1][p2] = true; if(m_Type == GraphType::Undirected) &#123; m_pMatrix[p2][p1] = true; &#125; &#125;&#125; 这里需要区分的是有向图和无向图： 123if(m_Type == GraphType::Undirected) &#123; m_pMatrix[p2][p1] = true;&#125; 如果是无向图，就需要执行这一步操作，使其变得对称。即(A,C)是一条边时，(C,A)也是一条边。 这里给出测试数据： 123456789101112131415161718192021222324252627282930313233343536//节点数组std::string vexs[] = &#123;\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"&#125;;//无向图边数据std::string edges[][2] = &#123; &#123;\"A\",\"C\"&#125;, &#123;\"A\",\"D\"&#125;, &#123;\"A\",\"F\"&#125;, &#123;\"B\",\"C\"&#125;, &#123;\"C\",\"D\"&#125;, &#123;\"E\",\"G\"&#125;, &#123;\"F\",\"G\"&#125;&#125;;//有向图边数据std::string edges2[][2] = &#123; &#123;\"A\",\"B\"&#125;, &#123;\"B\",\"C\"&#125;, &#123;\"B\",\"E\"&#125;, &#123;\"B\",\"F\"&#125;, &#123;\"C\",\"E\"&#125;, &#123;\"D\",\"C\"&#125;, &#123;\"E\",\"B\"&#125;, &#123;\"E\",\"D\"&#125;, &#123;\"F\",\"G\"&#125;&#125;;int vlen = sizeof(vexs)/sizeof(vexs[0]);int elen = sizeof(edges)/sizeof(edges[0]);int elen2 = sizeof(edges2)/sizeof(edges2[0]);Graph* graph = GraphCreator::create(GRAPH_MATRIX | GRAPH_DIRECTION, vexs,vlen,edges,elen);graph-&gt;print();std::cout &lt;&lt; std::endl;Graph* graph2 = GraphCreator::create(GRAPH_MATRIX | GRAPH_UNDIRECTION, vexs,vlen,edges2,elen2);graph2-&gt;print();std::cout &lt;&lt; std::endl; 头文件源码：GraphByMatrix.hpp 源文件源码：GraphByMatrix.cpp","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"图","slug":"数据结构/图","permalink":"http://hucoco.com/categories/数据结构/图/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"图","slug":"图","permalink":"http://hucoco.com/tags/图/"}]},{"title":"图基类和工厂函数","slug":"Graph/Graph","date":"2016-11-14T14:38:37.000Z","updated":"2016-12-11T02:41:30.000Z","comments":true,"path":"2016/11/14/Graph/Graph/","link":"","permalink":"http://hucoco.com/2016/11/14/Graph/Graph/","excerpt":"图 Graph图论图的定义图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为”顶点(vertex)”，而点与点之间的连线则被成为”边或弧”(edege)。通常记为，G=(V,E)。 图的种类根据边是否有方向，将图可以划分为：无向图和有向图。 无向图","text":"图 Graph图论图的定义图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为”顶点(vertex)”，而点与点之间的连线则被成为”边或弧”(edege)。通常记为，G=(V,E)。 图的种类根据边是否有方向，将图可以划分为：无向图和有向图。 无向图 上面的图是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中： V1 = { A , B , C , D , E , F } V1表示由”A,B,C,D,E,F”几个顶点组成的集合。 E1 = { (A,B) , (A,C) , (B,C) , (B,E) , (B,F) , (C,F) , (C,D) , (E,F) , (C,E)} E1是由边(A,B),边(A,C)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。 有向图 上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中， V2={A,C,B,F,D,E,G} V2表示由”A,B,C,D,E,F,G”几个顶点组成的集合。 E2={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;} E1是由矢量,矢量…等等组成的集合。其中，矢量&lt;A,B)表示由”顶点A”指向”顶点C”的有向边。 邻接点和度邻接点一条边上的两个顶点叫做邻接点。例如，上面无向图中的顶点A和顶点C就是邻接点。 在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。 例如，上面有向图中的B和E是邻接点；是B的出边，还是E的入边。 度在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。例如，上面无向图中顶点A的度是2。 在有向图中，度还有”入度”和”出度”之分。 某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。 顶点的度=入度+出度。 例如，上面有向图中，顶点B的入度是2，出度是3，顶点B的度=2+3=5。 路径和回路路径：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。 路径长度：路径中”边的数量”。 简单路径：若一条路径上顶点不重复出现，则是简单路径。 回路：若路径的第一个顶点和最后一个顶点相同，则是回路。 简单回路：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。 连通图和连通分量连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。 连通分量：非连通图中的各个连通子图称为该图的连通分量。 权图的存储图的存储结构，常用的是”邻接矩阵”和”邻接表”。 邻接矩阵邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。假设图中顶点数为n，则邻接矩阵定义为 A[i][j] == 1 存在边 A[i][j] == 0 不存在边 下面通过示意图来进行解释。 N/A A B C D E F G A 0 0 1 1 0 1 0 B 0 0 1 0 0 0 0 C 1 1 0 1 0 0 0 D 1 0 1 0 0 0 0 E 0 0 0 0 0 0 1 F 1 0 0 0 0 0 1 G 0 0 0 0 1 1 0 无向图和它对应的邻接矩阵 N/A A B C D E F G A 0 1 0 0 0 0 0 B 0 0 1 0 1 1 0 C 0 0 0 0 1 0 0 D 0 0 1 0 0 0 0 E 0 1 0 1 0 0 1 F 0 0 0 0 0 0 1 G 0 0 0 0 0 0 0 有向图和它对应的邻接矩阵 通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。 邻接矩阵的缺点就是比较耗费空间。 邻接表邻接表是图的一种链式存储表示方法。它是改进后的”邻接矩阵”，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。 无向图和它对应的邻接矩阵。 有向图和它对应的邻接矩阵。 图基类这里我们构造一个图的接口类，这样我们能使用一套接口来完成对这几种类型的图的操作，虚基类能很好的完成这项任务。 这里涉及到了C++的动态多态。 源码：Graph.hpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546enum class GraphType &#123; Undirected = 0, Directed = 1&#125;;class Graph &#123;protected: Graph()&#123;&#125;; /** * [Graph 构造函数模板] * * @param type [有向图或者无向图] * @param vexs [节点数据数组] * @param vlen [节点数据数组长度] * @param edges [边数据数组] * @param elen [边数据数组长度] * */ Graph(const GraphType&amp; type,std::string vexs[], int vlen, std::string edges[][2], int elen) &#123;&#125; /** * [getPosition 返回对应数据节点位置] * @param std::string [节点数据] * @return [节点位置] */ virtual int getPosition(std::string) = 0;public: virtual ~Graph() &#123;&#125;; /** * [print 打印图数据] */ virtual void print() = 0; /** * [DepthFirstSearch 深度优先搜索（遍历）] */ virtual void DepthFirstSearch() = 0; /** * [BreadthFirstSearch 广度优先搜索（遍历）] */ virtual void BreadthFirstSearch() = 0; /** * [topologicalSort 拓扑排序] */ virtual void topologicalSort() = 0;&#125;; 图工厂类用工厂模式来构造图类，我们不需要关心我们需要声明一个什么类型的数据，只需要传入相关的参数就能获取到对应的数据。 源码：GraphCreator.hpp 1234567891011121314151617181920212223242526272829#include &lt;string&gt;typedef int8_t GraphMask;const GraphMask GRAPH_MATRIX = 0x1;const GraphMask GRAPH_LIST = 0x2;const GraphMask GRAPH_DIRECTION = 0x4;const GraphMask GRAPH_UNDIRECTION = 0x8;class Graph;class GraphByMatrix;class GraphByList;/** * 图类数据工厂类 */class GraphCreator &#123;public: /** * [create 构造图类数据] * @param GraphMask [传入需要构造的图的类型] GRAPH_MATRIX 和 GRAPH_LIST必须选择一个，GRAPH_DIRECTION 和 GRAPH_UNDIRECTION 可选可不选，默认为GRAPH_UNDIRECTION * @param others [参见Graph.hpp] * * @return [图类数据] */ static Graph* create(GraphMask mask,std::string vexs[], int vlen, std::string edges[][2], int elen);&#125;; 源码：GraphCreator.cpp 1234567891011121314151617181920212223242526272829303132#include \"GraphCreator.hpp\"#include \"Graph.hpp\"#include \"GraphByMatrix.hpp\"#include \"GraphByList.hpp\"Graph* GraphCreator::create(GraphMask mask,std::string vexs[], int vlen, std::string edges[][2], int elen) &#123; Graph* pRet; switch (mask) &#123; case GRAPH_MATRIX: case GRAPH_MATRIX | GRAPH_UNDIRECTION: pRet = new GraphByMatrix(GraphType::Undirected,vexs,vlen,edges,elen); break; case GRAPH_MATRIX | GRAPH_DIRECTION: pRet = new GraphByMatrix(GraphType::Directed,vexs,vlen,edges,elen); break; case GRAPH_LIST: case GRAPH_LIST | GRAPH_UNDIRECTION: pRet = new GraphByList(GraphType::Undirected,vexs,vlen,edges,elen); break; case GRAPH_LIST | GRAPH_DIRECTION: pRet = new GraphByList(GraphType::Directed,vexs,vlen,edges,elen); break; default: pRet = nullptr; &#125; if(pRet == nullptr) &#123; return nullptr; &#125; return pRet;&#125; 之后我们很轻松的就能创建不同类型的度，而且我们不需要关注它具体是什么类型的。 邻接矩阵有向图1Graph* graph = GraphCreator::create(GRAPH_MATRIX | GRAPH_DIRECTION, vexs,vlen,edges,elen); 邻接矩阵有向图1Graph* graph = GraphCreator::create(GRAPH_MATRIX | GRAPH_UNDIRECTION, vexs,vlen,edges2,elen2); 邻接表有向图1Graph* graph = GraphCreator::create(GRAPH_LIST | GRAPH_DIRECTION, vexs,vlen,edges,elen); 邻接表无向图1Graph* graph = GraphCreator::create(GRAPH_LIST | GRAPH_UNDIRECTION, vexs,vlen,edges2,elen2);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"图","slug":"数据结构/图","permalink":"http://hucoco.com/categories/数据结构/图/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"图","slug":"图","permalink":"http://hucoco.com/tags/图/"}]},{"title":"红黑树实现（删除）","slug":"Tree/RBTree/红黑树实现（删除）","date":"2016-11-10T11:43:32.000Z","updated":"2016-12-11T02:41:21.000Z","comments":true,"path":"2016/11/10/Tree/RBTree/红黑树实现（删除）/","link":"","permalink":"http://hucoco.com/2016/11/10/Tree/RBTree/红黑树实现（删除）/","excerpt":"上一节《红黑树实现(旋转)》 红黑树基本操作删除我们删除的节点的方法与常规二叉搜索树中删除节点的方法是一样的，如果被删除的节点不是有双非空子女，则直接删除这个节点，用它的唯一子节点顶替它的位置，如果它的子节点分是空节点，那就用空节点顶替它的位置，如果它的双子全为非空，我们就把它的直接后继节点内容复制到它的位置，之后以同样的方式删除它的后继节点，它的后继节点不可能是双子非空，因此此传递过程最多只进行一次 二叉树的删除继续讲解之前，补充说明下二叉树结点删除的几种情况，待删除的节点按照儿子的个数可以分为三种： 没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。 只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。 有两个儿子。这是最麻烦的情况，因为你删除节点之后，还要保证满足搜索二叉树的结构。其实也比较容易，我们可以选择左儿子中的最大元素或者右儿子中的最小元素放到待删除节点的位置，就可以保证结构的不变。当然，你要记得调整子树，毕竟又出现了节点删除。习惯上大家选择左儿子中的最大元素，其实选择右儿子的最小元素也一样，没有任何差别，只是人们习惯从左向右。这里咱们也选择左儿子的最大元素，将它放到待删结点的位置。左儿子的最大元素其实很好找，只要顺着左儿子不断的去搜索右子树就可以了，直到找到一个没有右子树的结点。那就是最大的了。","text":"上一节《红黑树实现(旋转)》 红黑树基本操作删除我们删除的节点的方法与常规二叉搜索树中删除节点的方法是一样的，如果被删除的节点不是有双非空子女，则直接删除这个节点，用它的唯一子节点顶替它的位置，如果它的子节点分是空节点，那就用空节点顶替它的位置，如果它的双子全为非空，我们就把它的直接后继节点内容复制到它的位置，之后以同样的方式删除它的后继节点，它的后继节点不可能是双子非空，因此此传递过程最多只进行一次 二叉树的删除继续讲解之前，补充说明下二叉树结点删除的几种情况，待删除的节点按照儿子的个数可以分为三种： 没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。 只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。 有两个儿子。这是最麻烦的情况，因为你删除节点之后，还要保证满足搜索二叉树的结构。其实也比较容易，我们可以选择左儿子中的最大元素或者右儿子中的最小元素放到待删除节点的位置，就可以保证结构的不变。当然，你要记得调整子树，毕竟又出现了节点删除。习惯上大家选择左儿子中的最大元素，其实选择右儿子的最小元素也一样，没有任何差别，只是人们习惯从左向右。这里咱们也选择左儿子的最大元素，将它放到待删结点的位置。左儿子的最大元素其实很好找，只要顺着左儿子不断的去搜索右子树就可以了，直到找到一个没有右子树的结点。那就是最大的了。 123456789101112131415161718TREE-DELETE(T, z) if left[z] = NIL or right[z] = NIL then y ← z else y ← TREE-SUCCESSOR(z) if left[y] ≠ NIL then x ← left[y] else x ← right[y] if x ≠ NIL then p[x] ← p[y] if p[y] = NIL then root[T] ← x else if y = left[p[y]] then left[p[y]] ← x else right[p[y]] ← x if y ≠ z then key[z] ← key[y] copy y's satellite data into z return y 红黑树的删除回到红黑树上来，红黑树结点删除的算法实现伪代码是： 12345678910111213141516171819RB-DELETE(T, z)if left[z] = nil[T] or right[z] = nil[T] then y ← z else y ← TREE-SUCCESSOR(z) if left[y] ≠ nil[T] then x ← left[y] else x ← right[y] p[x] ← p[y] if p[y] = nil[T] then root[T] ← x else if y = left[p[y]] then left[p[y]] ← x else right[p[y]] ← x if y ≠ z then key[z] ← key[y] copy y's satellite data into z if color[y] = BLACK then RB-DELETE-FIXUP(T, x) return y 在删除节点后，原红黑树的性质可能被改变，如果删除的是红色节点，那么原红黑树的性质依旧保持，此时不用做修正操作，如果删除的节点是黑色节点，原红黑树的性质可能会被改变，我们要对其做修正操作。那么哪些树的性质会发生变化呢，如果删除节点不是树唯一节点，那么删除节点的那一个支的到各叶节点的黑色节点数会发生变化，此时性质5被破坏。如果被删节点的唯一非空子节点是红色，而被删节点的父节点也是红色，那么性质4被破坏。如果被删节点是根节点，而它的唯一非空子节点是红色，则删除后新根节点将变成红色，违背性质2。 如下是修复操作的伪代码 1234567891011121314151617181920212223while x ≠ root[T] and color[x] = BLACK do if x = left[p[x]] then w ← right[p[x]] if color[w] = RED then color[w] ← BLACK ▹ Case 1 color[p[x]] ← RED ▹ Case 1 LEFT-ROTATE(T, p[x]) ▹ Case 1 w ← right[p[x]] ▹ Case 1 if color[left[w]] = BLACK and color[right[w]] = BLACK then color[w] ← RED ▹ Case 2 x ← p[x] ▹ Case 2 else if color[right[w]] = BLACK then color[left[w]] ← BLACK ▹ Case 3 color[w] ← RED ▹ Case 3 RIGHT-ROTATE(T, w) ▹ Case 3 w ← right[p[x]] ▹ Case 3 color[w] ← color[p[x]] ▹ Case 4 color[p[x]] ← BLACK ▹ Case 4 color[right[w]] ← BLACK ▹ Case 4 LEFT-ROTATE(T, p[x]) ▹ Case 4 x ← root[T] ▹ Case 4 else (same as then clause with \"right\" and \"left\" exchanged) color[x] ← BLACK 上面的修复情况看起来有些复杂，下面我们用一个分析技巧：我们从被删节点后来顶替它的那个节点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的节点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父节点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。 如果是以下情况，恢复比较简单： 当前节点是红+黑色。 直接把当前节点染成黑色，结束此时红黑树性质全部恢复。 当前节点是黑+黑且是根节点。 解法：什么都不做，结束。 但如果是以下情况呢？： 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑) 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意 此时，我们需要调用RB-DELETE-FIXUP(T, x)，来恢复与保持红黑性质的工作。 删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法（我们只讨论当前节点是其父节点左孩子时的情况）。此变换后原红黑树性质5不变，而把问题转化为兄弟节点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟节点为黑色的情况)。 即如下代码操作： 12345678while x ≠ root[T] and color[x] = BLACK do if x = left[p[x]] then w ← right[p[x]] if color[w] = RED then color[w] ← BLACK ▹ Case 1 color[p[x]] ← RED ▹ Case 1 LEFT-ROTATE(T, p[x]) ▹ Case 1 w ← right[p[x]] ▹ Case 1 状况由 变化为 删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。（此变换后性质5不变)。 123if color[left[w]] = BLACK and color[right[w]] = BLACK then color[w] ← RED ▹ Case 2 x ← p[x] ▹ Case 2 状况由 变化为 删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持。 12345else if color[right[w]] = BLACK then color[left[w]] ← BLACK ▹ Case 3 color[w] ← RED ▹ Case 3 RIGHT-ROTATE(T, w) ▹ Case 3 w ← right[p[x]] ▹ Case 3 状况由 变化为 删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确。 状况由 变化为 至此，红黑树的理论知识差不多讲完了。 红黑树源码：RedBlackTree.hpp 参考资料：红黑树(一)之 原理和算法详细介绍","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"树","slug":"数据结构/树","permalink":"http://hucoco.com/categories/数据结构/树/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"红黑树","slug":"红黑树","permalink":"http://hucoco.com/tags/红黑树/"}]},{"title":"红黑树实现（插入）","slug":"Tree/RBTree/红黑树实现（添加操作）","date":"2016-11-09T01:43:32.000Z","updated":"2016-12-11T02:41:10.000Z","comments":true,"path":"2016/11/09/Tree/RBTree/红黑树实现（添加操作）/","link":"","permalink":"http://hucoco.com/2016/11/09/Tree/RBTree/红黑树实现（添加操作）/","excerpt":"上一节《红黑树实现(旋转)》 红黑树基本操作添加将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下： 第一步: 将红黑树当作一颗二叉查找树，将节点插入。红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。 那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！","text":"上一节《红黑树实现(旋转)》 红黑树基本操作添加将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下： 第一步: 将红黑树当作一颗二叉查找树，将节点插入。红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。 那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！ 第二步：将插入的节点着色为”红色”。为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性： 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点是黑色。 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。 第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？ 对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。 对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。 对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。 对于”特性(4)”，是有可能违背的！ 那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。 添加操作伪代码123456789101112131415161718RB-INSERT(T, z) y ← nil[T] x ← root[T] while x ≠ nil[T] do y ← x if key[z] &lt; key[x] then x ← left[x] else x ← right[x] p[z] ← y if y = nil[T] then root[T] ← z else if key[z] &lt; key[y] then left[y] ← z else right[y] ← z left[z] ← nil[T] right[z] ← nil[T] color[z] ← RED RB-INSERT-FIXUP(T, z) 添加修复操作伪代码1234567891011121314151617RB-INSERT-FIXUP(T, z)while color[p[z]] = RED do if p[z] = left[p[p[z]]] then y ← right[p[p[z]]] if color[y] = RED then color[p[z]] ← BLACK ▹ Case 1 color[y] ← BLACK ▹ Case 1 color[p[p[z]]] ← RED ▹ Case 1 z ← p[p[z]] ▹ Case 1 else if z = right[p[z]] then z ← p[z] ▹ Case 2 LEFT-ROTATE(T, z) ▹ Case 2 color[p[z]] ← BLACK ▹ Case 3 color[p[p[z]]] ← RED ▹ Case 3 RIGHT-ROTATE(T, p[p[z]]) ▹ Case 3 else (same as then clause with \"right\" and \"left\" exchanged) color[root[T]] ← BLACK 情况编号 现象说明 处理策略 1 当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。 (01) 将“父节点”设为黑色。(02) 将“叔叔节点”设为黑色。(03) 将“祖父节点”设为“红色”。(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。 2 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子 (01) 将“父节点”作为“新的当前节点”。(02) 以“新的当前节点”为支点进行左旋。 3 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子 (01) 将“父节点”设为“黑色”。(02) 将“祖父节点”设为“红色”。(03) 以“祖父节点”为支点进行右旋。 C++实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697template &lt;class T&gt;bool RedBlackTree&lt;T&gt;::insert(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123; RedBlackNode&lt;T&gt;* y = nullptr; RedBlackNode&lt;T&gt;* x = root; while (x != nullptr) &#123; if(x-&gt;key == node-&gt;key)&#123; return false; &#125; y = x; if(node-&gt;key &lt; x-&gt;key) &#123; x = x-&gt;pLeft; &#125; else &#123; x = x-&gt;pRight; &#125; &#125; node-&gt;pParent = y; if(y != nullptr) &#123; if(node-&gt;key &lt; y-&gt;key) &#123; y-&gt;pLeft = node; &#125; else &#123; y-&gt;pRight = node; &#125; &#125; else &#123; root = node; &#125; set_red(node); insertFixUp(root, node); return true;&#125;template &lt;class T&gt;void RedBlackTree&lt;T&gt;::insertFixUp(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *node) &#123; RedBlackNode&lt;T&gt;* parent; RedBlackNode&lt;T&gt;* gparnet; while ((parent = get_parent(node))&amp;&amp;(is_red(parent))) &#123; gparnet = get_parent(parent); if(parent == gparnet-&gt;pLeft) &#123; RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pRight; if(uncle &amp;&amp; is_red(uncle)) &#123; set_black(uncle); set_black(parent); set_red(gparnet); node = gparnet; continue; &#125; if(parent-&gt;pRight == node) &#123; RedBlackNode&lt;T&gt;* tmp; leftRotate(root, parent); tmp = parent; parent = node; node = tmp; &#125; set_black(parent); set_red(gparnet); rightRotate(root, gparnet); &#125; else &#123; RedBlackNode&lt;T&gt;* uncle = gparnet-&gt;pLeft; if(uncle &amp;&amp; is_red(uncle)) &#123; set_black(uncle); set_black(parent); set_red(gparnet); node = gparnet; continue; &#125; if(parent-&gt;pLeft == node) &#123; RedBlackNode&lt;T&gt;* tmp; rightRotate(root, parent); tmp = parent; parent = node; node = tmp; &#125; set_black(parent); set_red(gparnet); leftRotate(root, gparnet); &#125; &#125; set_black(root);&#125; Case 1: 当前结点的父结点是红色，祖父结点的另一个子结点（叔叔结点）是红色。1234while z.p.color == RED do if z.p == z.p.p.left then y ← z.p.p.right if y.color == RED 此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。这里只考虑父结点为祖父左孩子的情况，如下图所示。 对此我们策略是：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。即如下代码所示： 1234then z.p.color ← BLACK ▹ Case 1 y.color ← BLACK ▹ Case 1 z.p.p.color ← RED ▹ Case 1 z ← z.p.p ▹ Case 1 于是，插入修复情况1转换成了插入修复情况2。 Case 2: 当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子此时，解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。即如下代码所示： 123else if z == z.p.right then z ← z.p ▹ Case 2 LEFT-ROTATE(T, z) ▹ Case 2 从而插入修复情况2转换成了插入修复情况3。 Case 3: 当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左孩子解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，操作代码为： 123z.p.color ← BLACK ▹ Case 3 z.p.p.color ← RED ▹ Case 3 RIGHT-ROTATE(T, z.p.p) ▹ Case 3 红黑树源码：RedBlackTree.hpp","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"树","slug":"数据结构/树","permalink":"http://hucoco.com/categories/数据结构/树/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"红黑树","slug":"红黑树","permalink":"http://hucoco.com/tags/红黑树/"}]},{"title":"红黑树实现（旋转）","slug":"Tree/RBTree/红黑树","date":"2016-11-08T06:51:56.000Z","updated":"2016-12-11T02:40:58.000Z","comments":true,"path":"2016/11/08/Tree/RBTree/红黑树/","link":"","permalink":"http://hucoco.com/2016/11/08/Tree/RBTree/红黑树/","excerpt":"二叉树复习二叉树有以下特性： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值。 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值。 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点。 红黑树简介红黑树是一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红或黑。 红黑树特性 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 Notes: 特性(3)中的叶子节点，是只为空(NIL或null)的节点。 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。","text":"二叉树复习二叉树有以下特性： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值。 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值。 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点。 红黑树简介红黑树是一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红或黑。 红黑树特性 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 Notes: 特性(3)中的叶子节点，是只为空(NIL或null)的节点。 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。 红黑树应用红黑树的应用特别广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。 STL中的Set、Map。 Java中的TreeSet、TreeMap。 Linux中的虚拟内存管理。 红黑树基本操作左旋12345 z x / / \\ --(左旋)--&gt; xy z / y 对x进行左旋，意味着”将x变成一个左节点”。 伪代码123456789101112LEFT-ROTATE(T, x) y ← right[x] right[x] ← left[y] p[left[y]] ← x p[y] ← p[x] if p[x] = nil[T] then root[T] ← y else if x = left[p[x]] then left[p[x]] ← y else right[p[x]] ← y left[y] ← x p[x] ← y C++实现1234567891011121314151617181920212223242526template &lt;class T&gt;void RedBlackTree&lt;T&gt;::leftRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *x) &#123; RedBlackNode&lt;T&gt; *y = x-&gt;pRight; x-&gt;pRight = y-&gt;pLeft; if(y-&gt;pLeft != nullptr) &#123; y-&gt;pLeft-&gt;pParent = x; &#125; y-&gt;pParent = x-&gt;pParent; if(x-&gt;pParent == nullptr) &#123; root = y; &#125; else &#123; if(x-&gt;pParent-&gt;pLeft == x) &#123; x-&gt;pParent-&gt;pLeft = y; &#125; else &#123; x-&gt;pParent-&gt;pRight = y; &#125; &#125; y-&gt;pLeft = x; x-&gt;pParent = y; &#125; 右旋12345 y x \\ / \\ --(右旋)--&gt; xy z \\ z 对x进行左旋，意味着”将x变成一个左节点”。 伪代码123456789101112RIGHT-ROTATE(T, y) x ← left[y] left[y] ← right[x] p[right[x]] ← y p[x] ← p[y] if p[y] = nil[T] then root[T] ← x else if y = right[p[y]] then right[p[y]] ← x else left[p[y]] ← x right[x] ← y p[y] ← x C++实现12345678910111213141516171819202122232425262728template &lt;class T&gt;void RedBlackTree&lt;T&gt;::rightRotate(RedBlackNode&lt;T&gt; *&amp;root, RedBlackNode&lt;T&gt; *y) &#123; RedBlackNode&lt;T&gt; *x = y-&gt;pLeft; y-&gt;pLeft = x-&gt;pRight; if(x-&gt;pRight != nullptr) &#123; x-&gt;pRight-&gt;pParent = y; &#125; x-&gt;pParent = y-&gt;pParent; if(y-&gt;pParent == nullptr) &#123; root = x; &#125; else &#123; if(y-&gt;pParent-&gt;pRight == y) &#123; y-&gt;pParent-&gt;pRight = x; &#125; else &#123; y-&gt;pParent-&gt;pLeft = x; &#125; &#125; x-&gt;pRight = y; y-&gt;pParent = x; &#125; 红黑树源码：RedBlackTree.hpp","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/categories/数据结构/"},{"name":"树","slug":"数据结构/树","permalink":"http://hucoco.com/categories/数据结构/树/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://hucoco.com/tags/数据结构/"},{"name":"红黑树","slug":"红黑树","permalink":"http://hucoco.com/tags/红黑树/"}]},{"title":"位运算解N皇后问题","slug":"Algorithm/NQueens","date":"2016-09-20T03:38:04.000Z","updated":"2016-12-13T04:11:16.000Z","comments":true,"path":"2016/09/20/Algorithm/NQueens/","link":"","permalink":"http://hucoco.com/2016/09/20/Algorithm/NQueens/","excerpt":"","text":"问题概述八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。而且仅当 n = 1 或 n ≥ 4 时问题有解。 八皇后问题最早是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出。之后陆续有数学家对其进行研究，其中包括高斯和康托，并且将其推广为更一般的n皇后摆放问题。八皇后问题的第一个解是在1850年由弗朗兹·诺克给出的。诺克也是首先将问题推广到更一般的n皇后摆放问题的人之一。1874年，S.冈德尔提出了一个通过行列式来求解的方法，这个方法后来又被J.W.L.格莱舍加以改进。 艾兹格·迪杰斯特拉在1972年用这个问题为例来说明他所谓结构性编程的能力。 八皇后问题出现在1990年代初期的著名电子游戏第七访客中。 算法源码123456789101112int NQueens(int n) &#123; int upperlim = (1 &lt;&lt; n) - 1, sum = 0; std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123; if(row == upperlim) &#123;++sum;return;&#125; for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123; pos = cur &amp; (-cur); cur -= pos; &#125; &#125;; dfs(0,0,0); return sum;&#125; 这里用到了C++的匿名函数，不太了解的朋友可以去查一下。 详解初始化1int upperlim = (1 &lt;&lt; n) - 1, sum = 0; upperlim的值位n位二进制1，这个不难理解。 递归函数1234567std::function&lt;void(int,int,int)&gt; dfs = [&amp;](int row,int ld,int rd) &#123; if(row == upperlim) &#123;++sum;return;&#125; for(int cur = upperlim &amp; (~(row|ld|rd)),pos = 0;cur ;dfs(row|pos,(ld|pos)&lt;&lt;1,(rd|pos)&gt;&gt;1)) &#123; pos = cur &amp; (-cur); cur -= pos; &#125;&#125;; 函数有三个参数： row 纵列 ld 左对角线 rd 右对角线 通过这三个参数来判断某个位置能否放置皇后。 分步图解这里用六皇后问题做一个分步图解。 12345row = 000001ld = 000010rd = 000000cur = 111100pos = 000100 12345row = 000101ld = 001100rd = 000010 cur = 110000pos = 010000 12345row = 010101ld = 111000rd = 001001 cur = 000010pos = 000010 12345row = 010111ld = 110100rd = 000101 cur = 001000，pos = 001000 12345row = 011111ld = 111000rd = 000110cur = 000000pos = 000000 第一轮查找就完成了，这里还有一种思想是深度优先搜索，也就是直捣黄龙找出一个解之后再去找第二个解，因为八皇后问题属于图论范围，所以图论的思想也能在这个问题中找到。","categories":[{"name":"算法","slug":"算法","permalink":"http://hucoco.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hucoco.com/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"},{"name":"N皇后问题","slug":"N皇后问题","permalink":"http://hucoco.com/tags/N皇后问题/"},{"name":"位运算","slug":"位运算","permalink":"http://hucoco.com/tags/位运算/"}]},{"title":"光线追踪","slug":"Graphics/Ray Tracing","date":"2016-08-16T09:13:12.000Z","updated":"2016-12-10T06:55:06.000Z","comments":true,"path":"2016/08/16/Graphics/Ray Tracing/","link":"","permalink":"http://hucoco.com/2016/08/16/Graphics/Ray Tracing/","excerpt":"简述这一部分的内容会详细记录如何实现光线追踪(Ray Tracing)算法，该算法在CPU中完成计算，且是非实时的，最后的结果为渲染好的一张图片。 这一部分完成会，还会有一个使用OpenGL实现实时光线追踪。 首先我们需要准备建立这个项目，你需要如下东西： 一个熟悉的C++的IDE，我用的Xcode FreeImage库（当然也可以使用其他图像库，例如OpenCV等） 相关数学资料（后面会详细介绍，例如空间解析几何，线性代数等） 相关IDE就不在这里多说废话了，这里重点说下FreeImage在MacOS平台下的配置问题。 首先我们需要去下载一个FreeImage库，我使用的版本是3.1.5.4这个版本，其他版本配置问题可能会有差异，下面为每一步的详细步骤。","text":"简述这一部分的内容会详细记录如何实现光线追踪(Ray Tracing)算法，该算法在CPU中完成计算，且是非实时的，最后的结果为渲染好的一张图片。 这一部分完成会，还会有一个使用OpenGL实现实时光线追踪。 首先我们需要准备建立这个项目，你需要如下东西： 一个熟悉的C++的IDE，我用的Xcode FreeImage库（当然也可以使用其他图像库，例如OpenCV等） 相关数学资料（后面会详细介绍，例如空间解析几何，线性代数等） 相关IDE就不在这里多说废话了，这里重点说下FreeImage在MacOS平台下的配置问题。 首先我们需要去下载一个FreeImage库，我使用的版本是3.1.5.4这个版本，其他版本配置问题可能会有差异，下面为每一步的详细步骤。 Step 1 – 修改 Makefile 文件Step 1.1找到Makefile.osx文件，这个是MacOS平台下的Makefile配置信息，但是官方提供的配置信息已经不能完成MacOS下的编译工作，所以需要全部替换为一下配置信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# -*- Makefile -*-# Mac OSX makefile for FreeImageinclude Makefile.srcs# General configuration variables:CC_I386 = ClangCC_X86_64 = ClangCPP_I386 = Clang++CPP_X86_64 = Clang++COMPILERFLAGS = -Os -fexceptions -fvisibility=hidden -DNO_LCMS -D__ANSI__ -mmacosx-version-min=10.7 -DDISABLE_PERF_MEASUREMENT #-g -DDEBUGCOMPILERFLAGS_I386 = -arch i386COMPILERFLAGS_X86_64 = -arch x86_64COMPILERPPFLAGS = -Wno-ctor-dtor-privacy -D__ANSI__ -stdlib=libc++INCLUDE +=INCLUDE_I386 = -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkINCLUDE_X86_64 = -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkCFLAGS_I386 = $(COMPILERFLAGS) $(COMPILERFLAGS_I386) $(INCLUDE) $(INCLUDE_I386)CFLAGS_X86_64 = $(COMPILERFLAGS) $(COMPILERFLAGS_X86_64) $(INCLUDE) $(INCLUDE_X86_64)CPPFLAGS_I386 = $(COMPILERPPFLAGS) $(CFLAGS_I386)CPPFLAGS_X86_64 = $(COMPILERPPFLAGS) $(CFLAGS_X86_64)LIBRARIES_I386 = -Wl,-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkLIBRARIES_X86_64 = -Wl,-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkLIBTOOL = libtoolLIPO = lipoTARGET = freeimageSTATICLIB = lib$(TARGET).aSHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).dylibLIBNAME = lib$(TARGET).$(VER_MAJOR).dylibHEADER = Source/FreeImage.h.SUFFIXES: .o-i386 .o-x86_64MODULES_I386 = $(SRCS:.c=.o-i386)MODULES_X86_64 = $(SRCS:.c=.o-x86_64)MODULES_I386 := $(MODULES_I386:.cpp=.o-i386)MODULES_X86_64 := $(MODULES_X86_64:.cpp=.o-x86_64)PREFIX = /usr/localINSTALLDIR = $(PREFIX)/libINCDIR = $(PREFIX)/includedefault: allall: distdist: FreeImage cp *.a Dist cp Source/FreeImage.h Dist# cp *.dylib DistFreeImage: $(STATICLIB)#$(STATICLIB) $(SHAREDLIB)$(STATICLIB): $(STATICLIB)-x86_64 $(LIPO) -create $(STATICLIB)-x86_64 -output $(STATICLIB)#$(STATICLIB): $(STATICLIB)-i386 $(STATICLIB)-x86_64# $(LIPO) -create $(STATICLIB)-i386 $(STATICLIB)-x86_64 -output $(STATICLIB)$(STATICLIB)-i386: $(MODULES_I386) $(LIBTOOL) -arch_only i386 -o $@ $(MODULES_I386)$(STATICLIB)-x86_64: $(MODULES_X86_64) $(LIBTOOL) -arch_only x86_64 -o $@ $(MODULES_X86_64)$(SHAREDLIB): $(SHAREDLIB)-i386 $(SHAREDLIB)-x86_64 $(LIPO) -create $(SHAREDLIB)-i386 $(SHAREDLIB)-x86_64 -output $(SHAREDLIB)$(SHAREDLIB)-i386: $(MODULES_I386) $(CPP_I386) -arch i386 -dynamiclib $(LIBRARIES_I386) -o $@ $(MODULES_I386)$(SHAREDLIB)-x86_64: $(MODULES_X86_64) $(CPP_X86_64) -arch x86_64 -dynamiclib $(LIBRARIES_X86_64) -o $@ $(MODULES_X86_64).c.o-i386: $(CC_I386) $(CFLAGS_I386) -c $&lt; -o $@.c.o-x86_64: $(CC_X86_64) $(CFLAGS_X86_64) -c $&lt; -o $@.cpp.o-i386: $(CPP_I386) $(CPPFLAGS_I386) -c $&lt; -o $@.cpp.o-x86_64: $(CPP_X86_64) $(CPPFLAGS_X86_64) -c $&lt; -o $@install: install -d -m 755 -o root -g wheel $(INCDIR) $(INSTALLDIR) install -m 644 -o root -g wheel $(HEADER) $(INCDIR) install -m 644 -o root -g wheel $(SHAREDLIB) $(STATICLIB) $(INSTALLDIR) ranlib -sf $(INSTALLDIR)/$(STATICLIB) ln -sf $(SHAREDLIB) $(INSTALLDIR)/$(LIBNAME)clean: rm -f core Dist/*.* u2dtmp* $(MODULES_I386) $(MODULES_X86_64) $(STATICLIB) $(STATICLIB)-i386 $(STATICLIB)-x86_64 $(SHAREDLIB) $(SHAREDLIB)-i386 $(SHAREDLIB)-x86_64 Step 1.2我们需要根据自己的系统信息来修改一下配置信息，以便和我们的MaxOS SDK版本对应，为gcc/g++编译做好准备工作。 找到以下代码： 12345678INCLUDE_I386 = -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkINCLUDE_X86_64 = -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkCFLAGS_I386 = $(COMPILERFLAGS) $(COMPILERFLAGS_I386) $(INCLUDE) $(INCLUDE_I386)CFLAGS_X86_64 = $(COMPILERFLAGS) $(COMPILERFLAGS_X86_64) $(INCLUDE) $(INCLUDE_X86_64)CPPFLAGS_I386 = $(COMPILERPPFLAGS) $(CFLAGS_I386)CPPFLAGS_X86_64 = $(COMPILERPPFLAGS) $(CFLAGS_X86_64)LIBRARIES_I386 = -Wl,-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdkLIBRARIES_X86_64 = -Wl,-syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk 关注MacOSX10.11.sdk这个地方，这个是当前系统版本对应的SDK，根据自己的版本号来设置。下面为两种看自己系统版本号的方法，第二种会更加准确。 你可以在关于本机中看到你的系统版本号 在Applications找到Xcode，并右键点击显示包内容，按以下顺序进入到SDKs文件夹中：Contents--Developer--Platforms--MacOSX.platform--Developer--SDKs，这个文件夹中的SDK都可以使用，一般情况下只会有一种SDK，也就是当前版本的SDK，使用那一个就对了。 Step 2 – 修改 FreeImage 中的错误顺着以下路径找到ImfAutoArray.h文件： Source--OpenEXR--IlmImf 之后再这个文件的相应位置添加如下一句话： 1#include&lt;cstring&gt; 或者其他和这个string库匹配的头文件也可以。 这里可能是FreeImage制作者的一点小马虎吧。 Step 3 – 开始编译打开CMD，跳转到对应的FreeImage文件下，然后输入make，接下来就是等待成功吧。 如果有额外问题，可以联系我，我们一起解决它。 完成编译后，你会看的到该目录下Dist文件下有一个FreeImage.a以及FreeImage.h，你可以找一个固定的地方存放他们，也可以不动他们。 Step 4 – 配置项目文件这里我们需要一个使用Xcode创建一个Command Line Tool项目，如果使用的Windows平台，可以使用Win32控制台程序项目，这里我只介绍MacOS下Xcode的配置。 选中TARGETS中的对应项目，点击到Build Phases中，在Link Binary With Libraryes中，将刚刚的FreeImage.a加入进去。 再点击到Build Setting，找到Search Paths部分，在Library Search和User Header Search Path中加入FreeImage.a对应的目录 修改Always Search User Path改为Yes Step 5 – 配置完成下一片，会实现一些基础数据类，顺带也可以熟悉下C++。 如果有错误，欢迎指正。","categories":[{"name":"图形学","slug":"图形学","permalink":"http://hucoco.com/categories/图形学/"},{"name":"光线追踪","slug":"图形学/光线追踪","permalink":"http://hucoco.com/categories/图形学/光线追踪/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"http://hucoco.com/tags/图形学/"},{"name":"FreeImage","slug":"FreeImage","permalink":"http://hucoco.com/tags/FreeImage/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://hucoco.com/tags/光线追踪/"}]},{"title":"深入探讨const关键字","slug":"Cpp/const_keyword","date":"2016-06-09T10:33:58.000Z","updated":"2016-08-25T04:49:22.000Z","comments":true,"path":"2016/06/09/Cpp/const_keyword/","link":"","permalink":"http://hucoco.com/2016/06/09/Cpp/const_keyword/","excerpt":"这一次我准备用一个实际的例子来更加深入的探讨const关键字，可能这个例子不是特别的符合要求。这个例子的需求是这样的：我们需要一个画折线的对象，这个对象可以添加新的点，也可以删除的点，为了方便实践，我们规定这个折线最多由20个点组成，并且可以输出当前点的个数和所有点的信息。首先我们来分析一下需求： 创建这样的一个简单对象，我们需要一个Point类和Line类，而且他们的关系属于has-a，所以应该用组合的方式实现。 Point类中需要存储点的坐标信息，并且可以修改和获取这些信息。 Line类中需要存储点的信息，并且可以修改和获取这些信息，以及获取总共的点的数量，删除的点的功能。","text":"这一次我准备用一个实际的例子来更加深入的探讨const关键字，可能这个例子不是特别的符合要求。这个例子的需求是这样的：我们需要一个画折线的对象，这个对象可以添加新的点，也可以删除的点，为了方便实践，我们规定这个折线最多由20个点组成，并且可以输出当前点的个数和所有点的信息。首先我们来分析一下需求： 创建这样的一个简单对象，我们需要一个Point类和Line类，而且他们的关系属于has-a，所以应该用组合的方式实现。 Point类中需要存储点的坐标信息，并且可以修改和获取这些信息。 Line类中需要存储点的信息，并且可以修改和获取这些信息，以及获取总共的点的数量，删除的点的功能。 首先看看Point.h123456789101112131415class Point&#123;private: int x; int y; bool isInit;public: Point(); Point(const int&amp; _x,const int&amp; _y); void updateXY(const int&amp; _x,const int&amp; _y); int getX() const &#123;return x;&#125; int getY() const &#123;return y;&#125; bool getIsInit() const &#123;return isInit;&#125; void display() const;&#125;; x,y表示点的坐标，isInit表示这个点是否被初始化。 有参构造函数中和updateXY方法中，参数我们使用的const reference to int的类型，这样做的原因是因为我们只需要传递这个值进入这个方法。 而在get以及display方法中，我们只需要传递某一个值出去，并不需要函数去修改某些变量，所以我们将方法标记为const。 接下来我们在看看Point.cpp1234567891011121314151617181920Point::Point():x(0),y(0),isInit(false)&#123; &#125;Point::Point(const int&amp; _x,const int&amp; _y):x(_x),y(_y),isInit(true)&#123; &#125;void Point::updateXY(const int &amp;_x, const int &amp;_y)&#123; x = _x; y = _y;&#125;void Point::display() const&#123; printf(\"(%d,%d)\\n\",x,y);&#125; 实现很简单，但是这里我需要谈谈另外一个话题，关于初始化的问题。我相信很多初学者都是这样实现第一个无参构造函数的：123456Point::Point()&#123; x = 0; y = 0; isInit = false;&#125; 这样的做法叫做赋值，而非初始化，C++有一条这样的规定，在成员变量的初始化动作发生在进入构造函数本体之前。换句话说，你应该使用参数列表去初始化所有的成员变量，就像示例代码中所实现的一样。这样做符合C++规定并在效率也会更高。 接下来回归正题，我们来细谈Line类的实现，我们先谈谈成员变量：1234567class Line&#123;private: Point pointArray[20]; int count; bool countIsValid;&#125; 我们需要一个长度为20的Point的数组，这个没什么好多说的。 count变量用来表示当前Line中所存储的点的数量，countIsValid用来表示点的数量是否发生的变化 接下来我们来看看怎么实现所有需要的函数，首先是构造函数：123Line::Line():count(0),countIsValid(true)&#123;&#125; 构造函数的实现方法我上面说过了，还是请记住构造函数，并不是赋值函数。接下来是添加点的函数实现：123456789101112void Line::addPoint(const Point &amp;_new)&#123; for(int i = 0 ; i &lt; 20 ; i++) &#123; if(!pointArray[i].getIsInit()) &#123; pointArray[i] = _new; break; &#125; &#125; countIsValid = false;&#125; 参数我们只是需要值就行，而不是需要对象，所以我们使用const reference类型进行传递就行了，函数中我们遍历到我们第一个没有使用的空间时，便使用这一空间存储当前传入的数据。 这段实现很不合实际，但是我只想想为后面最关键的部分做铺垫而已，大家就不要吐槽了。 123456789101112131415void Line::deletePointByIndex(const int &amp;_index)&#123; for(int i = _index;i&lt;=20;i++) &#123; if(pointArray[i+1].getIsInit()) &#123; pointArray[i] = pointArray[i+1]; pointArray[i+1] = Point(); &#125; else &#123; break; &#125; &#125;&#125; 根据下标删除一个点，然后将后面的点前向靠拢的一个操作。没有什么特别的地方。接下来就这一次的重点，重载[]：123456789101112const Point&amp; Line::operator[] (const int&amp; _index) const&#123; if(_index &gt;= 20) &#123; throw \"Error\"; &#125; if(!pointArray[_index].getIsInit()) &#123; throw \"Error\"; &#125; return pointArray[_index];&#125; 第一个if语句用来表示下标超出的范围，然后抛出一个错误，第二个下标用来检测当前点是不是有有效数据，如果没有就会抛出一个错误，错误处理实现的很简单，因为这不是重点。这里我们返回的是一个const Point&amp;类型的值并且函数也为const类型，因为我们不希望函数修改任何值，只是用来返回一个值。然后我们发现返回的这个值并不能被操作，这个不是我们想要的，于是我们需要再次重载一个返回Point&amp;类型的函数，但是如果我们的类特别复杂，前面的检查方法十分的复杂，我们再这样写一遍就特别的麻烦，对了我们有粘贴复制，但整体代码会显得很长，或与又有人说，可以把检查方法写一成一个函数，但是并有这样的必要，因为这样的函数并非广泛使用，下面我就来说一种特别的方法：1234Point&amp; Line::operator[] (const int&amp; _index)&#123; return const_cast&lt;Point&amp;&gt;(static_cast&lt;const Line&amp;&gt;(*this)[_index]);&#125; 首先我们将本对象转化为一个const Line&amp;的对象，因为我们只想使用值并不想修改static_cast(this)帮助我们完成了这样的想法，然后我们使用了static_cast(this)[_index]返回的const Point&amp;类型的值，但是我们需要去掉const关键字，这里使用了const_cast()这个方法，它可以帮我们去掉const关键字。这样我们就可以做这样的事情了：123Line l1;l1.addPoint(Point(3,3));l1[0].display(); 接下来我们来说说怎么实现返回当前点的总和，上面那段烂代码也是为了这段代码出现的必要，因为它要告诉大家一个重要的关键字。12345678910111213141516int Line::getPointCount() const&#123; if(!countIsValid) &#123; count = 0; for(int i = 0 ; i &lt; 20 ; i++) &#123; if(pointArray[i].getIsInit()) &#123; count++; &#125; &#125; countIsValid = true; &#125; return count;&#125; 作为一个获取某个值的函数，它同样被设置成为了const类型，但是我们在这个函数中改变了count和countIsValid的量，为了完成这个方法，我们需要修改一个成员变量的类型：12mutable int count;mutable bool countIsValid; mutable这个关键字，允许这个变量在任何地方都可以被修改，即使它在const函数内。这样大家都懂了吧。 好了其他的函数都不重要了，代码怎么实现的也不重要，关键是他们使用的方法，如果你已经完全掌握了上面的方法，现在你可以自己写一个String类。const能帮助你完成安全性的工作。 下一次我们会分享一些构造/析构/赋值运算相关的内容。","categories":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"}]},{"title":"浅析const关键字","slug":"Cpp/const","date":"2016-06-09T07:45:01.000Z","updated":"2016-08-25T04:51:22.000Z","comments":true,"path":"2016/06/09/Cpp/const/","link":"","permalink":"http://hucoco.com/2016/06/09/Cpp/const/","excerpt":"const关键字它允许你指定一个语义的约束，也就是不允许被改动的对象，而编译器会帮助你实施这样的约束，这有有助于在团队协作中不去违反这样的规则。const可以用到的地方很多，你可以在classes外部去修饰global或者namespace作用域中的常量，或者修饰文件、函数、区块作用域中被声明为static的对象，也可以用它修饰classes内部的成员变量，而面对指针，你可以可以指出是对于指针自身，还是指针所指物，或者两个都不是。12345char authorName[] = \"HookCoco\";char* name = authorName; //1const char* name = authorName; //2char* const name = authorName; //3const char* const name = authorName; //4 指针可修改，数据可修改 指针可修改，数据不可修改 指针不可修改，数据可修改 指针不可修改，数据不可修改","text":"const关键字它允许你指定一个语义的约束，也就是不允许被改动的对象，而编译器会帮助你实施这样的约束，这有有助于在团队协作中不去违反这样的规则。const可以用到的地方很多，你可以在classes外部去修饰global或者namespace作用域中的常量，或者修饰文件、函数、区块作用域中被声明为static的对象，也可以用它修饰classes内部的成员变量，而面对指针，你可以可以指出是对于指针自身，还是指针所指物，或者两个都不是。12345char authorName[] = \"HookCoco\";char* name = authorName; //1const char* name = authorName; //2char* const name = authorName; //3const char* const name = authorName; //4 指针可修改，数据可修改 指针可修改，数据不可修改 指针不可修改，数据可修改 指针不可修改，数据不可修改 简单来说如果const出现在星号的左边，表示被指物是常量，如果出现在右边，表示指针自身是常量，如果都出现，表示被指物和指针自身都是常量。而对于被指物是常量的写法有以下两种：12void f1(const char* name);void f2(char const * name); 这两种写法都是可行的，使用哪一种都可以，我习惯于用前者。 STL迭代器系以指针为根据塑模出来，所以迭代器的作用就像一个T指针，申明迭代器为const就想声明指针为const一样（T* const），它表示这个迭代器不能指向不同的东西，但是内容数据是可以修改的，如果你希望迭代器所指的东西不可被改动，你需要的是const_iterator:12345678std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; //1++iter; //2std::vector&lt;int&gt;::const_iterator cIter = vec.begin();*cIter = 10; //3++cIter; //4 上述代码不完全正确，你觉得哪些是对的，哪些是错的呢？ 这句是对的，因为iter的被指物是可以被修改的 这句不对，因为iter是const 这句不对，因为*cIter是const 这句是对的，可以改变cIter 好了热身已经结束了，const最有威力的作用是面对函数声明时的应用，在一个函数声明中，你可以在参数，函数自身，返回值使用const 让函数的返回值为一个常量值，往往可以降低因客户错误而造成的意外而又不至于放弃安全性和高效性，举个栗子！12class Rational &#123;...&#125;;const Rational operator* (const Rational&amp; lhs,const Rational&amp; rhs)； 很多人就要问了，为什么要返回一个const对象？原因很简单，避免某些人错误的使用这样的函数：12Rational a,b,c;(a * b) = c; 如果不返回const关键字，这样做就是可行的，编译器并不会阻止你敢这样的蠢事。1if( a * b = c) 如果你手误写出这样代码，编译器也是不会阻止你的。返回const常量可以避免没必要的赋值操作，进而可以避免造成更多的错误，何乐而不为呢？ const成员函数 将const实施与成员函数的目的，是为了确认该成员函数可以作用于const对象身上。这一类函数很重要，原因有二： 这样做使class接口比较容易被理解，因为知道哪些函数可以改动对象内容而哪些函数不行是很重要的一件事。 它们使“操作const”对象成为可能。 很多人是忽视这样一个事实：两个成员函数如果只是常量性不同，可以被重载。这是C++的一个很重要很重要很重的特性。考虑以下这个class，用于表现一个长文本：123456789class TextBlock&#123;public: ··· const char&amp; operator[](std::size_t position) const &#123; return text[position]; &#125; char&amp; operator[](std::size_t position) const &#123; return text[position]; &#125;private: std::string text;&#125;; TextBlock的operator[]s可被这样使用：1234TextBlock tb(\"Hello\");std::cout &lt;&lt; tb[0];const TextBlock ctb(\"World\");std::cout &lt;&lt; ctb[0]; 前者调用non-const函数，后者调用const函数。顺带提一下，真实的程序中const对象大多用于 passed by pointer-to-const 或者 passed reference-to-const，比如下面：12345void print(const TextBlock&amp; ctb)&#123; std::cout &lt;&lt; ctb[0] ···&#125; 回到刚刚的话题，只要重载operator[]并对不同的版本给予不同的返回值类型，就可以令const和non-const获得不同的处理：1234std::cout &lt;&lt; tb[0];tb[0] = 'X';std::cout &lt;&lt; ctb[0];ctb[0] = 'X'; 上面这段代码的最后一行很明显是错误的，因为ctb是const类型的对象，不允许修改数据。还有一点也需要注意，non-const operator[]方法的返回值为reference to char，而不是char，若果是后者的话，第二行的这样的语句也无法通过编译，那是因为如果函数的返回值是一个内置类型，那么改动函数返回值从来就不合法，即使是合法的，C++以by value返回对象这一个规则意味被改动的其实是tb.text[0]的副本，不是tb.text[0]本身，不搞清楚这点的话，很多初学者都会头疼，比如以前的我····2333333 这一次我们就讲到这里，下一次我们会更加深入的探讨const关键字，如果你有时间，你可以仔细的考虑下operator[]的两个方法，他们其实是有些问题的。","categories":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"}]},{"title":"慎用#define","slug":"Cpp/#define","date":"2016-06-08T10:33:38.000Z","updated":"2016-08-25T04:49:26.000Z","comments":true,"path":"2016/06/08/Cpp/#define/","link":"","permalink":"http://hucoco.com/2016/06/08/Cpp/#define/","excerpt":"在我们学习C的时候，会常常使用到 #define 关键字来定义一些我们需要的元素，比如：1#define MATH_PI 3.1415 记号MATH_PI可能从未被编译器看见，也可能在编译器开始处理源码之前它就被预编译处理器移走了。于是MATH_PI有可能没进入记号表内。之后当以使用它时但获得了一个错误信息，可能你没法办很快的找到是哪里出现的问题，因为这个错误信息可能会提到3.1415而不是MATH_PI，若果他是你的小伙伴写的那一部分，但你并不知道，这可能会折腾你很久，处理这样的问题就非常的浪费时间。解决的办法很简单，就是以一个常量来替换上述的宏：1const double MathPI = 3.1415; 这样MathPI可能会被编译器看到并记入记号表内，这样就绝不会出现刚刚的情况。 这里在说一些题外话：我们在以不同的方式定义元素的时候，应该按照定于方式的规范来命名，比如这里的宏，我们使用的全大写+下划线来表示，而常量我们使用另外一种命名方式来表示，以此我们就可以区分不同的方式定义的元素。","text":"在我们学习C的时候，会常常使用到 #define 关键字来定义一些我们需要的元素，比如：1#define MATH_PI 3.1415 记号MATH_PI可能从未被编译器看见，也可能在编译器开始处理源码之前它就被预编译处理器移走了。于是MATH_PI有可能没进入记号表内。之后当以使用它时但获得了一个错误信息，可能你没法办很快的找到是哪里出现的问题，因为这个错误信息可能会提到3.1415而不是MATH_PI，若果他是你的小伙伴写的那一部分，但你并不知道，这可能会折腾你很久，处理这样的问题就非常的浪费时间。解决的办法很简单，就是以一个常量来替换上述的宏：1const double MathPI = 3.1415; 这样MathPI可能会被编译器看到并记入记号表内，这样就绝不会出现刚刚的情况。 这里在说一些题外话：我们在以不同的方式定义元素的时候，应该按照定于方式的规范来命名，比如这里的宏，我们使用的全大写+下划线来表示，而常量我们使用另外一种命名方式来表示，以此我们就可以区分不同的方式定义的元素。 当我们使用const来代替#define时，有两种特殊的情况需要提一下。 定义常量指针由于常量定义通常放在头文件内，这样便于被不同的源码包含，因此有必要将指针声明为const，若要定义一个不变的指针，就必须const两次：1const char* const authorName = \"Hook\"; 为什么要这样做，在后面的文章中我会讲到。这里还会有更好的方法，我也更建议使用下面这样的方法。1const std::string authorName(\"Hook\"); Class专有常量为了将常量的作用于限制在类中，就必须把常量成为类的一个成员，为了保证只有一份这样的实体，就必须让它成为一个static成员123456class BaseSkill&#123; pirvate: static const double CoolDownTime = 2.5; ...&#125; 但是这种写法并不好，因为C++要求每一个元素都应该有它的定义式，而这种写法是声明式，所以建议使用一下的这种方式：*.h123456class BaseSkill&#123; pirvate: static const double CoolDownTime; ...&#125; *.cpp1const double BaseSkill::CoolDownTime = 2.5; 这样的功能#define就没有办法完成，因为#define对作用域是不敏感的，只要#define被定义，直到它被#undef，否则它将一直有用，所有任何有封装性的方法都不能使用它。倘若Class在编译期间就需要使用一个常量又该怎么办呢，比如我们需要声明一个数组，编译器必须要在编译期间就要直到这个数组的长度，但这时候编译器不允许static const常量来完整这个任务，这里就需要用到一种就做“the enum hack”的补偿做法。 因为一个枚举类型的数值可以当做ints来使用 1234567class DataBuffer&#123; private: enum &#123; BufferLength = 100 &#125;; int Buffer[BufferLength]; ...&#125; enum是很值得我们深度认识的元素，它比较像#define而不像const，这也是它优秀的地方。 接下来我们回到#define上来，通常我们习惯用#define去写一些宏函数，这东西很棒，但是需要格外的注意一些情况，比如下面这段代码：1#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) :(b)) 这个应该不难理解，选取a和b中较大的作为f(int)的参数传入。这里再说点其他的，书写宏函数时，实参一定要用括号包起来，不然你会经历绝望。当然就算我们括起来了，接下来也会经历绝望。123int a = 4,b = 2;CALL_WITH_MAX(++a,b);CALL_WITH_MAX(++a,b+8); 你能想象结果是什么么？12f(5);f(10); 我想大部分会认为是上面这个结果，但是你错了，我们完全还原一下函数：12f((++a)&gt;(b) ? (++a):(b))f((++a)&gt;(b+8) ? (++a):(b+8)) 现在应该清楚了吧！a的值取决于a被使用的次数，而且这样的错误使我们不能明确控制的，但是template inline函数会完全解决这个问题。12345template&lt;typename T&gt;inline void callWithMax(const T&amp; a,const T&amp; b)&#123; f(a &gt; b ? a :b)&#125; T可以代表你所需要的一切类型，只要他们能拿来比较，大的一个就会成为f的参数传入，而且你也可以把它作为某一个类的成员，宏是没有办法完成的。 好了，这一章就到这里，简单概括一下： 对于常量，使用const或者enum来代替#define 对于函数，使用template inline来代替#define 下一次我们会来细细的讨论下const这个关键字。","categories":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hucoco.com/tags/C/"}]},{"title":"MacOS 配置 Hexo","slug":"Hexo/MacOS_Hexo","date":"2016-06-05T16:09:16.000Z","updated":"2016-06-09T16:22:52.000Z","comments":true,"path":"2016/06/06/Hexo/MacOS_Hexo/","link":"","permalink":"http://hucoco.com/2016/06/06/Hexo/MacOS_Hexo/","excerpt":"前言 Hexo基于Node.js，由台湾大神tommy351开发，可以实现一个静态网页组成的博客，而且更轻更快，使用也相当的简单。只要安装了Git和Node.js，我们就可以在电脑上快速的用Hexo来写作，Hexo同样支持评论、分类、标签、图片等。 特性 快速Hexo基于Node.js，支持多线程，几百篇文章也可以几秒生成。 流畅支持GitHub Flavored Markdown和Octopress的插件。 扩展Hexo支持EJS、Swig和Stylus，通过插件支持Haml、Jade、Less 下面就来给大家介绍下Hexo静态博客环境搭建的方法。","text":"前言 Hexo基于Node.js，由台湾大神tommy351开发，可以实现一个静态网页组成的博客，而且更轻更快，使用也相当的简单。只要安装了Git和Node.js，我们就可以在电脑上快速的用Hexo来写作，Hexo同样支持评论、分类、标签、图片等。 特性 快速Hexo基于Node.js，支持多线程，几百篇文章也可以几秒生成。 流畅支持GitHub Flavored Markdown和Octopress的插件。 扩展Hexo支持EJS、Swig和Stylus，通过插件支持Haml、Jade、Less 下面就来给大家介绍下Hexo静态博客环境搭建的方法。 先整理一下思路1.首先hexo是基于nodejs，所以需要安装nodejs（之前没有安装过的话）。2.安装nodejs的方法很多的，因为为了简单，而且网上的很多教程也是用的homebrew安装方式，我也就用的这个。3.安装homebrew方式很简单，因为mac自带了ruby，一句话就能搞定。4.hexo提交部署需要git部署到github，所以需要安装git工具。5.整理一下安装顺序，（homebrew-nodejs-hexo-git）— 1.安装homebrew打开终端，输入下面代码： ruby -e “$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”稍等片刻安装完成就可以了，因为正在下载，如果没有网速的话，可以关闭或者按下‘Ctrk+C’来结束进程并重新下载。值得注意的是输入这行代码也可能会提醒你输入的过旧，需要输入新的代码，只用复制那段代码然后轻敲回车就OK。 2.安装nodejs用homebrew安装，一句话搞定。 brew install node 3.安装hexo可以使用nodejs自带的npm进行安装。 npm install -g hexo 3.1创建hexo文件夹待安装完成之后，在自己想要的位置新建一个文件夹，例如在根目录新建。打开终端输入： mkdir blog cd blog hexo init 3.2安装依赖包 npm install 4.安装git安装好之后建议注册一个github账号，如果没有的话。 4.1homebrew安装 sudo brew install git 4.2配置 4.2.1检查SSH key cd ~/.ssh 4.2.2备份已有的key mkdir key_backup mv id_rsa* key_backup 4.2.3生成SSH key ssh-keygen -t rsa -C &quot;xxxx@xxxx.com&quot; xxxx@xxxx为自己的github账号。 4.2.4将SSH key添加到github 登录到gitHub页面，Account Settings-&gt;SSH Public Keys-&gt;Add another key将生成的key(id_rsa.pub文件）内容copy到输入框中，save。id_rsa.pub文件放在.ssh这个隐藏文件夹之下，因为当前就在这个目录，所以直接打开。 ls open id_rsa.pub 打开这个文件推荐使用Sublime Text 2(下同),复制里面的东西，然后到在网页上保存。 4.2.5测试连接 ssh git@github.com 如果现实连接成功，那就可以，不可以请重复以上步骤，找出错误的原因，或者把显示的错误信息代码复制到谷歌上面搜索。 4.2.6设置个人信息 git config --global user.name &quot;xxx” git config --global user.email &quot;xxx@xxx.com&quot; xxx是你自己的github的账号，xxx@xxx.com是注册邮箱。 5.创建github上面的repository 在自己的github主页右下角，创建一个新的repositpry。我的github账号是HuCoco，那么我就应该创建的repository名字为HuCoco.github.io. 6.部署在自己创建的blog下找到_config.yml这个文件并编辑，在最下面添加如下的语句。网址的HuCoco替换成自己账号即可。 deploy: type: git repository: http://github.com/HuCoco/HuCoco.github.io.git branch: master PS:三个冒号之后需要留一个空格，不然会引起错误。 至此，hexo博客的搭建已经完成，接下来可以执行下面代码在本地运行,查看效果 cd blog hexo g hexo s 然后在浏览器中输入localhost:4000就可以看到了。如果没有错误的话，可以执行 hexo d 完成之后，我们的博客就完全搭建起来了。在浏览器中输入HuCoco.github.io就可以访问了，去看看你的成果吧！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://hucoco.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hucoco.com/tags/Hexo/"}]},{"title":"Windows 配置 Hexo","slug":"Hexo/Windows_Hexo","date":"2016-06-04T16:08:57.000Z","updated":"2016-06-09T16:21:40.000Z","comments":true,"path":"2016/06/05/Hexo/Windows_Hexo/","link":"","permalink":"http://hucoco.com/2016/06/05/Hexo/Windows_Hexo/","excerpt":"先说一些废话 Hexo基于Node.js，由台湾大神tommy351开发，可以实现一个静态网页组成的博客，而且更轻更快，使用也相当的简单。只要安装了Git和Node.js，我们就可以在电脑上快速的用Hexo来写作，Hexo同样支持评论、分类、标签、图片等。 特性 快速Hexo基于Node.js，支持多线程，几百篇文章也可以几秒生成。 流畅支持GitHub Flavored Markdown和Octopress的插件。 扩展Hexo支持EJS、Swig和Stylus，通过插件支持Haml、Jade、Less 下面就来给大家介绍下Hexo静态博客环境搭建的方法。","text":"先说一些废话 Hexo基于Node.js，由台湾大神tommy351开发，可以实现一个静态网页组成的博客，而且更轻更快，使用也相当的简单。只要安装了Git和Node.js，我们就可以在电脑上快速的用Hexo来写作，Hexo同样支持评论、分类、标签、图片等。 特性 快速Hexo基于Node.js，支持多线程，几百篇文章也可以几秒生成。 流畅支持GitHub Flavored Markdown和Octopress的插件。 扩展Hexo支持EJS、Swig和Stylus，通过插件支持Haml、Jade、Less 下面就来给大家介绍下Hexo静态博客环境搭建的方法。 Hexo安装方法一、下载Git msysGit下载地址 进入上面的页面,点击Download会进入下载页面，找到Downloads部分，根据自己系统的情况选择下载32位或者64位的安装包，下载完成后进行安装。 二、下在Node.jsNode.js下载地址同样进入上面的界面，点击INSTALL下载安装包，下载完成后并安装。 三、安装Hexo完成上面两步后，此时当我们在桌面点击鼠标右键时，会有一系列新的选项，这里我们需要用到的Git Bash，接下来我们会用命令行来完成剩余的工作。 1.安装Hexo根据上面的方法，打开Git Bash控制台，之后系统会打开一个窗口，窗口内是黑色的背景和一堆英文，看不懂没有关系跟着步骤一步一步做就行。在控制台中输入以下命令：npm install -g hexo之后系统会自动去Git上下载并安装Hexo，接下来会一直循环显示/-\\这三个符号，这表示系统在下载需要的文件。但是根据笔者遇到的情况，使用npm安装可能会出现卡住的现象导致无法正常安装，解决的办法就是修改npm的安装源，大家可以选择以下方法中的一个即可（正常下载的朋友就略过这里）1. 通过config命令： npm config set registry http://registry.cnpmjs.org npm info underscore2. 通过命令行指定 npm -registry http://registry.cnpmjs.org info underscore然后再来执行一次最开始的命令：npm install -g hexo耐心等待一会儿，Hexo就下载好了。2.生成Hexo静态博客 选一个适合的地方存放博客文件 cd命令可以在命令行中快速指定到一个地址，比如： cd D:\\ D: 这样可以快速的指定要一个地址上去，然后是创建一个文件夹进行归类管理 mkdir blog 这样在D盘我们就创建了一个名字为blog的文件夹。接下来我们在进入blog文件夹中，同样使用cd命令。 cd blog 此时我们进入了我们选好的地址中，执行以下命令： hexo init 然后你会看到以下的反馈： [info] Copying data [info] You are almost done! Don&#39;t forget to run &#39;npm install&#39;... 所以接下来就要执行 npm install 等待他完成后我们可以进去到文件夹中看到以下目录： node_modules： Hexo的功能JavaScript文件 public：生成静态网页文件 scaffolds：工具模板 source： /_drafts-草稿文件夹 /_posts-文章文件夹 themes：用来存放皮肤的文件夹 _config.yml：全局配置文件 db.json：json格式的静态常量数据库 查看生成的静态网页 进入到blog的地址后，执行如下的命令： hexo generate 用来生成静态网页相关的文件，这些文件会存储在public中，也可使用简单的命令hexo g 然后再输入hexo server或者hexo s这样可以在本地查看自己生成的网页，现在打开浏览器（推荐使用的浏览器是Chrome和FireFox）,在地址栏输入localhost:4000或者点击这里 最后最初始的工作就做完了，下一步的任务就是如何吧网页托管到GitHub上，这样别人也能开你的博客了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://hucoco.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://hucoco.com/tags/Hexo/"}]}]}